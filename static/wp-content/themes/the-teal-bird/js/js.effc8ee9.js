parcelRequire = function (e, r, t, n) { var i, o = "function" == typeof parcelRequire && parcelRequire, u = "function" == typeof require && require; function f(t, n) { if (!r[t]) { if (!e[t]) { var i = "function" == typeof parcelRequire && parcelRequire; if (!n && i) return i(t, !0); if (o) return o(t, !0); if (u && "string" == typeof t) return u(t); var c = new Error("Cannot find module '" + t + "'"); throw c.code = "MODULE_NOT_FOUND", c } p.resolve = function (r) { return e[t][1][r] || r }, p.cache = {}; var l = r[t] = new f.Module(t); e[t][0].call(l.exports, p, l, l.exports, this) } return r[t].exports; function p(e) { return f(p.resolve(e)) } } f.isParcelRequire = !0, f.Module = function (e) { this.id = e, this.bundle = f, this.exports = {} }, f.modules = e, f.cache = r, f.parent = o, f.register = function (r, t) { e[r] = [function (e, r) { r.exports = t }, {}] }; for (var c = 0; c < t.length; c++)try { f(t[c]) } catch (e) { i || (i = e) } if (t.length) { var l = f(t[t.length - 1]); "object" == typeof exports && "undefined" != typeof module ? module.exports = l : "function" == typeof define && define.amd ? define(function () { return l }) : n && (this[n] = l) } if (parcelRequire = f, i) throw i; return f }({
    "nGBO": [function (require, module, exports) {
        var define;
        var e; !function (t, r) { "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof e && e.amd ? e(r) : (t = t || self).barba = r() }(this, function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function t(t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } function r() { return (r = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var r = arguments[t]; for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]) } return e }).apply(this, arguments) } function n(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } function o(e) { return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function i(e, t) { return (i = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function s(e, t, r) { return (s = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } }() ? Reflect.construct : function (e, t, r) { var n = [null]; n.push.apply(n, t); var o = new (Function.bind.apply(e, n)); return r && i(o, r.prototype), o }).apply(null, arguments) } function a(e) { var t = "function" == typeof Map ? new Map : void 0; return (a = function (e) { if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== t) { if (t.has(e)) return t.get(e); t.set(e, r) } function r() { return s(e, arguments, o(this).constructor) } return r.prototype = Object.create(e.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), i(r, e) })(e) } function u(e, t) { try { var r = e() } catch (e) { return t(e) } return r && r.then ? r.then(void 0, t) : r } "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))); var c, h = "2.9.7"; !function (e) { e[e.off = 0] = "off", e[e.error = 1] = "error", e[e.warning = 2] = "warning", e[e.info = 3] = "info", e[e.debug = 4] = "debug" }(c || (c = {})); var f = c.off, l = function () { function e(e) { this.t = e } e.getLevel = function () { return f }, e.setLevel = function (e) { return f = c[e] }; var t = e.prototype; return t.error = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; this.i(console.error, c.error, t) }, t.warn = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; this.i(console.warn, c.warning, t) }, t.info = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; this.i(console.info, c.info, t) }, t.debug = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; this.i(console.log, c.debug, t) }, t.i = function (t, r, n) { r <= e.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(n)) }, e }(), p = S, v = P, d = b, m = x, g = A, y = "/", w = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g"); function b(e, t) { for (var r, n = [], o = 0, i = 0, s = "", a = t && t.delimiter || y, u = t && t.whitelist || void 0, c = !1; null !== (r = w.exec(e));) { var h = r[0], f = r[1], l = r.index; if (s += e.slice(i, l), i = l + h.length, f) s += f[1], c = !0; else { var p = "", v = r[2], d = r[3], m = r[4], g = r[5]; if (!c && s.length) { var b = s.length - 1, P = s[b]; (!u || u.indexOf(P) > -1) && (p = P, s = s.slice(0, b)) } s && (n.push(s), s = "", c = !1); var x = d || m, j = p || a; n.push({ name: v || o++, prefix: p, delimiter: j, optional: "?" === g || "*" === g, repeat: "+" === g || "*" === g, pattern: x ? k(x) : "[^" + E(j === a ? j : j + a) + "]+?" }) } } return (s || i < e.length) && n.push(s + e.substr(i)), n } function P(e, t) { return function (r, n) { var o = e.exec(r); if (!o) return !1; for (var i = o[0], s = o.index, a = {}, u = n && n.decode || decodeURIComponent, c = 1; c < o.length; c++)if (void 0 !== o[c]) { var h = t[c - 1]; a[h.name] = h.repeat ? o[c].split(h.delimiter).map(function (e) { return u(e, h) }) : u(o[c], h) } return { path: i, index: s, params: a } } } function x(e, t) { for (var r = new Array(e.length), n = 0; n < e.length; n++)"object" == typeof e[n] && (r[n] = new RegExp("^(?:" + e[n].pattern + ")$", j(t))); return function (t, n) { for (var o = "", i = n && n.encode || encodeURIComponent, s = !n || !1 !== n.validate, a = 0; a < e.length; a++) { var u = e[a]; if ("string" != typeof u) { var c, h = t ? t[u.name] : void 0; if (Array.isArray(h)) { if (!u.repeat) throw new TypeError('Expected "' + u.name + '" to not repeat, but got array'); if (0 === h.length) { if (u.optional) continue; throw new TypeError('Expected "' + u.name + '" to not be empty') } for (var f = 0; f < h.length; f++) { if (c = i(h[f], u), s && !r[a].test(c)) throw new TypeError('Expected all "' + u.name + '" to match "' + u.pattern + '"'); o += (0 === f ? u.prefix : u.delimiter) + c } } else if ("string" != typeof h && "number" != typeof h && "boolean" != typeof h) { if (!u.optional) throw new TypeError('Expected "' + u.name + '" to be ' + (u.repeat ? "an array" : "a string")) } else { if (c = i(String(h), u), s && !r[a].test(c)) throw new TypeError('Expected "' + u.name + '" to match "' + u.pattern + '", but got "' + c + '"'); o += u.prefix + c } } else o += u } return o } } function E(e) { return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function k(e) { return e.replace(/([=!:$/()])/g, "\\$1") } function j(e) { return e && e.sensitive ? "" : "i" } function A(e, t, r) { for (var n = (r = r || {}).strict, o = !1 !== r.start, i = !1 !== r.end, s = r.delimiter || y, a = [].concat(r.endsWith || []).map(E).concat("$").join("|"), u = o ? "^" : "", c = 0; c < e.length; c++) { var h = e[c]; if ("string" == typeof h) u += E(h); else { var f = h.repeat ? "(?:" + h.pattern + ")(?:" + E(h.delimiter) + "(?:" + h.pattern + "))*" : h.pattern; t && t.push(h), u += h.optional ? h.prefix ? "(?:" + E(h.prefix) + "(" + f + "))?" : "(" + f + ")?" : E(h.prefix) + "(" + f + ")" } } if (i) n || (u += "(?:" + E(s) + ")?"), u += "$" === a ? "$" : "(?=" + a + ")"; else { var l = e[e.length - 1], p = "string" == typeof l ? l[l.length - 1] === s : void 0 === l; n || (u += "(?:" + E(s) + "(?=" + a + "))?"), p || (u += "(?=" + E(s) + "|" + a + ")") } return new RegExp(u, j(r)) } function S(e, t, r) { return e instanceof RegExp ? function (e, t) { if (!t) return e; var r = e.source.match(/\((?!\?)/g); if (r) for (var n = 0; n < r.length; n++)t.push({ name: n, prefix: null, delimiter: null, optional: !1, repeat: !1, pattern: null }); return e }(e, t) : Array.isArray(e) ? function (e, t, r) { for (var n = [], o = 0; o < e.length; o++)n.push(S(e[o], t, r).source); return new RegExp("(?:" + n.join("|") + ")", j(r)) }(e, t, r) : function (e, t, r) { return A(b(e, r), t, r) }(e, t, r) } p.match = function (e, t) { var r = []; return P(S(e, r, t), r) }, p.regexpToFunction = v, p.parse = d, p.compile = function (e, t) { return x(b(e, t), t) }, p.tokensToFunction = m, p.tokensToRegExp = g; var R = { container: "container", history: "history", namespace: "namespace", prefix: "data-barba", prevent: "prevent", wrapper: "wrapper" }, O = new (function () { function e() { this.o = R, this.u = new DOMParser } var t = e.prototype; return t.toString = function (e) { return e.outerHTML }, t.toDocument = function (e) { return this.u.parseFromString(e, "text/html") }, t.toElement = function (e) { var t = document.createElement("div"); return t.innerHTML = e, t }, t.getHtml = function (e) { return void 0 === e && (e = document), this.toString(e.documentElement) }, t.getWrapper = function (e) { return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]') }, t.getContainer = function (e) { return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]') }, t.removeContainer = function (e) { document.body.contains(e) && e.parentNode.removeChild(e) }, t.addContainer = function (e, t) { var r = this.getContainer(); r ? this.s(e, r) : t.appendChild(e) }, t.getNamespace = function (e) { void 0 === e && (e = document); var t = e.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]"); return t ? t.getAttribute(this.o.prefix + "-" + this.o.namespace) : null }, t.getHref = function (e) { if (e.tagName && "a" === e.tagName.toLowerCase()) { if ("string" == typeof e.href) return e.href; var t = e.getAttribute("href") || e.getAttribute("xlink:href"); if (t) return this.resolveUrl(t.baseVal || t) } return null }, t.resolveUrl = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; var n = t.length; if (0 === n) throw new Error("resolveUrl requires at least one argument; got none."); var o = document.createElement("base"); if (o.href = arguments[0], 1 === n) return o.href; var i = document.getElementsByTagName("head")[0]; i.insertBefore(o, i.firstChild); for (var s, a = document.createElement("a"), u = 1; u < n; u++)a.href = arguments[u], o.href = s = a.href; return i.removeChild(o), s }, t.s = function (e, t) { t.parentNode.insertBefore(e, t.nextSibling) }, e }()), L = new (function () { function e() { this.h = [], this.v = -1 } var n = e.prototype; return n.init = function (e, t) { this.l = "barba"; var r = { ns: t, scroll: { x: window.scrollX, y: window.scrollY }, url: e }; this.h.push(r), this.v = 0; var n = { from: this.l, index: 0, states: [].concat(this.h) }; window.history && window.history.replaceState(n, "", e) }, n.change = function (e, t, r) { if (r && r.state) { var n = r.state, o = n.index; t = this.m(this.v - o), this.replace(n.states), this.v = o } else this.add(e, t); return t }, n.add = function (e, t) { var r = this.size, n = this.p(t), o = { ns: "tmp", scroll: { x: window.scrollX, y: window.scrollY }, url: e }; this.h.push(o), this.v = r; var i = { from: this.l, index: r, states: [].concat(this.h) }; switch (n) { case "push": window.history && window.history.pushState(i, "", e); break; case "replace": window.history && window.history.replaceState(i, "", e) } }, n.update = function (e, t) { var n = t || this.v, o = r({}, this.get(n), {}, e); this.set(n, o) }, n.remove = function (e) { e ? this.h.splice(e, 1) : this.h.pop(), this.v-- }, n.clear = function () { this.h = [], this.v = -1 }, n.replace = function (e) { this.h = e }, n.get = function (e) { return this.h[e] }, n.set = function (e, t) { return this.h[e] = t }, n.p = function (e) { var t = "push", r = e, n = R.prefix + "-" + R.history; return r.hasAttribute && r.hasAttribute(n) && (t = r.getAttribute(n)), t }, n.m = function (e) { return Math.abs(e) > 1 ? e > 0 ? "forward" : "back" : 0 === e ? "popstate" : e > 0 ? "back" : "forward" }, t(e, [{ key: "current", get: function () { return this.h[this.v] } }, { key: "state", get: function () { return this.h[this.h.length - 1] } }, { key: "previous", get: function () { return this.v < 1 ? null : this.h[this.v - 1] } }, { key: "size", get: function () { return this.h.length } }]), e }()), T = function (e, t) { try { var r = function () { if (!t.next.html) return Promise.resolve(e).then(function (e) { var r = t.next; if (e) { var n = O.toElement(e); r.namespace = O.getNamespace(n), r.container = O.getContainer(n), r.html = e, L.update({ ns: r.namespace }); var o = O.toDocument(e); document.title = o.title } }) }(); return Promise.resolve(r && r.then ? r.then(function () { }) : void 0) } catch (e) { return Promise.reject(e) } }, q = p, _ = { __proto__: null, update: T, nextTick: function () { return new Promise(function (e) { window.requestAnimationFrame(e) }) }, pathToRegexp: q }, H = function () { return window.location.origin }, M = function (e) { return void 0 === e && (e = window.location.href), C(e).port }, C = function (e) { var t, r = e.match(/:\d+/); if (null === r) /^http/.test(e) && (t = 80), /^https/.test(e) && (t = 443); else { var n = r[0].substring(1); t = parseInt(n, 10) } var o, i = e.replace(H(), ""), s = {}, a = i.indexOf("#"); a >= 0 && (o = i.slice(a + 1), i = i.slice(0, a)); var u = i.indexOf("?"); return u >= 0 && (s = N(i.slice(u + 1)), i = i.slice(0, u)), { hash: o, path: i, port: t, query: s } }, N = function (e) { return e.split("&").reduce(function (e, t) { var r = t.split("="); return e[r[0]] = r[1], e }, {}) }, B = function (e) { return void 0 === e && (e = window.location.href), e.replace(/(\/#.*|\/|#.*)$/, "") }, I = { __proto__: null, getHref: function () { return window.location.href }, getOrigin: H, getPort: M, getPath: function (e) { return void 0 === e && (e = window.location.href), C(e).path }, parse: C, parseQuery: N, clean: B }; function D(e, t, r) { return void 0 === t && (t = 2e3), new Promise(function (n, o) { var i = new XMLHttpRequest; i.onreadystatechange = function () { if (i.readyState === XMLHttpRequest.DONE) if (200 === i.status) n(i.responseText); else if (i.status) { var t = { status: i.status, statusText: i.statusText }; r(e, t), o(t) } }, i.ontimeout = function () { var n = new Error("Timeout error [" + t + "]"); r(e, n), o(n) }, i.onerror = function () { var t = new Error("Fetch error"); r(e, t), o(t) }, i.open("GET", e), i.timeout = t, i.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), i.setRequestHeader("x-barba", "yes"), i.send() }) } var U = function (e) { return !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then }; function $(e, t) { return void 0 === t && (t = {}), function () { for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)n[o] = arguments[o]; var i = !1; return new Promise(function (r, o) { t.async = function () { return i = !0, function (e, t) { e ? o(e) : r(t) } }; var s = e.apply(t, n); i || (U(s) ? s.then(r, o) : r(s)) }) } } var F = new (function (e) { function t() { var t; return (t = e.call(this) || this).logger = new l("@barba/core"), t.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], t.registered = new Map, t.init(), t } n(t, e); var r = t.prototype; return r.init = function () { var e = this; this.registered.clear(), this.all.forEach(function (t) { e[t] || (e[t] = function (r, n) { e.registered.has(t) || e.registered.set(t, new Set), e.registered.get(t).add({ ctx: n || {}, fn: r }) }) }) }, r.do = function (e) { for (var t = this, r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)n[o - 1] = arguments[o]; if (this.registered.has(e)) { var i = Promise.resolve(); return this.registered.get(e).forEach(function (e) { i = i.then(function () { return $(e.fn, e.ctx).apply(void 0, n) }) }), i.catch(function (r) { t.logger.debug("Hook error [" + e + "]"), t.logger.error(r) }) } return Promise.resolve() }, r.clear = function () { var e = this; this.all.forEach(function (t) { delete e[t] }), this.init() }, r.help = function () { this.logger.info("Available hooks: " + this.all.join(",")); var e = []; this.registered.forEach(function (t, r) { return e.push(r) }), this.logger.info("Registered hooks: " + e.join(",")) }, t }(function () { })), W = function () { function e(e) { if (this.P = [], "boolean" == typeof e) this.g = e; else { var t = Array.isArray(e) ? e : [e]; this.P = t.map(function (e) { return q(e) }) } } return e.prototype.checkHref = function (e) { if ("boolean" == typeof this.g) return this.g; var t = C(e).path; return this.P.some(function (e) { return null !== e.exec(t) }) }, e }(), K = function (e) { function t(t) { var r; return (r = e.call(this, t) || this).k = new Map, r } n(t, e); var o = t.prototype; return o.set = function (e, t, r) { return this.k.set(e, { action: r, request: t }), { action: r, request: t } }, o.get = function (e) { return this.k.get(e) }, o.getRequest = function (e) { return this.k.get(e).request }, o.getAction = function (e) { return this.k.get(e).action }, o.has = function (e) { return !this.checkHref(e) && this.k.has(e) }, o.delete = function (e) { return this.k.delete(e) }, o.update = function (e, t) { var n = r({}, this.k.get(e), {}, t); return this.k.set(e, n), n }, t }(W), X = function () { return !window.history.pushState }, z = function (e) { return !e.el || !e.href }, Y = function (e) { var t = e.event; return t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey }, G = function (e) { var t = e.el; return t.hasAttribute("target") && "_blank" === t.target }, Q = function (e) { var t = e.el; return void 0 !== t.protocol && window.location.protocol !== t.protocol || void 0 !== t.hostname && window.location.hostname !== t.hostname }, V = function (e) { var t = e.el; return void 0 !== t.port && M() !== M(t.href) }, J = function (e) { var t = e.el; return t.getAttribute && "string" == typeof t.getAttribute("download") }, Z = function (e) { return e.el.hasAttribute(R.prefix + "-" + R.prevent) }, ee = function (e) { return Boolean(e.el.closest("[" + R.prefix + "-" + R.prevent + '="all"]')) }, te = function (e) { var t = e.href; return B(t) === B() && M(t) === M() }, re = function (e) { function t(t) { var r; return (r = e.call(this, t) || this).suite = [], r.tests = new Map, r.init(), r } n(t, e); var r = t.prototype; return r.init = function () { this.add("pushState", X), this.add("exists", z), this.add("newTab", Y), this.add("blank", G), this.add("corsDomain", Q), this.add("corsPort", V), this.add("download", J), this.add("preventSelf", Z), this.add("preventAll", ee), this.add("sameUrl", te, !1) }, r.add = function (e, t, r) { void 0 === r && (r = !0), this.tests.set(e, t), r && this.suite.push(e) }, r.run = function (e, t, r, n) { return this.tests.get(e)({ el: t, event: r, href: n }) }, r.checkLink = function (e, t, r) { var n = this; return this.suite.some(function (o) { return n.run(o, e, t, r) }) }, t }(W), ne = function (e) { function t(r, n) { var o; void 0 === n && (n = "Barba error"); for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), a = 2; a < i; a++)s[a - 2] = arguments[a]; return (o = e.call.apply(e, [this].concat(s)) || this).error = r, o.label = n, Error.captureStackTrace && Error.captureStackTrace(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(o), t), o.name = "BarbaError", o } return n(t, e), t }(a(Error)), oe = function () { function e(e) { void 0 === e && (e = []), this.logger = new l("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{ name: "namespace", type: "strings" }, { name: "custom", type: "function" }], e && (this.all = this.all.concat(e)), this.update() } var t = e.prototype; return t.add = function (e, t) { switch (e) { case "rule": this.A.splice(t.position || 0, 0, t.value); break; case "transition": default: this.all.push(t) }this.update() }, t.resolve = function (e, t) { var r = this; void 0 === t && (t = {}); var n = t.once ? this.once : this.page; n = n.filter(t.self ? function (e) { return e.name && "self" === e.name } : function (e) { return !e.name || "self" !== e.name }); var o = new Map, i = n.find(function (n) { var i = !0, s = {}; return !(!t.self || "self" !== n.name) || (r.A.reverse().forEach(function (t) { i && (i = r.R(n, t, e, s), n.from && n.to && (i = r.R(n, t, e, s, "from") && r.R(n, t, e, s, "to")), n.from && !n.to && (i = r.R(n, t, e, s, "from")), !n.from && n.to && (i = r.R(n, t, e, s, "to"))) }), o.set(n, s), i) }), s = o.get(i), a = []; if (a.push(t.once ? "once" : "page"), t.self && a.push("self"), s) { var u, c = [i]; Object.keys(s).length > 0 && c.push(s), (u = this.logger).info.apply(u, ["Transition found [" + a.join(",") + "]"].concat(c)) } else this.logger.info("No transition found [" + a.join(",") + "]"); return i }, t.update = function () { var e = this; this.all = this.all.map(function (t) { return e.T(t) }).sort(function (e, t) { return e.priority - t.priority }).reverse().map(function (e) { return delete e.priority, e }), this.page = this.all.filter(function (e) { return void 0 !== e.leave || void 0 !== e.enter }), this.once = this.all.filter(function (e) { return void 0 !== e.once }) }, t.R = function (e, t, r, n, o) { var i = !0, s = !1, a = e, u = t.name, c = u, h = u, f = u, l = o ? a[o] : a, p = "to" === o ? r.next : r.current; if (o ? l && l[u] : l[u]) { switch (t.type) { case "strings": default: var v = Array.isArray(l[c]) ? l[c] : [l[c]]; p[c] && -1 !== v.indexOf(p[c]) && (s = !0), -1 === v.indexOf(p[c]) && (i = !1); break; case "object": var d = Array.isArray(l[h]) ? l[h] : [l[h]]; p[h] ? (p[h].name && -1 !== d.indexOf(p[h].name) && (s = !0), -1 === d.indexOf(p[h].name) && (i = !1)) : i = !1; break; case "function": l[f](r) ? s = !0 : i = !1 }s && (o ? (n[o] = n[o] || {}, n[o][u] = a[o][u]) : n[u] = a[u]) } return i }, t.O = function (e, t, r) { var n = 0; return (e[t] || e.from && e.from[t] || e.to && e.to[t]) && (n += Math.pow(10, r), e.from && e.from[t] && (n += 1), e.to && e.to[t] && (n += 2)), n }, t.T = function (e) { var t = this; e.priority = 0; var r = 0; return this.A.forEach(function (n, o) { r += t.O(e, n.name, o + 1) }), e.priority = r, e }, e }(), ie = function () { function e(e) { void 0 === e && (e = []), this.logger = new l("@barba/core"), this.S = !1, this.store = new oe(e) } var r = e.prototype; return r.get = function (e, t) { return this.store.resolve(e, t) }, r.doOnce = function (e) { var t = e.data, r = e.transition; try { var n = function () { o.S = !1 }, o = this, i = r || {}; o.S = !0; var s = u(function () { return Promise.resolve(o.j("beforeOnce", t, i)).then(function () { return Promise.resolve(o.once(t, i)).then(function () { return Promise.resolve(o.j("afterOnce", t, i)).then(function () { }) }) }) }, function (e) { o.S = !1, o.logger.debug("Transition error [before/after/once]"), o.logger.error(e) }); return Promise.resolve(s && s.then ? s.then(n) : n()) } catch (e) { return Promise.reject(e) } }, r.doPage = function (e) { var t = e.data, r = e.transition, n = e.page, o = e.wrapper; try { var i = function (e) { if (s) return e; a.S = !1 }, s = !1, a = this, c = r || {}, h = !0 === c.sync || !1; a.S = !0; var f = u(function () { function e() { return Promise.resolve(a.j("before", t, c)).then(function () { var e = !1; function r(r) { return e ? r : Promise.resolve(a.remove(t)).then(function () { return Promise.resolve(a.j("after", t, c)).then(function () { }) }) } var i = function () { if (h) return u(function () { return Promise.resolve(a.add(t, o)).then(function () { return Promise.resolve(a.j("beforeLeave", t, c)).then(function () { return Promise.resolve(a.j("beforeEnter", t, c)).then(function () { return Promise.resolve(Promise.all([a.leave(t, c), a.enter(t, c)])).then(function () { return Promise.resolve(a.j("afterLeave", t, c)).then(function () { return Promise.resolve(a.j("afterEnter", t, c)).then(function () { }) }) }) }) }) }) }, function (e) { if (a.M(e)) throw new ne(e, "Transition error [sync]") }); var r = function (r) { return e ? r : u(function () { var e = function () { if (!1 !== i) return Promise.resolve(a.add(t, o)).then(function () { return Promise.resolve(a.j("beforeEnter", t, c)).then(function () { return Promise.resolve(a.enter(t, c, i)).then(function () { return Promise.resolve(a.j("afterEnter", t, c)).then(function () { }) }) }) }) }(); if (e && e.then) return e.then(function () { }) }, function (e) { if (a.M(e)) throw new ne(e, "Transition error [before/after/enter]") }) }, i = !1, s = u(function () { return Promise.resolve(a.j("beforeLeave", t, c)).then(function () { return Promise.resolve(Promise.all([a.leave(t, c), T(n, t)]).then(function (e) { return e[0] })).then(function (e) { return i = e, Promise.resolve(a.j("afterLeave", t, c)).then(function () { }) }) }) }, function (e) { if (a.M(e)) throw new ne(e, "Transition error [before/after/leave]") }); return s && s.then ? s.then(r) : r(s) }(); return i && i.then ? i.then(r) : r(i) }) } var r = function () { if (h) return Promise.resolve(T(n, t)).then(function () { }) }(); return r && r.then ? r.then(e) : e() }, function (e) { if (a.S = !1, e.name && "BarbaError" === e.name) throw a.logger.debug(e.label), a.logger.error(e.error), e; throw a.logger.debug("Transition error [page]"), a.logger.error(e), e }); return Promise.resolve(f && f.then ? f.then(i) : i(f)) } catch (e) { return Promise.reject(e) } }, r.once = function (e, t) { try { return Promise.resolve(F.do("once", e, t)).then(function () { return t.once ? $(t.once, t)(e) : Promise.resolve() }) } catch (e) { return Promise.reject(e) } }, r.leave = function (e, t) { try { return Promise.resolve(F.do("leave", e, t)).then(function () { return t.leave ? $(t.leave, t)(e) : Promise.resolve() }) } catch (e) { return Promise.reject(e) } }, r.enter = function (e, t, r) { try { return Promise.resolve(F.do("enter", e, t)).then(function () { return t.enter ? $(t.enter, t)(e, r) : Promise.resolve() }) } catch (e) { return Promise.reject(e) } }, r.add = function (e, t) { try { return O.addContainer(e.next.container, t), F.do("nextAdded", e), Promise.resolve() } catch (e) { return Promise.reject(e) } }, r.remove = function (e) { try { return O.removeContainer(e.current.container), F.do("currentRemoved", e), Promise.resolve() } catch (e) { return Promise.reject(e) } }, r.M = function (e) { return e.message ? !/Timeout error|Fetch error/.test(e.message) : !e.status }, r.j = function (e, t, r) { try { return Promise.resolve(F.do(e, t, r)).then(function () { return r[e] ? $(r[e], r)(t) : Promise.resolve() }) } catch (e) { return Promise.reject(e) } }, t(e, [{ key: "isRunning", get: function () { return this.S }, set: function (e) { this.S = e } }, { key: "hasOnce", get: function () { return this.store.once.length > 0 } }, { key: "hasSelf", get: function () { return this.store.all.some(function (e) { return "self" === e.name }) } }, { key: "shouldWait", get: function () { return this.store.all.some(function (e) { return e.to && !e.to.route || e.sync }) } }]), e }(), se = function () { function e(e) { var t = this; this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== e.length && (e.forEach(function (e) { t.byNamespace.set(e.namespace, e) }), this.names.forEach(function (e) { F[e](t.L(e)) })) } return e.prototype.L = function (e) { var t = this; return function (r) { var n = e.match(/enter/i) ? r.next : r.current, o = t.byNamespace.get(n.namespace); return o && o[e] ? $(o[e], o)(r) : Promise.resolve() } }, e }(); Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (e) { var t = this; do { if (t.matches(e)) return t; t = t.parentElement || t.parentNode } while (null !== t && 1 === t.nodeType); return null }); var ae = { container: null, html: "", namespace: "", url: { hash: "", href: "", path: "", port: null, query: {} } }; return new (function () { function e() { this.version = h, this.schemaPage = ae, this.Logger = l, this.logger = new l("@barba/core"), this.plugins = [], this.hooks = F, this.dom = O, this.helpers = _, this.history = L, this.request = D, this.url = I } var n = e.prototype; return n.use = function (e, t) { var r = this.plugins; r.indexOf(e) > -1 ? this.logger.warn("Plugin [" + e.name + "] already installed.") : "function" == typeof e.install ? (e.install(this, t), r.push(e)) : this.logger.warn("Plugin [" + e.name + '] has no "install" method.') }, n.init = function (e) { var t = void 0 === e ? {} : e, n = t.transitions, o = void 0 === n ? [] : n, i = t.views, s = void 0 === i ? [] : i, a = t.schema, u = void 0 === a ? R : a, c = t.requestError, h = t.timeout, f = void 0 === h ? 2e3 : h, p = t.cacheIgnore, v = void 0 !== p && p, d = t.prefetchIgnore, m = void 0 !== d && d, g = t.preventRunning, y = void 0 !== g && g, w = t.prevent, b = void 0 === w ? null : w, P = t.debug, x = t.logLevel; if (l.setLevel(!0 === (void 0 !== P && P) ? "debug" : void 0 === x ? "off" : x), this.logger.info(this.version), Object.keys(u).forEach(function (e) { R[e] && (R[e] = u[e]) }), this.$ = c, this.timeout = f, this.cacheIgnore = v, this.prefetchIgnore = m, this.preventRunning = y, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found"); this._.setAttribute("aria-live", "polite"), this.q(); var E = this.data.current; if (!E.container) throw new Error("[@barba/core] No Barba container found"); if (this.cache = new K(v), this.prevent = new re(m), this.transitions = new ie(o), this.views = new se(s), null !== b) { if ("function" != typeof b) throw new Error("[@barba/core] Prevent should be a function"); this.prevent.add("preventCustom", b) } this.history.init(E.url.href, E.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach(function (e) { return e.init() }); var k = this.data; k.trigger = "barba", k.next = k.current, k.current = r({}, this.schemaPage), this.hooks.do("ready", k), this.once(k), this.q() }, n.destroy = function () { this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = [] }, n.force = function (e) { window.location.assign(e) }, n.go = function (e, t, r) { var n; if (void 0 === t && (t = "barba"), this.transitions.isRunning) this.force(e); else if (!(n = "popstate" === t ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(e) : this.prevent.run("sameUrl", null, null, e)) || this.transitions.hasSelf) return t = this.history.change(e, t, r), r && (r.stopPropagation(), r.preventDefault()), this.page(e, t, n) }, n.once = function (e) { try { var t = this; return Promise.resolve(t.hooks.do("beforeEnter", e)).then(function () { function r() { return Promise.resolve(t.hooks.do("afterEnter", e)).then(function () { }) } var n = function () { if (t.transitions.hasOnce) { var r = t.transitions.get(e, { once: !0 }); return Promise.resolve(t.transitions.doOnce({ transition: r, data: e })).then(function () { }) } }(); return n && n.then ? n.then(r) : r() }) } catch (e) { return Promise.reject(e) } }, n.page = function (e, t, n) { try { var o = function () { var e = i.data; return Promise.resolve(i.hooks.do("page", e)).then(function () { var t = u(function () { var t = i.transitions.get(e, { once: !1, self: n }); return Promise.resolve(i.transitions.doPage({ data: e, page: s, transition: t, wrapper: i._ })).then(function () { i.q() }) }, function () { 0 === l.getLevel() && i.force(e.current.url.href) }); if (t && t.then) return t.then(function () { }) }) }, i = this; i.data.next.url = r({ href: e }, i.url.parse(e)), i.data.trigger = t; var s = i.cache.has(e) ? i.cache.update(e, { action: "click" }).request : i.cache.set(e, i.request(e, i.timeout, i.onRequestError.bind(i, t)), "click").request, a = function () { if (i.transitions.shouldWait) return Promise.resolve(T(s, i.data)).then(function () { }) }(); return Promise.resolve(a && a.then ? a.then(o) : o()) } catch (e) { return Promise.reject(e) } }, n.onRequestError = function (e) { this.transitions.isRunning = !1; for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)r[n - 1] = arguments[n]; var o = r[0], i = r[1], s = this.cache.getAction(o); return this.cache.delete(o), !(this.$ && !1 === this.$(e, s, o, i) || ("click" === s && this.force(o), 1)) }, n.prefetch = function (e) { var t = this; this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, "barba")).catch(function (e) { t.logger.error(e) }), "prefetch") }, n.F = function () { !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D) }, n.H = function () { !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D) }, n.B = function (e) { var t = this, r = this.I(e); if (r) { var n = this.dom.getHref(r); this.prevent.checkHref(n) || this.cache.has(n) || this.cache.set(n, this.request(n, this.timeout, this.onRequestError.bind(this, r)).catch(function (e) { t.logger.error(e) }), "enter") } }, n.U = function (e) { var t = this.I(e); if (t) return this.transitions.isRunning && this.preventRunning ? (e.preventDefault(), void e.stopPropagation()) : void this.go(this.dom.getHref(t), t, e) }, n.D = function (e) { this.go(this.url.getHref(), "popstate", e) }, n.I = function (e) { for (var t = e.target; t && !this.dom.getHref(t);)t = t.parentNode; if (t && !this.prevent.checkLink(t, e, this.dom.getHref(t))) return t }, n.q = function () { var e = this.url.getHref(), t = { container: this.dom.getContainer(), html: this.dom.getHtml(), namespace: this.dom.getNamespace(), url: r({ href: e }, this.url.parse(e)) }; this.C = { current: t, next: r({}, this.schemaPage), trigger: void 0 }, this.hooks.do("reset", this.data) }, t(e, [{ key: "data", get: function () { return this.C } }, { key: "wrapper", get: function () { return this._ } }]), e }()) });
    }, {}], "w1pc": [function (require, module, exports) {
        var define;
        var e; !function (r, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof e && e.amd ? e(t) : (r = r || self).barbaRouter = t() }(this, function () { var e = "2.1.10"; return new (function () { function r() { this.name = "@barba/router", this.version = e, this.routeNames = [], this.routesByName = {} } var t = r.prototype; return t.install = function (e, r) { var t = this, o = (void 0 === r ? {} : r).routes, a = void 0 === o ? [] : o; this.logger = new e.Logger(this.name), this.logger.info(this.version), this.barba = e, a.forEach(function (e) { var r = e.name, o = e.path, a = [], s = t.barba.helpers.pathToRegexp(o, a); t.routeNames.indexOf(r) > -1 ? console.warn("[@barba/router] Duplicated route name (" + r + ")") : (t.routeNames.push(r), t.routesByName[r] = { keys: a, path: o, regex: s }) }), e.schemaPage.route = void 0 }, t.init = function () { this.barba.transitions.store.add("rule", { position: 1, value: { name: "route", type: "object" } }), this.barba.hooks.page(this.resolveRoutes, this), this.barba.hooks.reset(this.resolveRoutes, this) }, t.resolveUrl = function (e) { for (var r = this, t = this.barba.url.parse(e).path, o = { name: name, params: {} }, a = function (e, a) { var s = r.routeNames[e], n = r.routesByName[s], i = n.keys, u = n.regex.exec(t); if (null !== u) return o.name = s, i.forEach(function (e, r) { o.params[e.name] = u[r + 1] }), { v: o } }, s = 0, n = this.routeNames.length; s < n; s++) { var i = a(s); if ("object" == typeof i) return i.v } return null }, t.resolveRoutes = function (e) { var r = e.current, t = e.next; r.route = r.url.href ? this.resolveUrl(r.url.href) : void 0, t.route = t.url.href ? this.resolveUrl(t.url.href) : void 0 }, r }()) });
    }, {}], "TNS6": [function (require, module, exports) {
        "use strict"; function t(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function e(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } Object.defineProperty(exports, "__esModule", { value: !0 }), exports._getCache = exports._getSetter = exports._missingPlugin = exports._round = exports._roundModifier = exports._config = exports._ticker = exports._plugins = exports._checkPlugin = exports._replaceRandom = exports._colorStringFilter = exports._sortPropTweensByPriority = exports._forEachName = exports._removeLinkedListItem = exports._setDefaults = exports._relExp = exports._renderComplexString = exports._isUndefined = exports._isString = exports._numWithUnitExp = exports._numExp = exports._getProperty = exports.shuffle = exports.interpolate = exports.unitize = exports.pipe = exports.mapRange = exports.toArray = exports.splitColor = exports.clamp = exports.getUnit = exports.normalize = exports.snap = exports.random = exports.distribute = exports.wrapYoyo = exports.wrap = exports.Circ = exports.Expo = exports.Sine = exports.Bounce = exports.SteppedEase = exports.Back = exports.Elastic = exports.Strong = exports.Quint = exports.Quart = exports.Cubic = exports.Quad = exports.Linear = exports.Power4 = exports.Power3 = exports.Power2 = exports.Power1 = exports.Power0 = exports.default = exports.gsap = exports.PropTween = exports.TweenLite = exports.TweenMax = exports.Tween = exports.TimelineLite = exports.TimelineMax = exports.Timeline = exports.Animation = exports.GSCache = void 0; var r, i, n, s, a, o, u, h, _ = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, p = { duration: .5, overwrite: !1, delay: 0 }, l = 1e8, f = 1 / l, c = 2 * Math.PI, d = c / 4, m = 0, g = Math.sqrt, v = Math.cos, x = Math.sin, y = function (t) { return "string" == typeof t }, T = function (t) { return "function" == typeof t }, w = function (t) { return "number" == typeof t }, b = function (t) { return void 0 === t }, k = function (t) { return "object" == typeof t }, D = function (t) { return !1 !== t }, C = function () { return "undefined" != typeof window }, S = function (t) { return T(t) || y(t) }, A = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, M = Array.isArray, P = /(?:-?\.?\d|\.)+/gi, R = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g, E = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, z = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi, O = /[+-]=-?[\.\d]+/, L = /[#\-+.]*\b[a-z\d-=+%.]+/gi, F = {}, U = {}, I = function (t) { return (U = _t(t, F)) && _r }, B = function (t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") }, N = function (t, e) { return !e && console.warn(t) }, Q = function (t, e) { return t && (F[t] = e) && U && (U[t] = e) || F }, q = function () { return 0 }, j = {}, V = [], G = {}, W = {}, Y = {}, H = 30, J = [], K = "", X = function (t) { var e, r, i = t[0]; if (k(i) || T(i) || (t = [t]), !(e = (i._gsap || {}).harness)) { for (r = J.length; r-- && !J[r].targetTest(i);); e = J[r] } for (r = t.length; r--;)t[r] && (t[r]._gsap || (t[r]._gsap = new Ee(t[r], e))) || t.splice(r, 1); return t }, Z = function (t) { return t._gsap || X(jt(t))[0]._gsap }, $ = function (t, e, r) { return (r = t[e]) && T(r) ? t[e]() : b(r) && t.getAttribute && t.getAttribute(e) || r }, tt = function (t, e) { return (t = t.split(",")).forEach(e) || t }, et = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, rt = function (t, e) { for (var r = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < r;); return i < r }, it = function (t, e, r) { var i, n = w(t[1]), s = (n ? 2 : 1) + (e < 2 ? 0 : 1), a = t[s]; if (n && (a.duration = t[1]), a.parent = r, e) { for (i = a; r && !("immediateRender" in i);)i = r.vars.defaults || {}, r = D(r.vars.inherit) && r.parent; a.immediateRender = D(i.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1] } return a }, nt = function () { var t, e, r = V.length, i = V.slice(0); for (G = {}, V.length = 0, t = 0; t < r; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) }, st = function (t, e, r, i) { V.length && nt(), t.render(e, r, i), V.length && nt() }, at = function (t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match(L).length < 2 ? e : y(t) ? t.trim() : t }, ot = function (t) { return t }, ut = function (t, e) { for (var r in e) r in t || (t[r] = e[r]); return t }, ht = function (t, e) { for (var r in e) r in t || "duration" === r || "ease" === r || (t[r] = e[r]) }, _t = function (t, e) { for (var r in e) t[r] = e[r]; return t }, pt = function t(e, r) { for (var i in r) e[i] = k(r[i]) ? t(e[i] || (e[i] = {}), r[i]) : r[i]; return e }, lt = function (t, e) { var r, i = {}; for (r in t) r in e || (i[r] = t[r]); return i }, ft = function (t) { var e = t.parent || r, i = t.keyframes ? ht : ut; if (D(t.inherit)) for (; e;)i(t, e.vars.defaults), e = e.parent || e._dp; return t }, ct = function (t, e) { for (var r = t.length, i = r === e.length; i && r-- && t[r] === e[r];); return r < 0 }, dt = function (t, e, r, i, n) { void 0 === r && (r = "_first"), void 0 === i && (i = "_last"); var s, a = t[i]; if (n) for (s = e[n]; a && a[n] > s;)a = a._prev; return a ? (e._next = a._next, a._next = e) : (e._next = t[r], t[r] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = a, e.parent = e._dp = t, e }, mt = function (t, e, r, i) { void 0 === r && (r = "_first"), void 0 === i && (i = "_last"); var n = e._prev, s = e._next; n ? n._next = s : t[r] === e && (t[r] = s), s ? s._prev = n : t[i] === e && (t[i] = n), e._next = e._prev = e.parent = null }, gt = function (t, e) { t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0 }, vt = function (t, e) { if (t && (!e || e._end > t._dur || e._start < 0)) for (var r = t; r;)r._dirty = 1, r = r.parent; return t }, xt = function (t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }, yt = function t(e) { return !e || e._ts && t(e.parent) }, Tt = function (t) { return t._repeat ? wt(t._tTime, t = t.duration() + t._rDelay) * t : 0 }, wt = function (t, e) { return (t /= e) && ~~t === t ? ~~t - 1 : ~~t }, bt = function (t, e) { return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur) }, kt = function (t) { return t._end = et(t._start + (t._tDur / Math.abs(t._ts || t._rts || f) || 0)) }, Dt = function (t, e) { var r = t._dp; return r && r.smoothChildTiming && t._ts && (t._start = et(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), kt(t), r._dirty || vt(r, t)), t }, Ct = function (t, e) { var r; if ((e._time || e._initted && !e._dur) && (r = bt(t.rawTime(), e), (!e._dur || Ut(0, e.totalDuration(), r) - e._tTime > f) && e.render(r, !0)), vt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) { if (t._dur < t.duration()) for (r = t; r._dp;)r.rawTime() >= 0 && r.totalTime(r._tTime), r = r._dp; t._zTime = -f } }, St = function (t, e, r, i) { return e.parent && gt(e), e._start = et(r + e._delay), e._end = et(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), dt(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || Ct(t, e), t }, At = function (t, e) { return (F.ScrollTrigger || B("scrollTrigger", e)) && F.ScrollTrigger.create(e, t) }, Mt = function (t, e, r, i) { return Ne(t, e), t._initted ? !r && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && o !== ge.frame ? (V.push(t), t._lazy = [e, i], 1) : void 0 : 1 }, Pt = function (t, e, r, i) { var n, s, a = t.ratio, o = e < 0 || !e && a && !t._start && t._zTime > f && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1, u = t._rDelay, h = 0; if (u && t._repeat && (h = Ut(0, t._tDur, e), wt(h, u) !== (s = wt(t._tTime, u)) && (a = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== a || i || t._zTime === f || !e && t._zTime) { if (!t._initted && Mt(t, e, i, r)) return; for (s = t._zTime, t._zTime = e || (r ? f : 0), r || (r = e && !s), t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = h, r || se(t, "onStart"), n = t._pt; n;)n.r(o, n.d), n = n._next; t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !r && se(t, "onUpdate"), h && t._repeat && !r && t.parent && se(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === o && (o && gt(t, 1), r || (se(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } else t._zTime || (t._zTime = e) }, Rt = function (t, e, r) { var i; if (r > e) for (i = t._first; i && i._start <= r;) { if (!i._dur && "isPause" === i.data && i._start > e) return i; i = i._next } else for (i = t._last; i && i._start >= r;) { if (!i._dur && "isPause" === i.data && i._start < e) return i; i = i._prev } }, Et = function (t, e, r, i) { var n = t._repeat, s = et(e) || 0, a = t._tTime / t._tDur; return a && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = n ? n < 0 ? 1e10 : et(s * (n + 1) + t._rDelay * n) : s, a && !i ? Dt(t, t._tTime = t._tDur * a) : t.parent && kt(t), r || vt(t.parent, t), t }, zt = function (t) { return t instanceof Oe ? vt(t) : Et(t, t._dur) }, Ot = { _start: 0, endTime: q }, Lt = function t(e, r) { var i, n, s = e.labels, a = e._recent || Ot, o = e.duration() >= l ? a.endTime(!1) : e._dur; return y(r) && (isNaN(r) || r in s) ? "<" === (i = r.charAt(0)) || ">" === i ? ("<" === i ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(r.substr(1)) || 0) : (i = r.indexOf("=")) < 0 ? (r in s || (s[r] = o), s[r]) : (n = +(r.charAt(i - 1) + r.substr(i + 1)), i > 1 ? t(e, r.substr(0, i - 1)) + n : o + n) : null == r ? o : +r }, Ft = function (t, e) { return t || 0 === t ? e(t) : e }, Ut = function (t, e, r) { return r < t ? t : r > e ? e : r }, It = function (t) { return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : "" }, Bt = function (t, e, r) { return Ft(r, function (r) { return Ut(t, e, r) }) }, Nt = [].slice, Qt = function (t, e) { return t && k(t) && "length" in t && (!e && !t.length || t.length - 1 in t && k(t[0])) && !t.nodeType && t !== i }, qt = function (t, e, r) { return void 0 === r && (r = []), t.forEach(function (t) { var i; return y(t) && !e || Qt(t, 1) ? (i = r).push.apply(i, jt(t)) : r.push(t) }) || r }, jt = function (t, e) { return !y(t) || e || !n && ve() ? M(t) ? qt(t, e) : Qt(t) ? Nt.call(t, 0) : t ? [t] : [] : Nt.call(s.querySelectorAll(t), 0) }, Vt = function (t) { return t.sort(function () { return .5 - Math.random() }) }, Gt = function (t) { if (T(t)) return t; var e = k(t) ? t : { each: t }, r = Se(e.ease), i = e.from || 0, n = parseFloat(e.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, u = e.axis, h = i, _ = i; return y(i) ? h = _ = { center: .5, edges: .5, end: 1 }[i] || 0 : !a && o && (h = i[0], _ = i[1]), function (t, a, p) { var f, c, d, m, v, x, y, T, w, b = (p || e).length, k = s[b]; if (!k) { if (!(w = "auto" === e.grid ? 0 : (e.grid || [1, l])[1])) { for (y = -l; y < (y = p[w++].getBoundingClientRect().left) && w < b;); w-- } for (k = s[b] = [], f = o ? Math.min(w, b) * h - .5 : i % w, c = o ? b * _ / w - .5 : i / w | 0, y = 0, T = l, x = 0; x < b; x++)d = x % w - f, m = c - (x / w | 0), k[x] = v = u ? Math.abs("y" === u ? m : d) : g(d * d + m * m), v > y && (y = v), v < T && (T = v); "random" === i && Vt(k), k.max = y - T, k.min = T, k.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (w > b ? b - 1 : u ? "y" === u ? b / w : w : Math.max(w, b / w)) || 0) * ("edges" === i ? -1 : 1), k.b = b < 0 ? n - b : n, k.u = It(e.amount || e.each) || 0, r = r && b < 0 ? De(r) : r } return b = (k[t] - k.min) / k.max || 0, et(k.b + (r ? r(b) : b) * k.v) + k.u } }, Wt = function (t) { var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1; return function (r) { return Math.floor(Math.round(parseFloat(r) / t) * t * e) / e + (w(r) ? 0 : It(r)) } }, Yt = function (t, e) { var r, i, n = M(t); return !n && k(t) && (r = n = t.radius || l, t.values ? (t = jt(t.values), (i = !w(t[0])) && (r *= r)) : t = Wt(t.increment)), Ft(e, n ? T(t) ? function (e) { return i = t(e), Math.abs(i - e) <= r ? i : e } : function (e) { for (var n, s, a = parseFloat(i ? e.x : e), o = parseFloat(i ? e.y : 0), u = l, h = 0, _ = t.length; _--;)(n = i ? (n = t[_].x - a) * n + (s = t[_].y - o) * s : Math.abs(t[_] - a)) < u && (u = n, h = _); return h = !r || u <= r ? t[h] : e, i || h === e || w(e) ? h : h + It(e) } : Wt(t)) }, Ht = function (t, e, r, i) { return Ft(M(t) ? !e : !0 === r ? !!(r = 0) : !i, function () { return M(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / r) * r * i) / i }) }, Jt = function () { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; return function (t) { return e.reduce(function (t, e) { return e(t) }, t) } }, Kt = function (t, e) { return function (r) { return t(parseFloat(r)) + (e || It(r)) } }, Xt = function (t, e, r) { return re(t, e, 0, 1, r) }, Zt = function (t, e, r) { return Ft(r, function (r) { return t[~~e(r)] }) }, $t = function t(e, r, i) { var n = r - e; return M(e) ? Zt(e, t(0, e.length), r) : Ft(i, function (t) { return (n + (t - e) % n) % n + e }) }, te = function t(e, r, i) { var n = r - e, s = 2 * n; return M(e) ? Zt(e, t(0, e.length - 1), r) : Ft(i, function (t) { return e + ((t = (s + (t - e) % s) % s || 0) > n ? s - t : t) }) }, ee = function (t) { for (var e, r, i, n, s = 0, a = ""; ~(e = t.indexOf("random(", s));)i = t.indexOf(")", e), n = "[" === t.charAt(e + 7), r = t.substr(e + 7, i - e - 7).match(n ? L : P), a += t.substr(s, e - s) + Ht(n ? r : +r[0], n ? 0 : +r[1], +r[2] || 1e-5), s = i + 1; return a + t.substr(s, t.length - s) }, re = function (t, e, r, i, n) { var s = e - t, a = i - r; return Ft(n, function (e) { return r + ((e - t) / s * a || 0) }) }, ie = function t(e, r, i, n) { var s = isNaN(e + r) ? 0 : function (t) { return (1 - t) * e + t * r }; if (!s) { var a, o, u, h, _, p = y(e), l = {}; if (!0 === i && (n = 1) && (i = null), p) e = { p: e }, r = { p: r }; else if (M(e) && !M(r)) { for (u = [], h = e.length, _ = h - 2, o = 1; o < h; o++)u.push(t(e[o - 1], e[o])); h--, s = function (t) { t *= h; var e = Math.min(_, ~~t); return u[e](t - e) }, i = r } else n || (e = _t(M(e) ? [] : {}, e)); if (!u) { for (a in r) Ue.call(l, e, a, "get", r[a]); s = function (t) { return tr(t, l) || (p ? e.p : e) } } } return Ft(i, s) }, ne = function (t, e, r) { var i, n, s, a = t.labels, o = l; for (i in a) (n = a[i] - e) < 0 == !!r && n && o > (n = Math.abs(n)) && (s = i, o = n); return s }, se = function (t, e, r) { var i, n, s = t.vars, a = s[e]; if (a) return i = s[e + "Params"], n = s.callbackScope || t, r && V.length && nt(), i ? a.apply(n, i) : a.call(n) }, ae = function (t) { return gt(t), t.progress() < 1 && se(t, "onInterrupt"), t }, oe = function (t) { var e = (t = !t.name && t.default || t).name, r = T(t), i = e && !r && t.init ? function () { this._props = [] } : t, n = { init: q, render: tr, add: Ue, kill: rr, modifier: er, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: Ke, aliases: {}, register: 0 }; if (ve(), t !== i) { if (W[e]) return; ut(i, ut(lt(t, n), s)), _t(i.prototype, _t(n, lt(t, s))), W[i.prop = e] = i, t.targetTest && (J.push(i), j[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } Q(e, i), t.register && t.register(_r, i, sr) }, ue = 255, he = { aqua: [0, ue, ue], lime: [0, ue, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, ue], navy: [0, 0, 128], white: [ue, ue, ue], olive: [128, 128, 0], yellow: [ue, ue, 0], orange: [ue, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [ue, 0, 0], pink: [ue, 192, 203], cyan: [0, ue, ue], transparent: [ue, ue, ue, 0] }, _e = function (t, e, r) { return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (r - e) * t * 6 : t < .5 ? r : 3 * t < 2 ? e + (r - e) * (2 / 3 - t) * 6 : e) * ue + .5 | 0 }, pe = function (t, e, r) { var i, n, s, a, o, u, h, _, p, l, f = t ? w(t) ? [t >> 16, t >> 8 & ue, t & ue] : 0 : he.black; if (!f) { if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), he[t]) f = he[t]; else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), n = t.charAt(2), s = t.charAt(3), t = "#" + i + i + n + n + s + s), f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & ue, t & ue]; else if ("hsl" === t.substr(0, 3)) if (f = l = t.match(P), e) { if (~t.indexOf("=")) return f = t.match(R), r && f.length < 4 && (f[3] = 1), f } else a = +f[0] % 360 / 360, o = +f[1] / 100, i = 2 * (u = +f[2] / 100) - (n = u <= .5 ? u * (o + 1) : u + o - u * o), f.length > 3 && (f[3] *= 1), f[0] = _e(a + 1 / 3, i, n), f[1] = _e(a, i, n), f[2] = _e(a - 1 / 3, i, n); else f = t.match(P) || he.transparent; f = f.map(Number) } return e && !l && (i = f[0] / ue, n = f[1] / ue, s = f[2] / ue, u = ((h = Math.max(i, n, s)) + (_ = Math.min(i, n, s))) / 2, h === _ ? a = o = 0 : (p = h - _, o = u > .5 ? p / (2 - h - _) : p / (h + _), a = h === i ? (n - s) / p + (n < s ? 6 : 0) : h === n ? (s - i) / p + 2 : (i - n) / p + 4, a *= 60), f[0] = ~~(a + .5), f[1] = ~~(100 * o + .5), f[2] = ~~(100 * u + .5)), r && f.length < 4 && (f[3] = 1), f }, le = function (t) { var e = [], r = [], i = -1; return t.split(ce).forEach(function (t) { var n = t.match(E) || []; e.push.apply(e, n), r.push(i += n.length + 1) }), e.c = r, e }, fe = function (t, e, r) { var i, n, s, a, o = "", u = (t + o).match(ce), h = e ? "hsla(" : "rgba(", _ = 0; if (!u) return t; if (u = u.map(function (t) { return (t = pe(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")" }), r && (s = le(t), (i = r.c).join(o) !== s.c.join(o))) for (a = (n = t.replace(ce, "1").split(E)).length - 1; _ < a; _++)o += n[_] + (~i.indexOf(_) ? u.shift() || h + "0,0,0,0)" : (s.length ? s : u.length ? u : r).shift()); if (!n) for (a = (n = t.split(ce)).length - 1; _ < a; _++)o += n[_] + u[_]; return o + n[a] }, ce = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (t in he) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), de = /hsl[a]?\(/, me = function (t) { var e, r = t.join(" "); if (ce.lastIndex = 0, ce.test(r)) return e = de.test(r), t[1] = fe(t[1], e), t[0] = fe(t[0], e, le(t[1])), !0 }, ge = function () { var t, e, r, o, u, _, p = Date.now, l = 500, c = 33, d = p(), m = d, g = 1e3 / 240, v = g, x = [], y = function r(i) { var n, s, a, h, f = p() - m, y = !0 === i; if (f > l && (d += f - c), ((n = (a = (m += f) - d) - v) > 0 || y) && (h = ++o.frame, u = a - 1e3 * o.time, o.time = a /= 1e3, v += n + (n >= g ? 4 : g - n), s = 1), y || (t = e(r)), s) for (_ = 0; _ < x.length; _++)x[_](a, u, h, i) }; return o = { time: 0, frame: 0, tick: function () { y(!0) }, deltaRatio: function (t) { return u / (1e3 / (t || 60)) }, wake: function () { a && (!n && C() && (i = n = window, s = i.document || {}, F.gsap = _r, (i.gsapVersions || (i.gsapVersions = [])).push(_r.version), I(U || i.GreenSockGlobals || !i.gsap && i || {}), r = i.requestAnimationFrame), t && o.sleep(), e = r || function (t) { return setTimeout(t, v - 1e3 * o.time + 1 | 0) }, h = 1, y(2)) }, sleep: function () { (r ? i.cancelAnimationFrame : clearTimeout)(t), h = 0, e = q }, lagSmoothing: function (t, e) { l = t || 1 / f, c = Math.min(e, l, 0) }, fps: function (t) { g = 1e3 / (t || 240), v = 1e3 * o.time + g }, add: function (t) { x.indexOf(t) < 0 && x.push(t), ve() }, remove: function (t) { var e; ~(e = x.indexOf(t)) && x.splice(e, 1) && _ >= e && _-- }, _listeners: x } }(), ve = function () { return !h && ge.wake() }, xe = {}, ye = /^[\d.\-M][\d.\-,\s]/, Te = /["']/g, we = function (t) { for (var e, r, i, n = {}, s = t.substr(1, t.length - 3).split(":"), a = s[0], o = 1, u = s.length; o < u; o++)r = s[o], e = o !== u - 1 ? r.lastIndexOf(",") : r.length, i = r.substr(0, e), n[a] = isNaN(i) ? i.replace(Te, "").trim() : +i, a = r.substr(e + 1).trim(); return n }, be = function (t) { var e = t.indexOf("(") + 1, r = t.indexOf(")"), i = t.indexOf("(", e); return t.substring(e, ~i && i < r ? t.indexOf(")", r + 1) : r) }, ke = function (t) { var e = (t + "").split("("), r = xe[e[0]]; return r && e.length > 1 && r.config ? r.config.apply(null, ~t.indexOf("{") ? [we(e[1])] : be(t).split(",").map(at)) : xe._CE && ye.test(t) ? xe._CE("", t) : r }, De = function (t) { return function (e) { return 1 - t(1 - e) } }, Ce = function t(e, r) { for (var i, n = e._first; n;)n instanceof Oe ? t(n, r) : !n.vars.yoyoEase || n._yoyo && n._repeat || n._yoyo === r || (n.timeline ? t(n.timeline, r) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = r)), n = n._next }, Se = function (t, e) { return t && (T(t) ? t : xe[t] || ke(t)) || e }, Ae = function (t, e, r, i) { void 0 === r && (r = function (t) { return 1 - e(1 - t) }), void 0 === i && (i = function (t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var n, s = { easeIn: e, easeOut: r, easeInOut: i }; return tt(t, function (t) { for (var e in xe[t] = F[t] = s, xe[n = t.toLowerCase()] = r, s) xe[n + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = xe[t + "." + e] = s[e] }), s }, Me = function (t) { return function (e) { return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2 } }, Pe = function t(e, r, i) { var n = r >= 1 ? r : 1, s = (i || (e ? .3 : .45)) / (r < 1 ? r : 1), a = s / c * (Math.asin(1 / n) || 0), o = function (t) { return 1 === t ? 1 : n * Math.pow(2, -10 * t) * x((t - a) * s) + 1 }, u = "out" === e ? o : "in" === e ? function (t) { return 1 - o(1 - t) } : Me(o); return s = c / s, u.config = function (r, i) { return t(e, r, i) }, u }, Re = function t(e, r) { void 0 === r && (r = 1.70158); var i = function (t) { return t ? --t * t * ((r + 1) * t + r) + 1 : 0 }, n = "out" === e ? i : "in" === e ? function (t) { return 1 - i(1 - t) } : Me(i); return n.config = function (r) { return t(e, r) }, n }; exports._ticker = ge, exports._colorStringFilter = me, exports.splitColor = pe, exports.interpolate = ie, exports.mapRange = re, exports._replaceRandom = ee, exports.wrapYoyo = te, exports.wrap = $t, exports.normalize = Xt, exports.unitize = Kt, exports.pipe = Jt, exports.random = Ht, exports.snap = Yt, exports._roundModifier = Wt, exports.distribute = Gt, exports.shuffle = Vt, exports.toArray = jt, exports.clamp = Bt, exports.getUnit = It, exports._removeLinkedListItem = mt, exports._setDefaults = ut, exports._round = et, exports._forEachName = tt, exports._getProperty = $, exports._getCache = Z, exports._plugins = W, exports._missingPlugin = B, exports._relExp = O, exports._numWithUnitExp = E, exports._numExp = R, exports._isUndefined = b, exports._isString = y, exports._config = _, tt("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) { var r = e < 5 ? e + 1 : e; Ae(t + ",Power" + (r - 1), e ? function (t) { return Math.pow(t, r) } : function (t) { return t }, function (t) { return 1 - Math.pow(1 - t, r) }, function (t) { return t < .5 ? Math.pow(2 * t, r) / 2 : 1 - Math.pow(2 * (1 - t), r) / 2 }) }), xe.Linear.easeNone = xe.none = xe.Linear.easeIn, Ae("Elastic", Pe("in"), Pe("out"), Pe()), function (t, e) { var r = 1 / e, i = function (i) { return i < r ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375 }; Ae("Bounce", function (t) { return 1 - i(1 - t) }, i) }(7.5625, 2.75), Ae("Expo", function (t) { return t ? Math.pow(2, 10 * (t - 1)) : 0 }), Ae("Circ", function (t) { return -(g(1 - t * t) - 1) }), Ae("Sine", function (t) { return 1 === t ? 1 : 1 - v(t * d) }), Ae("Back", Re("in"), Re("out"), Re()), xe.SteppedEase = xe.steps = F.SteppedEase = { config: function (t, e) { void 0 === t && (t = 1); var r = 1 / t, i = t + (e ? 0 : 1), n = e ? 1 : 0, s = 1 - f; return function (t) { return ((i * Ut(0, s, t) | 0) + n) * r } } }, p.ease = xe["quad.out"], tt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (t) { return K += t + "," + t + "Params," }); var Ee = function (t, e) { this.id = m++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : $, this.set = e ? e.getSetter : Ke }; exports.GSCache = Ee; var ze = function () { function t(t, e) { var i = t.parent || r; this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Et(this, +t.duration, 1, 1), this.data = t.data, h || ge.wake(), i && St(i, this, e || 0 === e ? e : i._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0) } var e = t.prototype; return e.delay = function (t) { return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay }, e.duration = function (t) { return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur }, e.totalDuration = function (t) { return arguments.length ? (this._dirty = 0, Et(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (t, e) { if (ve(), !arguments.length) return this._tTime; var r = this._dp; if (r && r.smoothChildTiming && this._ts) { for (Dt(this, t); r.parent;)r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && St(this._dp, this, this._start - this._delay) } return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === f || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), st(this, t, e)), this }, e.time = function (t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Tt(this)) % this._dur || (t ? this._dur : 0), e) : this._time }, e.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, e.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Tt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, e.iteration = function (t, e) { var r = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * r, e) : this._repeat ? wt(this._tTime, r) + 1 : 1 }, e.timeScale = function (t) { if (!arguments.length) return this._rts === -f ? 0 : this._rts; if (this._rts === t) return this; var e = this.parent && this._ts ? bt(this.parent._time, this) : this._tTime; return this._rts = +t || 0, this._ts = this._ps || t === -f ? 0 : this._rts, xt(this.totalTime(Ut(-this._delay, this._tDur, e), !0)) }, e.paused = function (t) { return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ve(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= f) && Math.abs(this._zTime) !== f))), this) : this._ps }, e.startTime = function (t) { if (arguments.length) { this._start = t; var e = this.parent || this._dp; return e && (e._sort || !this.parent) && St(e, this, t - this._delay), this } return this._start }, e.endTime = function (t) { return this._start + (D(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts) }, e.rawTime = function (t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? bt(e.rawTime(t), this) : this._tTime : this._tTime }, e.globalTime = function (t) { for (var e = this, r = arguments.length ? t : e.rawTime(); e;)r = e._start + r / (e._ts || 1), e = e._dp; return r }, e.repeat = function (t) { return arguments.length ? (this._repeat = t, zt(this)) : this._repeat }, e.repeatDelay = function (t) { return arguments.length ? (this._rDelay = t, zt(this)) : this._rDelay }, e.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, e.seek = function (t, e) { return this.totalTime(Lt(this, t), D(e)) }, e.restart = function (t, e) { return this.play().totalTime(t ? -this._delay : 0, D(e)) }, e.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, e.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, e.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (t) { return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -f : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = 0, this._zTime = -f, this }, e.isActive = function () { var t, e = this.parent || this._dp, r = this._start; return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= r && t < this.endTime(!0) - f)) }, e.eventCallback = function (t, e, r) { var i = this.vars; return arguments.length > 1 ? (e ? (i[t] = e, r && (i[t + "Params"] = r), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t] }, e.then = function (t) { var e = this; return new Promise(function (r) { var i = T(t) ? t : ot, n = function () { var t = e.then; e.then = null, T(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), r(i), e.then = t }; e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? n() : e._prom = n }) }, e.kill = function () { ae(this) }, t }(); exports.Animation = ze, ut(ze.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -f, _prom: 0, _ps: !1, _rts: 1 }); var Oe = function (i) { function n(e, r) { var n; return void 0 === e && (e = {}), (n = i.call(this, e, r) || this).labels = {}, n.smoothChildTiming = !!e.smoothChildTiming, n.autoRemoveChildren = !!e.autoRemoveChildren, n._sort = D(e.sortChildren), n.parent && Ct(n.parent, t(n)), e.scrollTrigger && At(t(n), e.scrollTrigger), n } e(n, i); var s = n.prototype; return s.to = function (t, e, r) { return new Ge(t, it(arguments, 0, this), Lt(this, w(e) ? arguments[3] : r)), this }, s.from = function (t, e, r) { return new Ge(t, it(arguments, 1, this), Lt(this, w(e) ? arguments[3] : r)), this }, s.fromTo = function (t, e, r, i) { return new Ge(t, it(arguments, 2, this), Lt(this, w(e) ? arguments[4] : i)), this }, s.set = function (t, e, r) { return e.duration = 0, e.parent = this, ft(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Ge(t, e, Lt(this, r), 1), this }, s.call = function (t, e, r) { return St(this, Ge.delayedCall(0, t, e), Lt(this, r)) }, s.staggerTo = function (t, e, r, i, n, s, a) { return r.duration = e, r.stagger = r.stagger || i, r.onComplete = s, r.onCompleteParams = a, r.parent = this, new Ge(t, r, Lt(this, n)), this }, s.staggerFrom = function (t, e, r, i, n, s, a) { return r.runBackwards = 1, ft(r).immediateRender = D(r.immediateRender), this.staggerTo(t, e, r, i, n, s, a) }, s.staggerFromTo = function (t, e, r, i, n, s, a, o) { return i.startAt = r, ft(i).immediateRender = D(i.immediateRender), this.staggerTo(t, e, i, n, s, a, o) }, s.render = function (t, e, i) { var n, s, a, o, u, h, _, p, l, c, d, m, g = this._time, v = this._dirty ? this.totalDuration() : this._tDur, x = this._dur, y = this !== r && t > v - f && t >= 0 ? v : t < f ? 0 : t, T = this._zTime < 0 != t < 0 && (this._initted || !x); if (y !== this._tTime || i || T) { if (g !== this._time && x && (y += this._time - g, t += this._time - g), n = y, l = this._start, h = !(p = this._ts), T && (x || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (d = this._yoyo, u = x + this._rDelay, n = et(y % u), y === v ? (o = this._repeat, n = x) : ((o = ~~(y / u)) && o === y / u && (n = x, o--), n > x && (n = x)), c = wt(this._tTime, u), !g && this._tTime && c !== o && (c = o), d && 1 & o && (n = x - n, m = 1), o !== c && !this._lock)) { var w = d && 1 & c, b = w === (d && 1 & o); if (o < c && (w = !w), g = w ? 0 : x, this._lock = 1, this.render(g || (m ? 0 : et(o * u)), e, !x)._lock = 0, !e && this.parent && se(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g !== this._time || h !== !this._ts) return this; if (x = this._dur, v = this._tDur, b && (this._lock = 2, g = w ? x : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !h) return this; Ce(this, m) } if (this._hasPause && !this._forcing && this._lock < 2 && (_ = Rt(this, et(g), et(n))) && (y -= n - (n = _._start)), this._tTime = y, this._time = n, this._act = !p, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !g && n && !e && se(this, "onStart"), n >= g && t >= 0) for (s = this._first; s;) { if (a = s._next, (s._act || n >= s._start) && s._ts && _ !== s) { if (s.parent !== this) return this.render(t, e, i); if (s.render(s._ts > 0 ? (n - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (n - s._start) * s._ts, e, i), n !== this._time || !this._ts && !h) { _ = 0, a && (y += this._zTime = -f); break } } s = a } else { s = this._last; for (var k = t < 0 ? t : n; s;) { if (a = s._prev, (s._act || k <= s._end) && s._ts && _ !== s) { if (s.parent !== this) return this.render(t, e, i); if (s.render(s._ts > 0 ? (k - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (k - s._start) * s._ts, e, i), n !== this._time || !this._ts && !h) { _ = 0, a && (y += this._zTime = k ? -f : f); break } } s = a } } if (_ && !e && (this.pause(), _.render(n >= g ? 0 : -f)._zTime = n >= g ? 1 : -1, this._ts)) return this._start = l, kt(this), this.render(t, e, i); this._onUpdate && !e && se(this, "onUpdate", !0), (y === v && v >= this.totalDuration() || !y && g) && (l !== this._start && Math.abs(p) === Math.abs(this._ts) || this._lock || ((t || !x) && (y === v && this._ts > 0 || !y && this._ts < 0) && gt(this, 1), e || t < 0 && !g || !y && !g || (se(this, y === v ? "onComplete" : "onReverseComplete", !0), this._prom && !(y < v && this.timeScale() > 0) && this._prom()))) } return this }, s.add = function (t, e) { var r = this; if (w(e) || (e = Lt(this, e)), !(t instanceof ze)) { if (M(t)) return t.forEach(function (t) { return r.add(t, e) }), this; if (y(t)) return this.addLabel(t, e); if (!T(t)) return this; t = Ge.delayedCall(0, t) } return this !== t ? St(this, t, e) : this }, s.getChildren = function (t, e, r, i) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === r && (r = !0), void 0 === i && (i = -l); for (var n = [], s = this._first; s;)s._start >= i && (s instanceof Ge ? e && n.push(s) : (r && n.push(s), t && n.push.apply(n, s.getChildren(!0, e, r)))), s = s._next; return n }, s.getById = function (t) { for (var e = this.getChildren(1, 1, 1), r = e.length; r--;)if (e[r].vars.id === t) return e[r] }, s.remove = function (t) { return y(t) ? this.removeLabel(t) : T(t) ? this.killTweensOf(t) : (mt(this, t), t === this._recent && (this._recent = this._last), vt(this)) }, s.totalTime = function (t, e) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = et(ge.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), i.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime }, s.addLabel = function (t, e) { return this.labels[t] = Lt(this, e), this }, s.removeLabel = function (t) { return delete this.labels[t], this }, s.addPause = function (t, e, r) { var i = Ge.delayedCall(0, e || q, r); return i.data = "isPause", this._hasPause = 1, St(this, i, Lt(this, t)) }, s.removePause = function (t) { var e = this._first; for (t = Lt(this, t); e;)e._start === t && "isPause" === e.data && gt(e), e = e._next }, s.killTweensOf = function (t, e, r) { for (var i = this.getTweensOf(t, r), n = i.length; n--;)Le !== i[n] && i[n].kill(t, e); return this }, s.getTweensOf = function (t, e) { for (var r, i = [], n = jt(t), s = this._first, a = w(e); s;)s instanceof Ge ? rt(s._targets, n) && (a ? (!Le || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (r = s.getTweensOf(n, e)).length && i.push.apply(i, r), s = s._next; return i }, s.tweenTo = function (t, e) { e = e || {}; var r = this, i = Lt(r, t), n = e, s = n.startAt, a = n.onStart, o = n.onStartParams, u = Ge.to(r, ut(e, { ease: "none", lazy: !1, time: i, overwrite: "auto", duration: e.duration || Math.abs((i - (s && "time" in s ? s.time : r._time)) / r.timeScale()) || f, onStart: function () { r.pause(); var t = e.duration || Math.abs((i - r._time) / r.timeScale()); u._dur !== t && Et(u, t, 0, 1).render(u._time, !0, !0), a && a.apply(u, o || []) } })); return u }, s.tweenFromTo = function (t, e, r) { return this.tweenTo(e, ut({ startAt: { time: Lt(this, t) } }, r)) }, s.recent = function () { return this._recent }, s.nextLabel = function (t) { return void 0 === t && (t = this._time), ne(this, Lt(this, t)) }, s.previousLabel = function (t) { return void 0 === t && (t = this._time), ne(this, Lt(this, t), 1) }, s.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + f) }, s.shiftChildren = function (t, e, r) { void 0 === r && (r = 0); for (var i, n = this._first, s = this.labels; n;)n._start >= r && (n._start += t, n._end += t), n = n._next; if (e) for (i in s) s[i] >= r && (s[i] += t); return vt(this) }, s.invalidate = function () { var t = this._first; for (this._lock = 0; t;)t.invalidate(), t = t._next; return i.prototype.invalidate.call(this) }, s.clear = function (t) { void 0 === t && (t = !0); for (var e, r = this._first; r;)e = r._next, this.remove(r), r = e; return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), vt(this) }, s.totalDuration = function (t) { var e, i, n, s = 0, a = this._last, o = l; if (arguments.length) return this.timeScale((this._repeat < 0 ? this.duration() : this.totalDuration()) / (this.reversed() ? -t : t)); if (this._dirty) { for (n = this.parent; a;)e = a._prev, a._dirty && a.totalDuration(), (i = a._start) > o && this._sort && a._ts && !this._lock ? (this._lock = 1, St(this, a, i - a._delay, 1)._lock = 0) : o = i, i < 0 && a._ts && (s -= i, (!n && !this._dp || n && n.smoothChildTiming) && (this._start += i / this._ts, this._time -= i, this._tTime -= i), this.shiftChildren(-i, !1, -Infinity), o = 0), a._end > s && a._ts && (s = a._end), a = e; Et(this, this === r && this._time > s ? this._time : s, 1, 1), this._dirty = 0 } return this._tDur }, n.updateRoot = function (t) { if (r._ts && (st(r, bt(t, r)), o = ge.frame), ge.frame >= H) { H += _.autoSleep || 120; var e = r._first; if ((!e || !e._ts) && _.autoSleep && ge._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || ge.sleep() } } }, n }(ze); exports.TimelineLite = exports.TimelineMax = exports.Timeline = Oe, ut(Oe.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var Le, Fe = function (t, e, r, i, n, s, a) { var o, u, h, _, p, l, f, c, d = new sr(this._pt, t, e, 0, 1, $e, null, n), m = 0, g = 0; for (d.b = r, d.e = i, r += "", (f = ~(i += "").indexOf("random(")) && (i = ee(i)), s && (s(c = [r, i], t, e), r = c[0], i = c[1]), u = r.match(z) || []; o = z.exec(i);)_ = o[0], p = i.substring(m, o.index), h ? h = (h + 1) % 5 : "rgba(" === p.substr(-5) && (h = 1), _ !== u[g++] && (l = parseFloat(u[g - 1]) || 0, d._pt = { _next: d._pt, p: p || 1 === g ? p : ",", s: l, c: "=" === _.charAt(1) ? parseFloat(_.substr(2)) * ("-" === _.charAt(0) ? -1 : 1) : parseFloat(_) - l, m: h && h < 4 ? Math.round : 0 }, m = z.lastIndex); return d.c = m < i.length ? i.substring(m, i.length) : "", d.fp = a, (O.test(i) || f) && (d.e = 0), this._pt = d, d }, Ue = function (t, e, r, i, n, s, a, o, u) { T(i) && (i = i(n || 0, t, s)); var h, p = t[e], l = "get" !== r ? r : T(p) ? u ? t[e.indexOf("set") || !T(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](u) : t[e]() : p, f = T(p) ? u ? He : Ye : We; if (y(i) && (~i.indexOf("random(") && (i = ee(i)), "=" === i.charAt(1) && (i = parseFloat(l) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (It(l) || 0))), l !== i) return isNaN(l * i) ? (!p && !(e in t) && B(e, i), Fe.call(this, t, e, l, i, f, o || _.stringFilter, u)) : (h = new sr(this._pt, t, e, +l || 0, i - (l || 0), "boolean" == typeof p ? Ze : Xe, 0, f), u && (h.fp = u), a && h.modifier(a, this, t), this._pt = h) }, Ie = function (t, e, r, i, n) { if (T(t) && (t = qe(t, n, e, r, i)), !k(t) || t.style && t.nodeType || M(t) || A(t)) return y(t) ? qe(t, n, e, r, i) : t; var s, a = {}; for (s in t) a[s] = qe(t[s], n, e, r, i); return a }, Be = function (t, e, r, i, n, s) { var a, o, h, _; if (W[t] && !1 !== (a = new W[t]).init(n, a.rawVars ? e[t] : Ie(e[t], i, n, s, r), r, i, s) && (r._pt = o = new sr(r._pt, n, t, 0, 1, a.render, a, 0, a.priority), r !== u)) for (h = r._ptLookup[r._targets.indexOf(n)], _ = a._props.length; _--;)h[a._props[_]] = o; return a }, Ne = function t(e, i) { var n, s, a, o, u, h, _, l, c, d, m, g, v, x = e.vars, y = x.ease, T = x.startAt, w = x.immediateRender, b = x.lazy, k = x.onUpdate, C = x.onUpdateParams, S = x.callbackScope, A = x.runBackwards, M = x.yoyoEase, P = x.keyframes, R = x.autoRevert, E = e._dur, z = e._startAt, O = e._targets, L = e.parent, F = L && "nested" === L.data ? L.parent._targets : O, U = "auto" === e._overwrite, I = e.timeline; if (I && (!P || !y) && (y = "none"), e._ease = Se(y, p.ease), e._yEase = M ? De(Se(!0 === M ? y : M, p.ease)) : 0, M && e._yoyo && !e._repeat && (M = e._yEase, e._yEase = e._ease, e._ease = M), !I) { if (g = (l = O[0] ? Z(O[0]).harness : 0) && x[l.prop], n = lt(x, j), z && z.render(-1, !0).kill(), T) { if (gt(e._startAt = Ge.set(O, ut({ data: "isStart", overwrite: !1, parent: L, immediateRender: !0, lazy: D(b), startAt: null, delay: 0, onUpdate: k, onUpdateParams: C, callbackScope: S, stagger: 0 }, T))), w) if (i > 0) R || (e._startAt = 0); else if (E && !(i < 0 && z)) return void (i && (e._zTime = i)) } else if (A && E) if (z) !R && (e._startAt = 0); else if (i && (w = !1), a = ut({ overwrite: !1, data: "isFromStart", lazy: w && D(b), immediateRender: w, stagger: 0, parent: L }, n), g && (a[l.prop] = g), gt(e._startAt = Ge.set(O, a)), w) { if (!i) return } else t(e._startAt, f); for (e._pt = 0, b = E && D(b) || b && !E, s = 0; s < O.length; s++) { if (_ = (u = O[s])._gsap || X(O)[s]._gsap, e._ptLookup[s] = d = {}, G[_.id] && V.length && nt(), m = F === O ? s : F.indexOf(u), l && !1 !== (c = new l).init(u, g || n, e, m, F) && (e._pt = o = new sr(e._pt, u, c.name, 0, 1, c.render, c, 0, c.priority), c._props.forEach(function (t) { d[t] = o }), c.priority && (h = 1)), !l || g) for (a in n) W[a] && (c = Be(a, n, e, m, u, F)) ? c.priority && (h = 1) : d[a] = o = Ue.call(e, u, a, "get", n[a], m, F, 0, x.stringFilter); e._op && e._op[s] && e.kill(u, e._op[s]), U && e._pt && (Le = e, r.killTweensOf(u, d, e.globalTime(0)), v = !e.parent, Le = 0), e._pt && b && (G[_.id] = 1) } h && nr(e), e._onInit && e._onInit(e) } e._from = !I && !!x.runBackwards, e._onUpdate = k, e._initted = (!e._op || e._pt) && !v }, Qe = function (t, e) { var r, i, n, s, a = t[0] ? Z(t[0]).harness : 0, o = a && a.aliases; if (!o) return e; for (i in r = _t({}, e), o) if (i in r) for (n = (s = o[i].split(",")).length; n--;)r[s[n]] = r[i]; return r }, qe = function (t, e, r, i, n) { return T(t) ? t.call(e, r, i, n) : y(t) && ~t.indexOf("random(") ? ee(t) : t }, je = K + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", Ve = (je + ",id,stagger,delay,duration,paused,scrollTrigger").split(","); exports._checkPlugin = Be; var Ge = function (i) { function n(e, n, s, a) { var o; "number" == typeof n && (s.duration = n, n = s, s = null); var u, h, p, l, c, d, m, g, v = (o = i.call(this, a ? n : ft(n), s) || this).vars, x = v.duration, y = v.delay, T = v.immediateRender, b = v.stagger, C = v.overwrite, P = v.keyframes, R = v.defaults, E = v.scrollTrigger, z = v.yoyoEase, O = o.parent, L = (M(e) || A(e) ? w(e[0]) : "length" in n) ? [e] : jt(e); if (o._targets = L.length ? X(L) : N("GSAP target " + e + " not found. https://greensock.com", !_.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = C, P || b || S(x) || S(y)) { if (n = o.vars, (u = o.timeline = new Oe({ data: "nested", defaults: R || {} })).kill(), u.parent = t(o), P) ut(u.vars.defaults, { ease: "none" }), P.forEach(function (t) { return u.to(L, t, ">") }); else { if (l = L.length, m = b ? Gt(b) : q, k(b)) for (c in b) ~je.indexOf(c) && (g || (g = {}), g[c] = b[c]); for (h = 0; h < l; h++) { for (c in p = {}, n) Ve.indexOf(c) < 0 && (p[c] = n[c]); p.stagger = 0, z && (p.yoyoEase = z), g && _t(p, g), d = L[h], p.duration = +qe(x, t(o), h, d, L), p.delay = (+qe(y, t(o), h, d, L) || 0) - o._delay, !b && 1 === l && p.delay && (o._delay = y = p.delay, o._start += y, p.delay = 0), u.to(d, p, m(h, d, L)) } u.duration() ? x = y = 0 : o.timeline = 0 } x || o.duration(x = u.duration()) } else o.timeline = 0; return !0 === C && (Le = t(o), r.killTweensOf(L), Le = 0), O && Ct(O, t(o)), (T || !x && !P && o._start === et(O._time) && D(T) && yt(t(o)) && "nested" !== O.data) && (o._tTime = -f, o.render(Math.max(0, -y))), E && At(t(o), E), o } e(n, i); var s = n.prototype; return s.render = function (t, e, r) { var i, n, s, a, o, u, h, _, p, l = this._time, c = this._tDur, d = this._dur, m = t > c - f && t >= 0 ? c : t < f ? 0 : t; if (d) { if (m !== this._tTime || !t || r || this._startAt && this._zTime < 0 != t < 0) { if (i = m, _ = this.timeline, this._repeat) { if (a = d + this._rDelay, i = et(m % a), m === c ? (s = this._repeat, i = d) : ((s = ~~(m / a)) && s === m / a && (i = d, s--), i > d && (i = d)), (u = this._yoyo && 1 & s) && (p = this._yEase, i = d - i), o = wt(this._tTime, a), i === l && !r && this._initted) return this; s !== o && (_ && this._yEase && Ce(_, u), !this.vars.repeatRefresh || u || this._lock || (this._lock = r = 1, this.render(et(a * s), !0).invalidate()._lock = 0)) } if (!this._initted) { if (Mt(this, t < 0 ? t : i, r, e)) return this._tTime = 0, this; if (d !== this._dur) return this.render(t, e, r) } for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (p || this._ease)(i / d), this._from && (this.ratio = h = 1 - h), i && !l && !e && se(this, "onStart"), n = this._pt; n;)n.r(h, n.d), n = n._next; _ && _.render(t < 0 ? t : !i && u ? -f : _._dur * h, e, r) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, r), se(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !e && this.parent && se(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !d) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && gt(this, 1), e || t < 0 && !l || !m && !l || (se(this, m === c ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < c && this.timeScale() > 0) && this._prom())) } } else Pt(this, t, e, r); return this }, s.targets = function () { return this._targets }, s.invalidate = function () { return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), i.prototype.invalidate.call(this) }, s.kill = function (t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return ae(this); if (this.timeline) { var r = this.timeline.totalDuration(); return this.timeline.killTweensOf(t, e, Le && !0 !== Le.vars.overwrite)._first || ae(this), this.parent && r !== this.timeline.totalDuration() && Et(this, this._dur * this.timeline._tDur / r, 0, 1), this } var i, n, s, a, o, u, h, _ = this._targets, p = t ? jt(t) : _, l = this._ptLookup, f = this._pt; if ((!e || "all" === e) && ct(_, p)) return "all" === e && (this._pt = 0), ae(this); for (i = this._op = this._op || [], "all" !== e && (y(e) && (o = {}, tt(e, function (t) { return o[t] = 1 }), e = o), e = Qe(_, e)), h = _.length; h--;)if (~p.indexOf(_[h])) for (o in n = l[h], "all" === e ? (i[h] = e, a = n, s = {}) : (s = i[h] = i[h] || {}, a = e), a) (u = n && n[o]) && ("kill" in u.d && !0 !== u.d.kill(o) || mt(this, u, "_pt"), delete n[o]), "all" !== s && (s[o] = 1); return this._initted && !this._pt && f && ae(this), this }, n.to = function (t, e) { return new n(t, e, arguments[2]) }, n.from = function (t, e) { return new n(t, it(arguments, 1)) }, n.delayedCall = function (t, e, r, i) { return new n(e, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: e, onReverseComplete: e, onCompleteParams: r, onReverseCompleteParams: r, callbackScope: i }) }, n.fromTo = function (t, e, r) { return new n(t, it(arguments, 2)) }, n.set = function (t, e) { return e.duration = 0, e.repeatDelay || (e.repeat = 0), new n(t, e) }, n.killTweensOf = function (t, e, i) { return r.killTweensOf(t, e, i) }, n }(ze); exports.TweenLite = exports.TweenMax = exports.Tween = Ge, ut(Ge.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), tt("staggerTo,staggerFrom,staggerFromTo", function (t) { Ge[t] = function () { var e = new Oe, r = Nt.call(arguments, 0); return r.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, r) } }); var We = function (t, e, r) { return t[e] = r }, Ye = function (t, e, r) { return t[e](r) }, He = function (t, e, r, i) { return t[e](i.fp, r) }, Je = function (t, e, r) { return t.setAttribute(e, r) }, Ke = function (t, e) { return T(t[e]) ? Ye : b(t[e]) && t.setAttribute ? Je : We }, Xe = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e) }, Ze = function (t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, $e = function (t, e) { var r = e._pt, i = ""; if (!t && e.b) i = e.b; else if (1 === t && e.e) i = e.e; else { for (; r;)i = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round(1e4 * (r.s + r.c * t)) / 1e4) + i, r = r._next; i += e.c } e.set(e.t, e.p, i, e) }, tr = function (t, e) { for (var r = e._pt; r;)r.r(t, r.d), r = r._next }, er = function (t, e, r, i) { for (var n, s = this._pt; s;)n = s._next, s.p === i && s.modifier(t, e, r), s = n }, rr = function (t) { for (var e, r, i = this._pt; i;)r = i._next, i.p === t && !i.op || i.op === t ? mt(this, i, "_pt") : i.dep || (e = 1), i = r; return !e }, ir = function (t, e, r, i) { i.mSet(t, e, i.m.call(i.tween, r, i.mt), i) }, nr = function (t) { for (var e, r, i, n, s = t._pt; s;) { for (e = s._next, r = i; r && r.pr > s.pr;)r = r._next; (s._prev = r ? r._prev : n) ? s._prev._next = s : i = s, (s._next = r) ? r._prev = s : n = s, s = e } t._pt = i }; exports._sortPropTweensByPriority = nr, exports._renderComplexString = $e, exports._getSetter = Ke; var sr = function () { function t(t, e, r, i, n, s, a, o, u) { this.t = e, this.s = i, this.c = n, this.p = r, this.r = s || Xe, this.d = a || this, this.set = o || We, this.pr = u || 0, this._next = t, t && (t._prev = this) } return t.prototype.modifier = function (t, e, r) { this.mSet = this.mSet || this.set, this.set = ir, this.m = t, this.mt = r, this.tween = e }, t }(); exports.PropTween = sr, tt(K + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (t) { return j[t] = 1 }), F.TweenMax = F.TweenLite = Ge, F.TimelineLite = F.TimelineMax = Oe, r = new Oe({ sortChildren: !1, defaults: p, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), _.stringFilter = me; var ar = { registerPlugin: function () { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; e.forEach(function (t) { return oe(t) }) }, timeline: function (t) { return new Oe(t) }, getTweensOf: function (t, e) { return r.getTweensOf(t, e) }, getProperty: function (t, e, r, i) { y(t) && (t = jt(t)[0]); var n = Z(t || {}).get, s = r ? ot : at; return "native" === r && (r = ""), t ? e ? s((W[e] && W[e].get || n)(t, e, r, i)) : function (e, r, i) { return s((W[e] && W[e].get || n)(t, e, r, i)) } : t }, quickSetter: function (t, e, r) { if ((t = jt(t)).length > 1) { var i = t.map(function (t) { return _r.quickSetter(t, e, r) }), n = i.length; return function (t) { for (var e = n; e--;)i[e](t) } } t = t[0] || {}; var s = W[e], a = Z(t), o = a.harness && (a.harness.aliases || {})[e] || e, h = s ? function (e) { var i = new s; u._pt = 0, i.init(t, r ? e + r : e, u, 0, [t]), i.render(1, i), u._pt && tr(1, u) } : a.set(t, o); return s ? h : function (e) { return h(t, o, r ? e + r : e, a, 1) } }, isTweening: function (t) { return r.getTweensOf(t, !0).length > 0 }, defaults: function (t) { return t && t.ease && (t.ease = Se(t.ease, p.ease)), pt(p, t || {}) }, config: function (t) { return pt(_, t || {}) }, registerEffect: function (t) { var e = t.name, r = t.effect, i = t.plugins, n = t.defaults, s = t.extendTimeline; (i || "").split(",").forEach(function (t) { return t && !W[t] && !F[t] && N(e + " effect requires " + t + " plugin.") }), Y[e] = function (t, e, i) { return r(jt(t), ut(e || {}, n), i) }, s && (Oe.prototype[e] = function (t, r, i) { return this.add(Y[e](t, k(r) ? r : (i = r) && {}, this), i) }) }, registerEase: function (t, e) { xe[t] = Se(e) }, parseEase: function (t, e) { return arguments.length ? Se(t, e) : xe }, getById: function (t) { return r.getById(t) }, exportRoot: function (t, e) { void 0 === t && (t = {}); var i, n, s = new Oe(t); for (s.smoothChildTiming = D(t.smoothChildTiming), r.remove(s), s._dp = 0, s._time = s._tTime = r._time, i = r._first; i;)n = i._next, !e && !i._dur && i instanceof Ge && i.vars.onComplete === i._targets[0] || St(s, i, i._start - i._delay), i = n; return St(r, s, 0), s }, utils: { wrap: $t, wrapYoyo: te, distribute: Gt, random: Ht, snap: Yt, normalize: Xt, getUnit: It, clamp: Bt, splitColor: pe, toArray: jt, mapRange: re, pipe: Jt, unitize: Kt, interpolate: ie, shuffle: Vt }, install: I, effects: Y, ticker: ge, updateRoot: Oe.updateRoot, plugins: W, globalTimeline: r, core: { PropTween: sr, globals: Q, Tween: Ge, Timeline: Oe, Animation: ze, getCache: Z, _removeLinkedListItem: mt } }; tt("to,from,fromTo,delayedCall,set,killTweensOf", function (t) { return ar[t] = Ge[t] }), ge.add(Oe.updateRoot), u = ar.to({}, { duration: 0 }); var or = function (t, e) { for (var r = t._pt; r && r.p !== e && r.op !== e && r.fp !== e;)r = r._next; return r }, ur = function (t, e) { var r, i, n, s = t._targets; for (r in e) for (i = s.length; i--;)(n = t._ptLookup[i][r]) && (n = n.d) && (n._pt && (n = or(n, r)), n && n.modifier && n.modifier(e[r], t, s[i], r)) }, hr = function (t, e) { return { name: t, rawVars: 1, init: function (t, r, i) { i._onInit = function (t) { var i, n; if (y(r) && (i = {}, tt(r, function (t) { return i[t] = 1 }), r = i), e) { for (n in i = {}, r) i[n] = e(r[n]); r = i } ur(t, r) } } } }, _r = ar.registerPlugin({ name: "attr", init: function (t, e, r, i, n) { var s, a; for (s in e) (a = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], i, n, 0, 0, s)) && (a.op = s), this._props.push(s) } }, { name: "endArray", init: function (t, e) { for (var r = e.length; r--;)this.add(t, r, t[r] || 0, e[r]) } }, hr("roundProps", Wt), hr("modifiers"), hr("snap", Yt)) || ar; exports.default = exports.gsap = _r, Ge.version = Oe.version = _r.version = "3.5.1", a = 1, C() && ve(); var pr = xe.Power0, lr = xe.Power1, fr = xe.Power2, cr = xe.Power3, dr = xe.Power4, mr = xe.Linear, gr = xe.Quad, vr = xe.Cubic, xr = xe.Quart, yr = xe.Quint, Tr = xe.Strong, wr = xe.Elastic, br = xe.Back, kr = xe.SteppedEase, Dr = xe.Bounce, Cr = xe.Sine, Sr = xe.Expo, Ar = xe.Circ; exports.Circ = Ar, exports.Expo = Sr, exports.Sine = Cr, exports.Bounce = Dr, exports.SteppedEase = kr, exports.Back = br, exports.Elastic = wr, exports.Strong = Tr, exports.Quint = yr, exports.Quart = xr, exports.Cubic = vr, exports.Quad = gr, exports.Linear = mr, exports.Power4 = dr, exports.Power3 = cr, exports.Power2 = fr, exports.Power1 = lr, exports.Power0 = pr;
    }, {}], "bp4Z": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.checkPrefix = exports._createElement = exports._getBBox = exports.default = exports.CSSPlugin = void 0; var t, e, r, n, i, s, o, a, p = require("./gsap-core.js"), u = function () { return "undefined" != typeof window }, c = {}, l = 180 / Math.PI, h = Math.PI / 180, f = Math.atan2, g = 1e8, d = /([A-Z])/g, x = /(?:left|right|width|margin|padding|x)/i, m = /[\s,\(]\S/, _ = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, y = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, v = function (t, e) { return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, b = function (t, e) { return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e) }, w = function (t, e) { var r = e.s + e.c * t; e.set(e.t, e.p, ~~(r + (r < 0 ? -.5 : .5)) + e.u, e) }, O = function (t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) }, M = function (t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) }, P = function (t, e, r) { return t.style[e] = r }, C = function (t, e, r) { return t.style.setProperty(e, r) }, B = function (t, e, r) { return t._gsap[e] = r }, S = function (t, e, r) { return t._gsap.scaleX = t._gsap.scaleY = r }, T = function (t, e, r, n, i) { var s = t._gsap; s.scaleX = s.scaleY = r, s.renderTransform(i, s) }, F = function (t, e, r, n, i) { var s = t._gsap; s[e] = r, s.renderTransform(i, s) }, E = "transform", Y = E + "Origin", A = function (t, r) { var n = e.createElementNS ? e.createElementNS((r || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : e.createElement(t); return n.style ? n : e.createElement(t) }, X = function t(e, r, n) { var i = getComputedStyle(e); return i[r] || i.getPropertyValue(r.replace(d, "-$1").toLowerCase()) || i.getPropertyValue(r) || !n && t(e, z(r) || r, 1) || "" }, k = "O,Moz,ms,Ms,Webkit".split(","), z = function (t, e, r) { var n = (e || i).style, s = 5; if (t in n && !r) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); s-- && !(k[s] + t in n);); return s < 0 ? null : (3 === s ? "ms" : s >= 0 ? k[s] : "") + t }, N = function () { u() && window.document && (t = window, e = t.document, r = e.documentElement, i = A("div") || { style: {} }, s = A("div"), E = z(E), Y = E + "Origin", i.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", a = !!z("perspective"), n = 1) }, U = function t(e) { var n, i = A("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), s = this.parentNode, o = this.nextSibling, a = this.style.cssText; if (r.appendChild(i), i.appendChild(this), this.style.display = "block", e) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t } catch (p) { } else this._gsapBBox && (n = this._gsapBBox()); return s && (o ? s.insertBefore(this, o) : s.appendChild(this)), r.removeChild(i), this.style.cssText = a, n }, V = function (t, e) { for (var r = e.length; r--;)if (t.hasAttribute(e[r])) return t.getAttribute(e[r]) }, W = function (t) { var e; try { e = t.getBBox() } catch (r) { e = U.call(t, !0) } return e && (e.width || e.height) || t.getBBox === U || (e = U.call(t, !0)), !e || e.width || e.x || e.y ? e : { x: +V(t, ["x", "cx", "x1"]) || 0, y: +V(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, q = function (t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !W(t)) }, D = function (t, e) { if (e) { var r = t.style; e in c && e !== Y && (e = E), r.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty(e.replace(d, "-$1").toLowerCase())) : r.removeAttribute(e) } }, j = function (t, e, r, n, i, s) { var o = new p.PropTween(t._pt, e, r, 0, 1, s ? M : O); return t._pt = o, o.b = n, o.e = i, t._props.push(r), o }, G = { deg: 1, rad: 1, turn: 1 }, I = function t(r, n, s, o) { var a, u, l, h, f = parseFloat(s) || 0, g = (s + "").trim().substr((f + "").length) || "px", d = i.style, m = x.test(n), _ = "svg" === r.tagName.toLowerCase(), y = (_ ? "client" : "offset") + (m ? "Width" : "Height"), v = "px" === o, b = "%" === o; return o === g || !f || G[o] || G[g] ? f : ("px" !== g && !v && (f = t(r, n, s, "px")), h = r.getCTM && q(r), b && (c[n] || ~n.indexOf("adius")) ? (0, p._round)(f / (h ? r.getBBox()[m ? "width" : "height"] : r[y]) * 100) : (d[m ? "width" : "height"] = 100 + (v ? g : o), u = ~n.indexOf("adius") || "em" === o && r.appendChild && !_ ? r : r.parentNode, h && (u = (r.ownerSVGElement || {}).parentNode), u && u !== e && u.appendChild || (u = e.body), (l = u._gsap) && b && l.width && m && l.time === p._ticker.time ? (0, p._round)(f / l.width * 100) : ((b || "%" === g) && (d.position = X(r, "position")), u === r && (d.position = "static"), u.appendChild(i), a = i[y], u.removeChild(i), d.position = "absolute", m && b && ((l = (0, p._getCache)(u)).time = p._ticker.time, l.width = u[y]), (0, p._round)(v ? a * f / 100 : a && f ? 100 / a * f : 0)))) }, R = function (t, e, r, i) { var s; return n || N(), e in _ && "transform" !== e && ~(e = _[e]).indexOf(",") && (e = e.split(",")[0]), c[e] && "transform" !== e ? (s = it(t, i), s = "transformOrigin" !== e ? s[e] : st(X(t, Y)) + " " + s.zOrigin + "px") : (!(s = t.style[e]) || "auto" === s || i || ~(s + "").indexOf("calc(")) && (s = J[e] && J[e](t, e, r) || X(t, e) || (0, p._getProperty)(t, e) || ("opacity" === e ? 1 : 0)), r && !~(s + "").indexOf(" ") ? I(t, e, s, r) + r : s }, L = function (t, e, r, n) { if (!r || "none" === r) { var i = z(e, t, 1), s = i && X(t, i, 1); s && s !== r ? (e = i, r = s) : "borderColor" === e && (r = X(t, "borderTopColor")) } var o, a, u, c, l, h, f, g, d, x, m, _, y = new p.PropTween(this._pt, t.style, e, 0, 1, p._renderComplexString), v = 0, b = 0; if (y.b = r, y.e = n, r += "", "auto" === (n += "") && (t.style[e] = n, n = X(t, e) || n, t.style[e] = r), o = [r, n], (0, p._colorStringFilter)(o), n = o[1], u = (r = o[0]).match(p._numWithUnitExp) || [], (n.match(p._numWithUnitExp) || []).length) { for (; a = p._numWithUnitExp.exec(n);)f = a[0], d = n.substring(v, a.index), l ? l = (l + 1) % 5 : "rgba(" !== d.substr(-5) && "hsla(" !== d.substr(-5) || (l = 1), f !== (h = u[b++] || "") && (c = parseFloat(h) || 0, m = h.substr((c + "").length), (_ = "=" === f.charAt(1) ? +(f.charAt(0) + "1") : 0) && (f = f.substr(2)), g = parseFloat(f), x = f.substr((g + "").length), v = p._numWithUnitExp.lastIndex - x.length, x || (x = x || p._config.units[e] || m, v === n.length && (n += x, y.e += x)), m !== x && (c = I(t, e, h, x) || 0), y._pt = { _next: y._pt, p: d || 1 === b ? d : ",", s: c, c: _ ? _ * g : g - c, m: l && l < 4 ? Math.round : 0 }); y.c = v < n.length ? n.substring(v, n.length) : "" } else y.r = "display" === e && "none" === n ? M : O; return p._relExp.test(n) && (y.e = 0), this._pt = y, y }, Z = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, H = function (t) { var e = t.split(" "), r = e[0], n = e[1] || "50%"; return "top" !== r && "bottom" !== r && "left" !== n && "right" !== n || (t = r, r = n, n = t), e[0] = Z[r] || r, e[1] = Z[n] || n, e.join(" ") }, $ = function (t, e) { if (e.tween && e.tween._time === e.tween._dur) { var r, n, i, s = e.t, o = s.style, a = e.u, p = s._gsap; if ("all" === a || !0 === a) o.cssText = "", n = 1; else for (i = (a = a.split(",")).length; --i > -1;)r = a[i], c[r] && (n = 1, r = "transformOrigin" === r ? Y : E), D(s, r); n && (D(s, E), p && (p.svg && s.removeAttribute("transform"), it(s, 1), p.uncache = 1)) } }, J = { clearProps: function (t, e, r, n, i) { if ("isFromStart" !== i.data) { var s = t._pt = new p.PropTween(t._pt, e, r, 0, 0, $); return s.u = n, s.pr = -10, s.tween = i, t._props.push(r), 1 } } }, K = [1, 0, 0, 1, 0, 0], Q = {}, tt = function (t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t }, et = function (t) { var e = X(t, E); return tt(e) ? K : e.substr(7).match(p._numExp).map(p._round) }, rt = function (t, e) { var n, i, s, o, a = t._gsap || (0, p._getCache)(t), u = t.style, c = et(t); return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (c = [(s = t.transform.baseVal.consolidate().matrix).a, s.b, s.c, s.d, s.e, s.f]).join(",") ? K : c : (c !== K || t.offsetParent || t === r || a.svg || (s = u.display, u.display = "block", (n = t.parentNode) && t.offsetParent || (o = 1, i = t.nextSibling, r.appendChild(t)), c = et(t), s ? u.display = s : D(t, "display"), o && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : r.removeChild(t))), e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c) }, nt = function (t, e, r, n, i, s) { var o, a, p, u = t._gsap, c = i || rt(t, !0), l = u.xOrigin || 0, h = u.yOrigin || 0, f = u.xOffset || 0, g = u.yOffset || 0, d = c[0], x = c[1], m = c[2], _ = c[3], y = c[4], v = c[5], b = e.split(" "), w = parseFloat(b[0]) || 0, O = parseFloat(b[1]) || 0; r ? c !== K && (a = d * _ - x * m) && (p = w * (-x / a) + O * (d / a) - (d * v - x * y) / a, w = w * (_ / a) + O * (-m / a) + (m * v - _ * y) / a, O = p) : (w = (o = W(t)).x + (~b[0].indexOf("%") ? w / 100 * o.width : w), O = o.y + (~(b[1] || b[0]).indexOf("%") ? O / 100 * o.height : O)), n || !1 !== n && u.smooth ? (y = w - l, v = O - h, u.xOffset = f + (y * d + v * m) - y, u.yOffset = g + (y * x + v * _) - v) : u.xOffset = u.yOffset = 0, u.xOrigin = w, u.yOrigin = O, u.smooth = !!n, u.origin = e, u.originIsAbsolute = !!r, t.style[Y] = "0px 0px", s && (j(s, u, "xOrigin", l, w), j(s, u, "yOrigin", h, O), j(s, u, "xOffset", f, u.xOffset), j(s, u, "yOffset", g, u.yOffset)), t.setAttribute("data-svg-origin", w + " " + O) }, it = function (t, e) { var r = t._gsap || new p.GSCache(t); if ("x" in r && !e && !r.uncache) return r; var n, i, s, o, u, c, g, d, x, m, _, y, v, b, w, O, M, P, C, B, S, T, F, A, k, z, N, U, V, W, D, j, G = t.style, I = r.scaleX < 0, R = X(t, Y) || "0"; return n = i = s = c = g = d = x = m = _ = 0, o = u = 1, r.svg = !(!t.getCTM || !q(t)), b = rt(t, r.svg), r.svg && (A = !r.uncache && t.getAttribute("data-svg-origin"), nt(t, A || R, !!A || r.originIsAbsolute, !1 !== r.smooth, b)), y = r.xOrigin || 0, v = r.yOrigin || 0, b !== K && (P = b[0], C = b[1], B = b[2], S = b[3], n = T = b[4], i = F = b[5], 6 === b.length ? (o = Math.sqrt(P * P + C * C), u = Math.sqrt(S * S + B * B), c = P || C ? f(C, P) * l : 0, (x = B || S ? f(B, S) * l + c : 0) && (u *= Math.cos(x * h)), r.svg && (n -= y - (y * P + v * B), i -= v - (y * C + v * S))) : (j = b[6], W = b[7], N = b[8], U = b[9], V = b[10], D = b[11], n = b[12], i = b[13], s = b[14], g = (w = f(j, V)) * l, w && (A = T * (O = Math.cos(-w)) + N * (M = Math.sin(-w)), k = F * O + U * M, z = j * O + V * M, N = T * -M + N * O, U = F * -M + U * O, V = j * -M + V * O, D = W * -M + D * O, T = A, F = k, j = z), d = (w = f(-B, V)) * l, w && (O = Math.cos(-w), D = S * (M = Math.sin(-w)) + D * O, P = A = P * O - N * M, C = k = C * O - U * M, B = z = B * O - V * M), c = (w = f(C, P)) * l, w && (A = P * (O = Math.cos(w)) + C * (M = Math.sin(w)), k = T * O + F * M, C = C * O - P * M, F = F * O - T * M, P = A, T = k), g && Math.abs(g) + Math.abs(c) > 359.9 && (g = c = 0, d = 180 - d), o = (0, p._round)(Math.sqrt(P * P + C * C + B * B)), u = (0, p._round)(Math.sqrt(F * F + j * j)), w = f(T, F), x = Math.abs(w) > 2e-4 ? w * l : 0, _ = D ? 1 / (D < 0 ? -D : D) : 0), r.svg && (A = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !tt(X(t, E)), A && t.setAttribute("transform", A))), Math.abs(x) > 90 && Math.abs(x) < 270 && (I ? (o *= -1, x += c <= 0 ? 180 : -180, c += c <= 0 ? 180 : -180) : (u *= -1, x += x <= 0 ? 180 : -180)), r.x = ((r.xPercent = n && Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0) ? 0 : n) + "px", r.y = ((r.yPercent = i && Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", r.z = s + "px", r.scaleX = (0, p._round)(o), r.scaleY = (0, p._round)(u), r.rotation = (0, p._round)(c) + "deg", r.rotationX = (0, p._round)(g) + "deg", r.rotationY = (0, p._round)(d) + "deg", r.skewX = x + "deg", r.skewY = m + "deg", r.transformPerspective = _ + "px", (r.zOrigin = parseFloat(R.split(" ")[2]) || 0) && (G[Y] = st(R)), r.xOffset = r.yOffset = 0, r.force3D = p._config.force3D, r.renderTransform = r.svg ? ht : a ? lt : at, r.uncache = 0, r }, st = function (t) { return (t = t.split(" "))[0] + " " + t[1] }, ot = function (t, e, r) { var n = (0, p.getUnit)(e); return (0, p._round)(parseFloat(e) + parseFloat(I(t, "x", r + "px", n))) + n }, at = function (t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, lt(t, e) }, pt = "0deg", ut = "0px", ct = ") ", lt = function (t, e) { var r = e || this, n = r.xPercent, i = r.yPercent, s = r.x, o = r.y, a = r.z, p = r.rotation, u = r.rotationY, c = r.rotationX, l = r.skewX, f = r.skewY, g = r.scaleX, d = r.scaleY, x = r.transformPerspective, m = r.force3D, _ = r.target, y = r.zOrigin, v = "", b = "auto" === m && t && 1 !== t || !0 === m; if (y && (c !== pt || u !== pt)) { var w, O = parseFloat(u) * h, M = Math.sin(O), P = Math.cos(O); O = parseFloat(c) * h, w = Math.cos(O), s = ot(_, s, M * w * -y), o = ot(_, o, -Math.sin(O) * -y), a = ot(_, a, P * w * -y + y) } x !== ut && (v += "perspective(" + x + ct), (n || i) && (v += "translate(" + n + "%, " + i + "%) "), (b || s !== ut || o !== ut || a !== ut) && (v += a !== ut || b ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ct), p !== pt && (v += "rotate(" + p + ct), u !== pt && (v += "rotateY(" + u + ct), c !== pt && (v += "rotateX(" + c + ct), l === pt && f === pt || (v += "skew(" + l + ", " + f + ct), 1 === g && 1 === d || (v += "scale(" + g + ", " + d + ct), _.style[E] = v || "translate(0, 0)" }, ht = function (t, e) { var r, n, i, s, o, a = e || this, u = a.xPercent, c = a.yPercent, l = a.x, f = a.y, g = a.rotation, d = a.skewX, x = a.skewY, m = a.scaleX, _ = a.scaleY, y = a.target, v = a.xOrigin, b = a.yOrigin, w = a.xOffset, O = a.yOffset, M = a.forceCSS, P = parseFloat(l), C = parseFloat(f); g = parseFloat(g), d = parseFloat(d), (x = parseFloat(x)) && (d += x = parseFloat(x), g += x), g || d ? (g *= h, d *= h, r = Math.cos(g) * m, n = Math.sin(g) * m, i = Math.sin(g - d) * -_, s = Math.cos(g - d) * _, d && (x *= h, o = Math.tan(d - x), i *= o = Math.sqrt(1 + o * o), s *= o, x && (o = Math.tan(x), r *= o = Math.sqrt(1 + o * o), n *= o)), r = (0, p._round)(r), n = (0, p._round)(n), i = (0, p._round)(i), s = (0, p._round)(s)) : (r = m, s = _, n = i = 0), (P && !~(l + "").indexOf("px") || C && !~(f + "").indexOf("px")) && (P = I(y, "x", l, "px"), C = I(y, "y", f, "px")), (v || b || w || O) && (P = (0, p._round)(P + v - (v * r + b * i) + w), C = (0, p._round)(C + b - (v * n + b * s) + O)), (u || c) && (o = y.getBBox(), P = (0, p._round)(P + u / 100 * o.width), C = (0, p._round)(C + c / 100 * o.height)), o = "matrix(" + r + "," + n + "," + i + "," + s + "," + P + "," + C + ")", y.setAttribute("transform", o), M && (y.style[E] = o) }, ft = function (t, e, r, n, i, s) { var o, a, u = (0, p._isString)(i), c = parseFloat(i) * (u && ~i.indexOf("rad") ? l : 1), h = s ? c * s : c - n, f = n + h + "deg"; return u && ("short" === (o = i.split("_")[1]) && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), "cw" === o && h < 0 ? h = (h + 360 * g) % 360 - 360 * ~~(h / 360) : "ccw" === o && h > 0 && (h = (h - 360 * g) % 360 - 360 * ~~(h / 360))), t._pt = a = new p.PropTween(t._pt, e, r, n, h, v), a.e = f, a.u = "deg", t._props.push(r), a }, gt = function (t, r, n) { var i, o, a, u, l, h, f, g = s.style, d = n._gsap; for (o in g.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", g[E] = r, e.body.appendChild(s), i = it(s, 1), c) (a = d[o]) !== (u = i[o]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(o) < 0 && (l = (0, p.getUnit)(a) !== (f = (0, p.getUnit)(u)) ? I(n, o, a, f) : parseFloat(a), h = parseFloat(u), t._pt = new p.PropTween(t._pt, d, o, l, h - l, y), t._pt.u = f || 0, t._props.push(o)); e.body.removeChild(s) }; exports._getBBox = W, exports.checkPrefix = z, exports._createElement = A, (0, p._forEachName)("padding,margin,Width,Radius", function (t, e) { var r = "Top", n = "Right", i = "Bottom", s = "Left", o = (e < 3 ? [r, n, i, s] : [r + s, r + n, i + n, i + s]).map(function (r) { return e < 2 ? t + r : "border" + r + t }); J[e > 1 ? "border" + t : t] = function (t, e, r, n, i) { var s, a; if (arguments.length < 4) return s = o.map(function (e) { return R(t, e, r) }), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a; s = (n + "").split(" "), a = {}, o.forEach(function (t, e) { return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0] }), t.init(e, a, i) } }); var dt = { name: "css", register: N, targetTest: function (t) { return t.style && t.nodeType }, init: function (t, e, r, i, s) { var o, a, u, l, h, f, g, d, x, v, O, M, P, C, B, S = this._props, T = t.style; for (g in n || N(), e) if ("autoRound" !== g && (a = e[g], !p._plugins[g] || !(0, p._checkPlugin)(g, e, r, i, t, s))) if (h = typeof a, f = J[g], "function" === h && (h = typeof (a = a.call(r, i, t, s))), "string" === h && ~a.indexOf("random(") && (a = (0, p._replaceRandom)(a)), f) f(this, t, g, a, r) && (B = 1); else if ("--" === g.substr(0, 2)) this.add(T, "setProperty", getComputedStyle(t).getPropertyValue(g) + "", a + "", i, s, 0, 0, g); else if ("undefined" !== h) { if (o = R(t, g), l = parseFloat(o), (v = "string" === h && "=" === a.charAt(1) ? +(a.charAt(0) + "1") : 0) && (a = a.substr(2)), u = parseFloat(a), g in _ && ("autoAlpha" === g && (1 === l && "hidden" === R(t, "visibility") && u && (l = 0), j(this, T, "visibility", l ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), "scale" !== g && "transform" !== g && ~(g = _[g]).indexOf(",") && (g = g.split(",")[0])), O = g in c) if (M || ((P = t._gsap).renderTransform || it(t), C = !1 !== e.smoothOrigin && P.smooth, (M = this._pt = new p.PropTween(this._pt, T, E, 0, 1, P.renderTransform, P, 0, -1)).dep = 1), "scale" === g) this._pt = new p.PropTween(this._pt, P, "scaleY", P.scaleY, v ? v * u : u - P.scaleY), S.push("scaleY", g), g += "X"; else { if ("transformOrigin" === g) { a = H(a), P.svg ? nt(t, a, 0, C, 0, this) : ((x = parseFloat(a.split(" ")[2]) || 0) !== P.zOrigin && j(this, P, "zOrigin", P.zOrigin, x), j(this, T, g, st(o), st(a))); continue } if ("svgOrigin" === g) { nt(t, a, 1, C, 0, this); continue } if (g in Q) { ft(this, P, g, l, a, v); continue } if ("smoothOrigin" === g) { j(this, P, "smooth", P.smooth, a); continue } if ("force3D" === g) { P[g] = a; continue } if ("transform" === g) { gt(this, a, t); continue } } else g in T || (g = z(g) || g); if (O || (u || 0 === u) && (l || 0 === l) && !m.test(a) && g in T) u || (u = 0), (d = (o + "").substr((l + "").length)) !== (x = (0, p.getUnit)(a) || (g in p._config.units ? p._config.units[g] : d)) && (l = I(t, g, o, x)), this._pt = new p.PropTween(this._pt, O ? P : T, g, l, v ? v * u : u - l, "px" !== x || !1 === e.autoRound || O ? y : w), this._pt.u = x || 0, d !== x && (this._pt.b = o, this._pt.r = b); else if (g in T) L.call(this, t, g, o, a); else { if (!(g in t)) { (0, p._missingPlugin)(g, a); continue } this.add(t, g, t[g], a, i, s) } S.push(g) } B && (0, p._sortPropTweensByPriority)(this) }, get: R, aliases: _, getSetter: function (t, e, r) { var n = _[e]; return n && n.indexOf(",") < 0 && (e = n), e in c && e !== Y && (t._gsap.x || R(t, "x")) ? r && o === r ? "scale" === e ? S : B : (o = r || {}) && ("scale" === e ? T : F) : t.style && !(0, p._isUndefined)(t.style[e]) ? P : ~e.indexOf("-") ? C : (0, p._getSetter)(t, e) }, core: { _removeProperty: D, _getMatrix: rt } }; exports.default = exports.CSSPlugin = dt, p.gsap.utils.checkPrefix = z, function (t, e, r, n) { var i = (0, p._forEachName)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + e + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function (t) { c[t] = 1 }); (0, p._forEachName)(e, function (t) { p._config.units[t] = "deg", Q[t] = 1 }), _[i[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + e, (0, p._forEachName)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function (t) { var e = t.split(":"); _[e[1]] = i[e[0]] }) }(0, "rotation,rotationX,rotationY,skewX,skewY"), (0, p._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (t) { p._config.units[t] = "px" }), p.gsap.registerPlugin(dt);
    }, { "./gsap-core.js": "TNS6" }], "TpQl": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), Object.defineProperty(exports, "Power0", { enumerable: !0, get: function () { return e.Power0 } }), Object.defineProperty(exports, "Power1", { enumerable: !0, get: function () { return e.Power1 } }), Object.defineProperty(exports, "Power2", { enumerable: !0, get: function () { return e.Power2 } }), Object.defineProperty(exports, "Power3", { enumerable: !0, get: function () { return e.Power3 } }), Object.defineProperty(exports, "Power4", { enumerable: !0, get: function () { return e.Power4 } }), Object.defineProperty(exports, "Linear", { enumerable: !0, get: function () { return e.Linear } }), Object.defineProperty(exports, "Quad", { enumerable: !0, get: function () { return e.Quad } }), Object.defineProperty(exports, "Cubic", { enumerable: !0, get: function () { return e.Cubic } }), Object.defineProperty(exports, "Quart", { enumerable: !0, get: function () { return e.Quart } }), Object.defineProperty(exports, "Quint", { enumerable: !0, get: function () { return e.Quint } }), Object.defineProperty(exports, "Strong", { enumerable: !0, get: function () { return e.Strong } }), Object.defineProperty(exports, "Elastic", { enumerable: !0, get: function () { return e.Elastic } }), Object.defineProperty(exports, "Back", { enumerable: !0, get: function () { return e.Back } }), Object.defineProperty(exports, "SteppedEase", { enumerable: !0, get: function () { return e.SteppedEase } }), Object.defineProperty(exports, "Bounce", { enumerable: !0, get: function () { return e.Bounce } }), Object.defineProperty(exports, "Sine", { enumerable: !0, get: function () { return e.Sine } }), Object.defineProperty(exports, "Expo", { enumerable: !0, get: function () { return e.Expo } }), Object.defineProperty(exports, "Circ", { enumerable: !0, get: function () { return e.Circ } }), Object.defineProperty(exports, "TweenLite", { enumerable: !0, get: function () { return e.TweenLite } }), Object.defineProperty(exports, "TimelineLite", { enumerable: !0, get: function () { return e.TimelineLite } }), Object.defineProperty(exports, "TimelineMax", { enumerable: !0, get: function () { return e.TimelineMax } }), Object.defineProperty(exports, "CSSPlugin", { enumerable: !0, get: function () { return r.CSSPlugin } }), exports.TweenMax = exports.default = exports.gsap = void 0; var e = require("./gsap-core.js"), r = require("./CSSPlugin.js"), t = e.gsap.registerPlugin(r.CSSPlugin) || e.gsap, n = t.core.Tween; exports.TweenMax = n, exports.default = exports.gsap = t;
    }, { "./gsap-core.js": "TNS6", "./CSSPlugin.js": "bp4Z" }], "dKqR": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.AmbientLight = gf, exports.AmbientLightProbe = zf, exports.AnimationClip = fd, exports.AnimationLoader = Md, exports.AnimationMixer = ym, exports.AnimationObjectGroup = gm, exports.ArcCurve = Pd, exports.ArrayCamera = ph, exports.ArrowHelper = ag, exports.Audio = Jf, exports.AudioAnalyser = nm, exports.AudioListener = Zf, exports.AudioLoader = Uf, exports.AxesHelper = cg, exports.AxisHelper = cv, exports.BinaryTextureLoader = dv, exports.Bone = Xh, exports.BooleanKeyframeTrack = ad, exports.BoundingBoxHelper = lv, exports.Box2 = Am, exports.Box3 = Ii, exports.Box3Helper = ng, exports.BoxHelper = eg, exports.BufferAttribute = _r, exports.BufferGeometry = Gr, exports.BufferGeometryLoader = Sf, exports.Camera = _o, exports.CameraHelper = Km, exports.CanvasRenderer = gv, exports.CanvasTexture = xu, exports.CatmullRomCurve3 = Fd, exports.CircleBufferGeometry = kp, exports.CircleGeometry = Hp, exports.Clock = jf, exports.ClosedSplineCurve3 = ov, exports.Color = hr, exports.ColorKeyframeTrack = cd, exports.CompressedTexture = yu, exports.CompressedTextureLoader = Sd, exports.ConeBufferGeometry = zp, exports.ConeGeometry = Gp, exports.CubeCamera = So, exports.CubeTexture = vc, exports.CubeTextureLoader = Ad, exports.CubicBezierCurve = Yd, exports.CubicBezierCurve3 = Zd, exports.CubicInterpolant = id, exports.Curve = Rd, exports.CurvePath = nf, exports.CylinderBufferGeometry = Up, exports.CylinderGeometry = Fp, exports.Cylindrical = Tm, exports.DataTexture = Eo, exports.DataTexture2DArray = yc, exports.DataTexture3D = xc, exports.DataTextureLoader = Td, exports.DepthTexture = _u, exports.DirectionalLight = mf, exports.DirectionalLightHelper = Zm, exports.DirectionalLightShadow = ff, exports.DiscreteInterpolant = od, exports.DodecahedronBufferGeometry = Du, exports.DodecahedronGeometry = Ou, exports.DynamicBufferAttribute = Zg, exports.EdgesGeometry = Bp, exports.EdgesHelper = hv, exports.EllipseCurve = Cd, exports.Euler = ri, exports.EventDispatcher = Pn, exports.ExtrudeBufferGeometry = wp, exports.ExtrudeGeometry = bp, exports.Face3 = fr, exports.Face4 = Ig, exports.FileLoader = wd, exports.Float32Attribute = iv, exports.Float32BufferAttribute = Lr, exports.Float64Attribute = rv, exports.Float64BufferAttribute = Rr, exports.Fog = _h, exports.FogExp2 = xh, exports.Font = Of, exports.FontLoader = Nf, exports.Frustum = Ro, exports.Geometry = ho, exports.GridHelper = jm, exports.Group = dh, exports.HemisphereLight = af, exports.HemisphereLightHelper = Vm, exports.HemisphereLightProbe = Gf, exports.IcosahedronBufferGeometry = Pu, exports.IcosahedronGeometry = Cu, exports.ImageBitmapLoader = Cf, exports.ImageLoader = Ed, exports.ImmediateRenderObject = Pm, exports.InstancedBufferAttribute = Mf, exports.InstancedBufferGeometry = wf, exports.InstancedInterleavedBuffer = _m, exports.InstancedMesh = Kh, exports.Int16Attribute = $g, exports.Int16BufferAttribute = Sr, exports.Int32Attribute = ev, exports.Int32BufferAttribute = Er, exports.Int8Attribute = Jg, exports.Int8BufferAttribute = br, exports.InterleavedBuffer = bh, exports.InterleavedBufferAttribute = Mh, exports.Interpolant = nd, exports.JSONLoader = vv, exports.KeyframeTrack = sd, exports.LOD = kh, exports.LatheBufferGeometry = Op, exports.LatheGeometry = Pp, exports.Layers = oi, exports.LensFlare = xv, exports.Light = sf, exports.LightProbe = xf, exports.LightShadow = cf, exports.Line = ou, exports.Line3 = Cm, exports.LineBasicMaterial = $h, exports.LineCurve = Jd, exports.LineCurve3 = Qd, exports.LineDashedMaterial = $p, exports.LineLoop = lu, exports.LineSegments = cu, exports.LinearInterpolant = rd, exports.Loader = _d, exports.LoadingManager = yd, exports.Material = gr, exports.MaterialLoader = _f, exports.Matrix3 = Bn, exports.Matrix4 = ei, exports.Mesh = io, exports.MeshBasicMaterial = vr, exports.MeshDepthMaterial = rh, exports.MeshDistanceMaterial = oh, exports.MeshFaceMaterial = zg, exports.MeshLambertMaterial = Qp, exports.MeshMatcapMaterial = Kp, exports.MeshNormalMaterial = Jp, exports.MeshPhongMaterial = Yp, exports.MeshPhysicalMaterial = Xp, exports.MeshStandardMaterial = qp, exports.MeshToonMaterial = Zp, exports.MultiMaterial = Hg, exports.NumberKeyframeTrack = ld, exports.Object3D = xi, exports.ObjectLoader = Ef, exports.OctahedronBufferGeometry = Ru, exports.OctahedronGeometry = Lu, exports.OrthographicCamera = df, exports.PMREMGenerator = Sg, exports.ParametricBufferGeometry = Mu, exports.ParametricGeometry = wu, exports.Particle = Vg, exports.ParticleBasicMaterial = qg, exports.ParticleSystem = jg, exports.ParticleSystemMaterial = Xg, exports.Path = rf, exports.PerspectiveCamera = bo, exports.Plane = Zi, exports.PlaneBufferGeometry = Io, exports.PlaneGeometry = Do, exports.PlaneHelper = ig, exports.PointCloud = kg, exports.PointCloudMaterial = Wg, exports.PointLight = pf, exports.PointLightHelper = Gm, exports.Points = mu, exports.PointsMaterial = hu, exports.PolarGridHelper = Wm, exports.PolyhedronBufferGeometry = Tu, exports.PolyhedronGeometry = Su, exports.PositionalAudio = em, exports.PropertyBinding = mm, exports.PropertyMixer = im, exports.QuadraticBezierCurve = Kd, exports.QuadraticBezierCurve3 = $d, exports.Quaternion = jn, exports.QuaternionKeyframeTrack = ud, exports.QuaternionLinearInterpolant = hd, exports.RawShaderMaterial = Wp, exports.Ray = Wi, exports.Raycaster = bm, exports.RectAreaLight = vf, exports.RingBufferGeometry = Cp, exports.RingGeometry = Rp, exports.Scene = _i, exports.ShaderMaterial = xo, exports.ShadowMaterial = jp, exports.Shape = of, exports.ShapeBufferGeometry = Ip, exports.ShapeGeometry = Dp, exports.ShapePath = Pf, exports.Skeleton = qh, exports.SkeletonHelper = Um, exports.SkinnedMesh = Vh, exports.Sphere = Fi, exports.SphereBufferGeometry = Lp, exports.SphereGeometry = Ap, exports.SphericalHarmonics3 = yf, exports.Spline = av, exports.SplineCurve = tf, exports.SplineCurve3 = sv, exports.SpotLight = hf, exports.SpotLightHelper = Dm, exports.SpotLightShadow = lf, exports.Sprite = Uh, exports.SpriteMaterial = Sh, exports.StereoCamera = Vf, exports.StringKeyframeTrack = pd, exports.TetrahedronBufferGeometry = Au, exports.TetrahedronGeometry = Eu, exports.TextBufferGeometry = Ep, exports.TextGeometry = Tp, exports.Texture = zn, exports.TextureLoader = Ld, exports.TorusBufferGeometry = Gu, exports.TorusGeometry = Uu, exports.TorusKnotBufferGeometry = Fu, exports.TorusKnotGeometry = Bu, exports.Triangle = sr, exports.TubeBufferGeometry = Nu, exports.TubeGeometry = Iu, exports.Uint16Attribute = tv, exports.Uint16BufferAttribute = Tr, exports.Uint32Attribute = nv, exports.Uint32BufferAttribute = Ar, exports.Uint8Attribute = Qg, exports.Uint8BufferAttribute = wr, exports.Uint8ClampedAttribute = Kg, exports.Uint8ClampedBufferAttribute = Mr, exports.Uniform = xm, exports.Vector2 = Nn, exports.Vector3 = Xn, exports.Vector4 = Hn, exports.VectorKeyframeTrack = dd, exports.Vertex = Yg, exports.VideoTexture = vu, exports.WebGL1Renderer = yh, exports.WebGLCubeRenderTarget = To, exports.WebGLMultisampleRenderTarget = Vn, exports.WebGLRenderTarget = kn, exports.WebGLRenderTargetCube = fv, exports.WebGLRenderer = vh, exports.WebGLUtils = uh, exports.WireframeGeometry = bu, exports.WireframeHelper = uv, exports.XHRLoader = pv, exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MathUtils = exports.Math = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoaderUtils = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LinePieces = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GeometryUtils = exports.GammaEncoding = exports.FrontSide = exports.FloatType = exports.FlatShading = exports.FaceColors = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.Cache = exports.ByteType = exports.CubeGeometry = exports.BoxGeometry = exports.BoxBufferGeometry = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AudioContext = exports.AnimationUtils = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0, exports.UniformsLib = exports.UVMapping = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.Spherical = exports.SmoothShading = exports.ShortType = exports.ShapeUtils = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = exports.RGBFormat = exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = void 0, exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.VertexColors = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = void 0, void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); const e = Object(t); for (let n = 1; n < arguments.length; n++) { const t = arguments[n]; if (null != t) for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) } return e }); const t = "119"; exports.REVISION = "119"; const e = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }; exports.MOUSE = e; const n = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }; exports.TOUCH = n; const i = 0; exports.CullFaceNone = i; const r = 1; exports.CullFaceBack = r; const o = 2; exports.CullFaceFront = o; const s = 3; exports.CullFaceFrontBack = 3; const a = 0; exports.BasicShadowMap = 0; const c = 1; exports.PCFShadowMap = c; const l = 2; exports.PCFSoftShadowMap = l; const h = 3; exports.VSMShadowMap = h; const u = 0; exports.FrontSide = u; const p = 1; exports.BackSide = p; const d = 2; exports.DoubleSide = d; const f = 1; exports.FlatShading = 1; const m = 2; exports.SmoothShading = 2; const g = 0; exports.NoBlending = g; const v = 1; exports.NormalBlending = v; const y = 2; exports.AdditiveBlending = y; const x = 3; exports.SubtractiveBlending = x; const _ = 4; exports.MultiplyBlending = _; const b = 5; exports.CustomBlending = b; const w = 100; exports.AddEquation = w; const M = 101; exports.SubtractEquation = M; const S = 102; exports.ReverseSubtractEquation = S; const T = 103; exports.MinEquation = T; const E = 104; exports.MaxEquation = E; const A = 200; exports.ZeroFactor = A; const L = 201; exports.OneFactor = L; const R = 202; exports.SrcColorFactor = R; const C = 203; exports.OneMinusSrcColorFactor = C; const P = 204; exports.SrcAlphaFactor = P; const O = 205; exports.OneMinusSrcAlphaFactor = O; const D = 206; exports.DstAlphaFactor = D; const I = 207; exports.OneMinusDstAlphaFactor = I; const N = 208; exports.DstColorFactor = N; const B = 209; exports.OneMinusDstColorFactor = B; const F = 210; exports.SrcAlphaSaturateFactor = F; const U = 0; exports.NeverDepth = U; const G = 1; exports.AlwaysDepth = G; const z = 2; exports.LessDepth = z; const H = 3; exports.LessEqualDepth = H; const k = 4; exports.EqualDepth = k; const V = 5; exports.GreaterEqualDepth = V; const j = 6; exports.GreaterDepth = j; const W = 7; exports.NotEqualDepth = W; const q = 0; exports.MultiplyOperation = q; const X = 1; exports.MixOperation = X; const Y = 2; exports.AddOperation = Y; const Z = 0; exports.NoToneMapping = Z; const J = 1; exports.LinearToneMapping = J; const Q = 2; exports.ReinhardToneMapping = Q; const K = 3; exports.CineonToneMapping = K; const $ = 4; exports.ACESFilmicToneMapping = $; const tt = 5; exports.CustomToneMapping = tt; const et = 300; exports.UVMapping = 300; const nt = 301; exports.CubeReflectionMapping = nt; const it = 302; exports.CubeRefractionMapping = it; const rt = 303; exports.EquirectangularReflectionMapping = rt; const ot = 304; exports.EquirectangularRefractionMapping = ot; const st = 306; exports.CubeUVReflectionMapping = st; const at = 307; exports.CubeUVRefractionMapping = at; const ct = 1e3; exports.RepeatWrapping = ct; const lt = 1001; exports.ClampToEdgeWrapping = lt; const ht = 1002; exports.MirroredRepeatWrapping = ht; const ut = 1003; exports.NearestFilter = ut; const pt = 1004; exports.NearestMipmapNearestFilter = pt; const dt = 1004; exports.NearestMipMapNearestFilter = 1004; const ft = 1005; exports.NearestMipmapLinearFilter = ft; const mt = 1005; exports.NearestMipMapLinearFilter = 1005; const gt = 1006; exports.LinearFilter = gt; const vt = 1007; exports.LinearMipmapNearestFilter = vt; const yt = 1007; exports.LinearMipMapNearestFilter = 1007; const xt = 1008; exports.LinearMipmapLinearFilter = xt; const _t = 1008; exports.LinearMipMapLinearFilter = 1008; const bt = 1009; exports.UnsignedByteType = bt; const wt = 1010; exports.ByteType = wt; const Mt = 1011; exports.ShortType = Mt; const St = 1012; exports.UnsignedShortType = St; const Tt = 1013; exports.IntType = Tt; const Et = 1014; exports.UnsignedIntType = Et; const At = 1015; exports.FloatType = At; const Lt = 1016; exports.HalfFloatType = Lt; const Rt = 1017; exports.UnsignedShort4444Type = Rt; const Ct = 1018; exports.UnsignedShort5551Type = Ct; const Pt = 1019; exports.UnsignedShort565Type = Pt; const Ot = 1020; exports.UnsignedInt248Type = Ot; const Dt = 1021; exports.AlphaFormat = Dt; const It = 1022; exports.RGBFormat = It; const Nt = 1023; exports.RGBAFormat = Nt; const Bt = 1024; exports.LuminanceFormat = Bt; const Ft = 1025; exports.LuminanceAlphaFormat = Ft; const Ut = Nt; exports.RGBEFormat = Ut; const Gt = 1026; exports.DepthFormat = Gt; const zt = 1027; exports.DepthStencilFormat = zt; const Ht = 1028; exports.RedFormat = Ht; const kt = 1029; exports.RedIntegerFormat = kt; const Vt = 1030; exports.RGFormat = Vt; const jt = 1031; exports.RGIntegerFormat = jt; const Wt = 1032; exports.RGBIntegerFormat = Wt; const qt = 1033; exports.RGBAIntegerFormat = qt; const Xt = 33776; exports.RGB_S3TC_DXT1_Format = Xt; const Yt = 33777; exports.RGBA_S3TC_DXT1_Format = Yt; const Zt = 33778; exports.RGBA_S3TC_DXT3_Format = Zt; const Jt = 33779; exports.RGBA_S3TC_DXT5_Format = Jt; const Qt = 35840; exports.RGB_PVRTC_4BPPV1_Format = Qt; const Kt = 35841; exports.RGB_PVRTC_2BPPV1_Format = Kt; const $t = 35842; exports.RGBA_PVRTC_4BPPV1_Format = $t; const te = 35843; exports.RGBA_PVRTC_2BPPV1_Format = te; const ee = 36196; exports.RGB_ETC1_Format = ee; const ne = 37492; exports.RGB_ETC2_Format = ne; const ie = 37496; exports.RGBA_ETC2_EAC_Format = ie; const re = 37808; exports.RGBA_ASTC_4x4_Format = re; const oe = 37809; exports.RGBA_ASTC_5x4_Format = oe; const se = 37810; exports.RGBA_ASTC_5x5_Format = se; const ae = 37811; exports.RGBA_ASTC_6x5_Format = ae; const ce = 37812; exports.RGBA_ASTC_6x6_Format = ce; const le = 37813; exports.RGBA_ASTC_8x5_Format = le; const he = 37814; exports.RGBA_ASTC_8x6_Format = he; const ue = 37815; exports.RGBA_ASTC_8x8_Format = ue; const pe = 37816; exports.RGBA_ASTC_10x5_Format = pe; const de = 37817; exports.RGBA_ASTC_10x6_Format = de; const fe = 37818; exports.RGBA_ASTC_10x8_Format = fe; const me = 37819; exports.RGBA_ASTC_10x10_Format = me; const ge = 37820; exports.RGBA_ASTC_12x10_Format = ge; const ve = 37821; exports.RGBA_ASTC_12x12_Format = ve; const ye = 36492; exports.RGBA_BPTC_Format = ye; const xe = 37840; exports.SRGB8_ALPHA8_ASTC_4x4_Format = xe; const _e = 37841; exports.SRGB8_ALPHA8_ASTC_5x4_Format = _e; const be = 37842; exports.SRGB8_ALPHA8_ASTC_5x5_Format = be; const we = 37843; exports.SRGB8_ALPHA8_ASTC_6x5_Format = we; const Me = 37844; exports.SRGB8_ALPHA8_ASTC_6x6_Format = Me; const Se = 37845; exports.SRGB8_ALPHA8_ASTC_8x5_Format = Se; const Te = 37846; exports.SRGB8_ALPHA8_ASTC_8x6_Format = Te; const Ee = 37847; exports.SRGB8_ALPHA8_ASTC_8x8_Format = Ee; const Ae = 37848; exports.SRGB8_ALPHA8_ASTC_10x5_Format = Ae; const Le = 37849; exports.SRGB8_ALPHA8_ASTC_10x6_Format = Le; const Re = 37850; exports.SRGB8_ALPHA8_ASTC_10x8_Format = Re; const Ce = 37851; exports.SRGB8_ALPHA8_ASTC_10x10_Format = Ce; const Pe = 37852; exports.SRGB8_ALPHA8_ASTC_12x10_Format = Pe; const Oe = 37853; exports.SRGB8_ALPHA8_ASTC_12x12_Format = Oe; const De = 2200; exports.LoopOnce = 2200; const Ie = 2201; exports.LoopRepeat = Ie; const Ne = 2202; exports.LoopPingPong = 2202; const Be = 2300; exports.InterpolateDiscrete = 2300; const Fe = 2301; exports.InterpolateLinear = 2301; const Ue = 2302; exports.InterpolateSmooth = 2302; const Ge = 2400; exports.ZeroCurvatureEnding = Ge; const ze = 2401; exports.ZeroSlopeEnding = 2401; const He = 2402; exports.WrapAroundEnding = 2402; const ke = 2500; exports.NormalAnimationBlendMode = ke; const Ve = 2501; exports.AdditiveAnimationBlendMode = 2501; const je = 0; exports.TrianglesDrawMode = 0; const We = 1; exports.TriangleStripDrawMode = 1; const qe = 2; exports.TriangleFanDrawMode = 2; const Xe = 3e3; exports.LinearEncoding = Xe; const Ye = 3001; exports.sRGBEncoding = Ye; const Ze = 3007; exports.GammaEncoding = Ze; const Je = 3002; exports.RGBEEncoding = Je; const Qe = 3003; exports.LogLuvEncoding = Qe; const Ke = 3004; exports.RGBM7Encoding = Ke; const $e = 3005; exports.RGBM16Encoding = $e; const tn = 3006; exports.RGBDEncoding = tn; const en = 3200; exports.BasicDepthPacking = en; const nn = 3201; exports.RGBADepthPacking = nn; const rn = 0; exports.TangentSpaceNormalMap = rn; const on = 1; exports.ObjectSpaceNormalMap = on; const sn = 0; exports.ZeroStencilOp = 0; const an = 7680; exports.KeepStencilOp = an; const cn = 7681; exports.ReplaceStencilOp = 7681; const ln = 7682; exports.IncrementStencilOp = 7682; const hn = 7683; exports.DecrementStencilOp = 7683; const un = 34055; exports.IncrementWrapStencilOp = 34055; const pn = 34056; exports.DecrementWrapStencilOp = 34056; const dn = 5386; exports.InvertStencilOp = 5386; const fn = 512; exports.NeverStencilFunc = 512; const mn = 513; exports.LessStencilFunc = 513; const gn = 514; exports.EqualStencilFunc = 514; const vn = 515; exports.LessEqualStencilFunc = 515; const yn = 516; exports.GreaterStencilFunc = 516; const xn = 517; exports.NotEqualStencilFunc = 517; const _n = 518; exports.GreaterEqualStencilFunc = 518; const bn = 519; exports.AlwaysStencilFunc = bn; const wn = 35044; exports.StaticDrawUsage = wn; const Mn = 35048; exports.DynamicDrawUsage = Mn; const Sn = 35040; exports.StreamDrawUsage = 35040; const Tn = 35045; exports.StaticReadUsage = 35045; const En = 35049; exports.DynamicReadUsage = 35049; const An = 35041; exports.StreamReadUsage = 35041; const Ln = 35046; exports.StaticCopyUsage = 35046; const Rn = 35050; exports.DynamicCopyUsage = 35050; const Cn = 35042; function Pn() { } exports.StreamCopyUsage = 35042, Object.assign(Pn.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } }, dispatchEvent: function (t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, i = n.length; e < i; e++)n[e].call(this, t) } } }); const On = []; for (let _v = 0; _v < 256; _v++)On[_v] = (_v < 16 ? "0" : "") + _v.toString(16); let Dn = 1234567; const In = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (On[255 & t] + On[t >> 8 & 255] + On[t >> 16 & 255] + On[t >> 24 & 255] + "-" + On[255 & e] + On[e >> 8 & 255] + "-" + On[e >> 16 & 15 | 64] + On[e >> 24 & 255] + "-" + On[63 & n | 128] + On[n >> 8 & 255] + "-" + On[n >> 16 & 255] + On[n >> 24 & 255] + On[255 & i] + On[i >> 8 & 255] + On[i >> 16 & 255] + On[i >> 24 & 255]).toUpperCase() }, clamp: function (t, e, n) { return Math.max(e, Math.min(n, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, lerp: function (t, e, n) { return (1 - n) * t + n * e }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { return void 0 !== t && (Dn = t % 2147483647), ((Dn = 16807 * Dn % 2147483647) - 1) / 2147483646 }, degToRad: function (t) { return t * In.DEG2RAD }, radToDeg: function (t) { return t * In.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }, setQuaternionFromProperEuler: function (t, e, n, i, r) { const o = Math.cos, s = Math.sin, a = o(n / 2), c = s(n / 2), l = o((e + i) / 2), h = s((e + i) / 2), u = o((e - i) / 2), p = s((e - i) / 2), d = o((i - e) / 2), f = s((i - e) / 2); switch (r) { case "XYX": t.set(a * h, c * u, c * p, a * l); break; case "YZY": t.set(c * p, a * h, c * u, a * l); break; case "ZXZ": t.set(c * u, c * p, a * h, a * l); break; case "XZX": t.set(a * h, c * f, c * d, a * l); break; case "YXY": t.set(c * d, a * h, c * f, a * l); break; case "ZYZ": t.set(c * f, c * d, a * h, a * l); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } }; function Nn(t = 0, e = 0) { this.x = t, this.y = e } function Bn() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } let Fn; exports.MathUtils = exports.Math = In, Object.defineProperties(Nn.prototype, { width: { get: function () { return this.x }, set: function (t) { this.x = t } }, height: { get: function () { return this.y }, set: function (t) { this.y = t } } }), Object.assign(Nn.prototype, { isVector2: !0, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.x = t, this.y = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, applyMatrix3: function (t) { const e = this.x, n = this.y, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { return Math.atan2(-this.y, -this.x) + Math.PI }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { const n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, o = this.y - t.y; return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this } }), Object.assign(Bn.prototype, { isMatrix3: !0, set: function (t, e, n, i, r, o, s, a, c) { const l = this.elements; return l[0] = t, l[1] = i, l[2] = s, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this }, extractBasis: function (t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }, setFromMatrix4: function (t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }, multiply: function (t) { return this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[3], a = n[6], c = n[1], l = n[4], h = n[7], u = n[2], p = n[5], d = n[8], f = i[0], m = i[3], g = i[6], v = i[1], y = i[4], x = i[7], _ = i[2], b = i[5], w = i[8]; return r[0] = o * f + s * v + a * _, r[3] = o * m + s * y + a * b, r[6] = o * g + s * x + a * w, r[1] = c * f + l * v + h * _, r[4] = c * m + l * y + h * b, r[7] = c * g + l * x + h * w, r[2] = u * f + p * v + d * _, r[5] = u * m + p * y + d * b, r[8] = u * g + p * x + d * w, this }, multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8]; return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a }, getInverse: function (t, e) { void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."); const n = t.elements, i = this.elements, r = n[0], o = n[1], s = n[2], a = n[3], c = n[4], l = n[5], h = n[6], u = n[7], p = n[8], d = p * c - l * u, f = l * h - p * a, m = u * a - c * h, g = r * d + o * f + s * m; if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const v = 1 / g; return i[0] = d * v, i[1] = (s * u - p * o) * v, i[2] = (l * o - s * c) * v, i[3] = f * v, i[4] = (p * r - s * h) * v, i[5] = (s * a - l * r) * v, i[6] = m * v, i[7] = (o * h - u * r) * v, i[8] = (c * r - o * a) * v, this }, transpose: function () { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, setUvTransform: function (t, e, n, i, r, o, s) { const a = Math.cos(r), c = Math.sin(r); this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1) }, scale: function (t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }, rotate: function (t) { const e = Math.cos(t), n = Math.sin(t), i = this.elements, r = i[0], o = i[3], s = i[6], a = i[1], c = i[4], l = i[7]; return i[0] = e * r + n * a, i[3] = e * o + n * c, i[6] = e * s + n * l, i[1] = -n * r + e * a, i[4] = -n * o + e * c, i[7] = -n * s + e * l, this }, translate: function (t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }, equals: function (t) { const e = this.elements, n = t.elements; for (let i = 0; i < 9; i++)if (e[i] !== n[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } }); const Un = { getDataURL: function (t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === Fn && (Fn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Fn.width = t.width, Fn.height = t.height; const n = Fn.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Fn } return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") } }; exports.ImageUtils = Un; let Gn = 0; function zn(t, e, n, i, r, o, s, a, c, l) { Object.defineProperty(this, "id", { value: Gn++ }), this.uuid = In.generateUUID(), this.name = "", this.image = void 0 !== t ? t : zn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : zn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : lt, this.wrapT = void 0 !== i ? i : lt, this.magFilter = void 0 !== r ? r : gt, this.minFilter = void 0 !== o ? o : xt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : Nt, this.internalFormat = null, this.type = void 0 !== a ? a : bt, this.offset = new Nn(0, 0), this.repeat = new Nn(1, 1), this.center = new Nn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Bn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : Xe, this.version = 0, this.onUpdate = null } function Hn(t = 0, e = 0, n = 0, i = 1) { this.x = t, this.y = e, this.z = n, this.w = i } function kn(t, e, n) { this.width = t, this.height = e, this.scissor = new Hn(0, 0, t, e), this.scissorTest = !1, this.viewport = new Hn(0, 0, t, e), n = n || {}, this.texture = new zn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : gt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function Vn(t, e, n) { kn.call(this, t, e, n), this.samples = 4 } function jn(t = 0, e = 0, n = 0, i = 1) { this._x = t, this._y = e, this._z = n, this._w = i } zn.DEFAULT_IMAGE = void 0, zn.DEFAULT_MAPPING = 300, zn.prototype = Object.assign(Object.create(Pn.prototype), { constructor: zn, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const i = this.image; if (void 0 === i.uuid && (i.uuid = In.generateUUID()), !e && void 0 === t.images[i.uuid]) { let e; if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++)e.push(Un.getDataURL(i[t])) } else e = Un.getDataURL(i); t.images[i.uuid] = { uuid: i.uuid, url: e } } n.image = i.uuid } return e || (t.textures[this.uuid] = n), n }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case ct: t.x = t.x - Math.floor(t.x); break; case lt: t.x = t.x < 0 ? 0 : 1; break; case ht: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case ct: t.y = t.y - Math.floor(t.y); break; case lt: t.y = t.y < 0 ? 0 : 1; break; case ht: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(zn.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.defineProperties(Hn.prototype, { width: { get: function () { return this.z }, set: function (t) { this.z = t } }, height: { get: function () { return this.w }, set: function (t) { this.w = t } } }), Object.assign(Hn.prototype, { isVector4: !0, set: function (t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { const e = this.x, n = this.y, i = this.z, r = this.w, o = t.elements; return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { let e, n, i, r; const o = t.elements, s = o[0], a = o[4], c = o[8], l = o[1], h = o[5], u = o[9], p = o[2], d = o[6], f = o[10]; if (Math.abs(a - l) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) { if (Math.abs(a + l) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(s + h + f - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (s + 1) / 2, o = (h + 1) / 2, m = (f + 1) / 2, g = (a + l) / 4, v = (c + p) / 4, y = (u + d) / 4; return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = g / (n = Math.sqrt(t)), r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = g / (i = Math.sqrt(o)), r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = v / (r = Math.sqrt(m)), i = y / r), this.set(n, i, r, e), this } let m = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (l - a) * (l - a)); return Math.abs(m) < .001 && (m = 1), this.x = (d - u) / m, this.y = (c - p) / m, this.z = (l - a) / m, this.w = Math.acos((s + h + f - 1) / 2), this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } }), kn.prototype = Object.assign(Object.create(Pn.prototype), { constructor: kn, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Vn.prototype = Object.assign(Object.create(kn.prototype), { constructor: Vn, isWebGLMultisampleRenderTarget: !0, copy: function (t) { return kn.prototype.copy.call(this, t), this.samples = t.samples, this } }), Object.assign(jn, { slerp: function (t, e, n, i) { return n.copy(t).slerp(e, i) }, slerpFlat: function (t, e, n, i, r, o, s) { let a = n[i + 0], c = n[i + 1], l = n[i + 2], h = n[i + 3]; const u = r[o + 0], p = r[o + 1], d = r[o + 2], f = r[o + 3]; if (h !== f || a !== u || c !== p || l !== d) { let t = 1 - s, e = a * u + c * p + l * d + h * f, n = e >= 0 ? 1 : -1, i = 1 - e * e; if (i > Number.EPSILON) { const r = Math.sqrt(i), o = Math.atan2(r, e * n); t = Math.sin(t * o) / r, s = Math.sin(s * o) / r } const r = s * n; if (a = a * t + u * r, c = c * t + p * r, l = l * t + d * r, h = h * t + f * r, t === 1 - s) { const t = 1 / Math.sqrt(a * a + c * c + l * l + h * h); a *= t, c *= t, l *= t, h *= t } } t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h }, multiplyQuaternionsFlat: function (t, e, n, i, r, o) { const s = n[i], a = n[i + 1], c = n[i + 2], l = n[i + 3], h = r[o], u = r[o + 1], p = r[o + 2], d = r[o + 3]; return t[e] = s * d + l * h + a * p - c * u, t[e + 1] = a * d + l * u + c * h - s * p, t[e + 2] = c * d + l * p + s * u - a * h, t[e + 3] = l * d - s * h - a * u - c * p, t } }), Object.defineProperties(jn.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this._onChangeCallback() } } }), Object.assign(jn.prototype, { isQuaternion: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }, setFromEuler: function (t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = t._x, i = t._y, r = t._z, o = t.order, s = Math.cos, a = Math.sin, c = s(n / 2), l = s(i / 2), h = s(r / 2), u = a(n / 2), p = a(i / 2), d = a(r / 2); switch (o) { case "XYZ": this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d; break; case "YXZ": this._x = u * l * h + c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d; break; case "ZXY": this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h - u * p * d; break; case "ZYX": this._x = u * l * h - c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h + u * p * d; break; case "YZX": this._x = u * l * h + c * p * d, this._y = c * p * h + u * l * d, this._z = c * l * d - u * p * h, this._w = c * l * h - u * p * d; break; case "XZY": this._x = u * l * h - c * p * d, this._y = c * p * h - u * l * d, this._z = c * l * d + u * p * h, this._w = c * l * h + u * p * d; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return !1 !== e && this._onChangeCallback(), this }, setFromAxisAngle: function (t, e) { const n = e / 2, i = Math.sin(n); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this }, setFromRotationMatrix: function (t) { const e = t.elements, n = e[0], i = e[4], r = e[8], o = e[1], s = e[5], a = e[9], c = e[2], l = e[6], h = e[10], u = n + s + h; if (u > 0) { const t = .5 / Math.sqrt(u + 1); this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (o - i) * t } else if (n > s && n > h) { const t = 2 * Math.sqrt(1 + n - s - h); this._w = (l - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + c) / t } else if (s > h) { const t = 2 * Math.sqrt(1 + s - n - h); this._w = (r - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + l) / t } else { const t = 2 * Math.sqrt(1 + h - n - s); this._w = (o - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t } return this._onChangeCallback(), this }, setFromUnitVectors: function (t, e) { let n = t.dot(e) + 1; return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() }, angleTo: function (t) { return 2 * Math.acos(Math.abs(In.clamp(this.dot(t), -1, 1))) }, rotateTowards: function (t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this }, identity: function () { return this.set(0, 0, 0, 1) }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { const n = t._x, i = t._y, r = t._z, o = t._w, s = e._x, a = e._y, c = e._z, l = e._w; return this._x = n * l + o * s + i * c - r * a, this._y = i * l + o * a + r * s - n * c, this._z = r * l + o * c + n * a - i * s, this._w = o * l - n * s - i * a - r * c, this._onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, i = this._y, r = this._z, o = this._w; let s = o * t._w + n * t._x + i * t._y + r * t._z; if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this; const a = 1 - s * s; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(a), l = Math.atan2(c, s), h = Math.sin((1 - e) * l) / c, u = Math.sin(e * l) / c; return this._w = o * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, fromBufferAttribute: function (t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }); const Wn = new Xn, qn = new jn; function Xn(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n } Object.assign(Xn.prototype, { isVector3: !0, set: function (t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: function (t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(qn.setFromEuler(t)) }, applyAxisAngle: function (t, e) { return this.applyQuaternion(qn.setFromAxisAngle(t, e)) }, applyMatrix3: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this }, applyNormalMatrix: function (t) { return this.applyMatrix3(t).normalize() }, applyMatrix4: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this }, applyQuaternion: function (t) { const e = this.x, n = this.y, i = this.z, r = t.x, o = t.y, s = t.z, a = t.w, c = a * e + o * i - s * n, l = a * n + s * e - r * i, h = a * i + r * n - o * e, u = -r * e - o * n - s * i; return this.x = c * a + u * -r + l * -s - h * -o, this.y = l * a + u * -o + h * -r - c * -s, this.z = h * a + u * -s + c * -o - l * -r, this }, project: function (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, unproject: function (t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }, transformDirection: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }, cross: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, crossVectors: function (t, e) { const n = t.x, i = t.y, r = t.z, o = e.x, s = e.y, a = e.z; return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this }, projectOnVector: function (t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) }, projectOnPlane: function (t) { return Wn.copy(this).projectOnVector(t), this.sub(Wn) }, reflect: function (t) { return this.sub(Wn.copy(t).multiplyScalar(2 * this.dot(t))) }, angleTo: function (t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(In.clamp(n, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z; return e * e + n * n + i * i }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, setFromSphericalCoords: function (t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }, setFromCylindrical: function (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, setFromCylindricalCoords: function (t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }, setFromMatrixPosition: function (t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }, setFromMatrixScale: function (t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = i, this }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.elements, 4 * e) }, setFromMatrix3Column: function (t, e) { return this.fromArray(t.elements, 3 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } }); const Yn = new Xn, Zn = new ei, Jn = new Xn(0, 0, 0), Qn = new Xn(1, 1, 1), Kn = new Xn, $n = new Xn, ti = new Xn; function ei() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } Object.assign(ei.prototype, { isMatrix4: !0, set: function (t, e, n, i, r, o, s, a, c, l, h, u, p, d, f, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new ei).fromArray(this.elements) }, copy: function (t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this }, copyPosition: function (t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this }, extractBasis: function (t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }, extractRotation: function (t) { const e = this.elements, n = t.elements, i = 1 / Yn.setFromMatrixColumn(t, 0).length(), r = 1 / Yn.setFromMatrixColumn(t, 1).length(), o = 1 / Yn.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromEuler: function (t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const e = this.elements, n = t.x, i = t.y, r = t.z, o = Math.cos(n), s = Math.sin(n), a = Math.cos(i), c = Math.sin(i), l = Math.cos(r), h = Math.sin(r); if ("XYZ" === t.order) { const t = o * l, n = o * h, i = s * l, r = s * h; e[0] = a * l, e[4] = -a * h, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -s * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = o * a } else if ("YXZ" === t.order) { const t = a * l, n = a * h, i = c * l, r = c * h; e[0] = t + r * s, e[4] = i * s - n, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a } else if ("ZXY" === t.order) { const t = a * l, n = a * h, i = c * l, r = c * h; e[0] = t - r * s, e[4] = -o * h, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * l, e[9] = r - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a } else if ("ZYX" === t.order) { const t = o * l, n = o * h, i = s * l, r = s * h; e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * h, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = s * a, e[10] = o * a } else if ("YZX" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * h + i, e[10] = t - r * h } else if ("XZY" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = -h, e[8] = c * l, e[1] = t * h + r, e[5] = o * l, e[9] = n * h - i, e[2] = i * h - n, e[6] = s * l, e[10] = r * h + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromQuaternion: function (t) { return this.compose(Jn, t, Qn) }, lookAt: function (t, e, n) { const i = this.elements; return ti.subVectors(t, e), 0 === ti.lengthSq() && (ti.z = 1), ti.normalize(), Kn.crossVectors(n, ti), 0 === Kn.lengthSq() && (1 === Math.abs(n.z) ? ti.x += 1e-4 : ti.z += 1e-4, ti.normalize(), Kn.crossVectors(n, ti)), Kn.normalize(), $n.crossVectors(ti, Kn), i[0] = Kn.x, i[4] = $n.x, i[8] = ti.x, i[1] = Kn.y, i[5] = $n.y, i[9] = ti.y, i[2] = Kn.z, i[6] = $n.z, i[10] = ti.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[4], a = n[8], c = n[12], l = n[1], h = n[5], u = n[9], p = n[13], d = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], x = n[11], _ = n[15], b = i[0], w = i[4], M = i[8], S = i[12], T = i[1], E = i[5], A = i[9], L = i[13], R = i[2], C = i[6], P = i[10], O = i[14], D = i[3], I = i[7], N = i[11], B = i[15]; return r[0] = o * b + s * T + a * R + c * D, r[4] = o * w + s * E + a * C + c * I, r[8] = o * M + s * A + a * P + c * N, r[12] = o * S + s * L + a * O + c * B, r[1] = l * b + h * T + u * R + p * D, r[5] = l * w + h * E + u * C + p * I, r[9] = l * M + h * A + u * P + p * N, r[13] = l * S + h * L + u * O + p * B, r[2] = d * b + f * T + m * R + g * D, r[6] = d * w + f * E + m * C + g * I, r[10] = d * M + f * A + m * P + g * N, r[14] = d * S + f * L + m * O + g * B, r[3] = v * b + y * T + x * R + _ * D, r[7] = v * w + y * E + x * C + _ * I, r[11] = v * M + y * A + x * P + _ * N, r[15] = v * S + y * L + x * O + _ * B, this }, multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, determinant: function () { const t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], o = t[1], s = t[5], a = t[9], c = t[13], l = t[2], h = t[6], u = t[10], p = t[14]; return t[3] * (+r * a * h - i * c * h - r * s * u + n * c * u + i * s * p - n * a * p) + t[7] * (+e * a * p - e * c * u + r * o * u - i * o * p + i * c * l - r * a * l) + t[11] * (+e * c * h - e * s * p - r * o * h + n * o * p + r * s * l - n * c * l) + t[15] * (-i * s * l - e * a * h + e * s * u + i * o * h - n * o * u + n * a * l) }, transpose: function () { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function (t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this }, getInverse: function (t, e) { void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."); const n = this.elements, i = t.elements, r = i[0], o = i[1], s = i[2], a = i[3], c = i[4], l = i[5], h = i[6], u = i[7], p = i[8], d = i[9], f = i[10], m = i[11], g = i[12], v = i[13], y = i[14], x = i[15], _ = d * y * u - v * f * u + v * h * m - l * y * m - d * h * x + l * f * x, b = g * f * u - p * y * u - g * h * m + c * y * m + p * h * x - c * f * x, w = p * v * u - g * d * u + g * l * m - c * v * m - p * l * x + c * d * x, M = g * d * h - p * v * h - g * l * f + c * v * f + p * l * y - c * d * y, S = r * _ + o * b + s * w + a * M; if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const T = 1 / S; return n[0] = _ * T, n[1] = (v * f * a - d * y * a - v * s * m + o * y * m + d * s * x - o * f * x) * T, n[2] = (l * y * a - v * h * a + v * s * u - o * y * u - l * s * x + o * h * x) * T, n[3] = (d * h * a - l * f * a - d * s * u + o * f * u + l * s * m - o * h * m) * T, n[4] = b * T, n[5] = (p * y * a - g * f * a + g * s * m - r * y * m - p * s * x + r * f * x) * T, n[6] = (g * h * a - c * y * a - g * s * u + r * y * u + c * s * x - r * h * x) * T, n[7] = (c * f * a - p * h * a + p * s * u - r * f * u - c * s * m + r * h * m) * T, n[8] = w * T, n[9] = (g * d * a - p * v * a - g * o * m + r * v * m + p * o * x - r * d * x) * T, n[10] = (c * v * a - g * l * a + g * o * u - r * v * u - c * o * x + r * l * x) * T, n[11] = (p * l * a - c * d * a - p * o * u + r * d * u + c * o * m - r * l * m) * T, n[12] = M * T, n[13] = (p * v * s - g * d * s + g * o * f - r * v * f - p * o * y + r * d * y) * T, n[14] = (g * l * s - c * v * s - g * o * h + r * v * h + c * o * y - r * l * y) * T, n[15] = (c * d * s - p * l * s + p * o * h - r * d * h - c * o * f + r * l * f) * T, this }, scale: function (t) { const e = this.elements, n = t.x, i = t.y, r = t.z; return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this }, getMaxScaleOnAxis: function () { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, i)) }, makeTranslation: function (t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }, makeRotationX: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { const n = Math.cos(e), i = Math.sin(e), r = 1 - n, o = t.x, s = t.y, a = t.z, c = r * o, l = r * s; return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }, makeShear: function (t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this }, compose: function (t, e, n) { const i = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, c = r + r, l = o + o, h = s + s, u = r * c, p = r * l, d = r * h, f = o * l, m = o * h, g = s * h, v = a * c, y = a * l, x = a * h, _ = n.x, b = n.y, w = n.z; return i[0] = (1 - (f + g)) * _, i[1] = (p + x) * _, i[2] = (d - y) * _, i[3] = 0, i[4] = (p - x) * b, i[5] = (1 - (u + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (d + y) * w, i[9] = (m - v) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this }, decompose: function (t, e, n) { const i = this.elements; let r = Yn.set(i[0], i[1], i[2]).length(), o = Yn.set(i[4], i[5], i[6]).length(), s = Yn.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Zn.copy(this); const a = 1 / r, c = 1 / o, l = 1 / s; return Zn.elements[0] *= a, Zn.elements[1] *= a, Zn.elements[2] *= a, Zn.elements[4] *= c, Zn.elements[5] *= c, Zn.elements[6] *= c, Zn.elements[8] *= l, Zn.elements[9] *= l, Zn.elements[10] *= l, e.setFromRotationMatrix(Zn), n.x = r, n.y = o, n.z = s, this }, makePerspective: function (t, e, n, i, r, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const s = this.elements, a = 2 * r / (e - t), c = 2 * r / (n - i), l = (e + t) / (e - t), h = (n + i) / (n - i), u = -(o + r) / (o - r), p = -2 * o * r / (o - r); return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this }, makeOrthographic: function (t, e, n, i, r, o) { const s = this.elements, a = 1 / (e - t), c = 1 / (n - i), l = 1 / (o - r), h = (e + t) * a, u = (n + i) * c, p = (o + r) * l; return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this }, equals: function (t) { const e = this.elements, n = t.elements; for (let i = 0; i < 16; i++)if (e[i] !== n[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } }); const ni = new ei, ii = new jn; function ri(t = 0, e = 0, n = 0, i = ri.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = i } function oi() { this.mask = 1 } ri.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ri.DefaultOrder = "XYZ", Object.defineProperties(ri.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this._onChangeCallback() } } }), Object.assign(ri.prototype, { isEuler: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }, setFromRotationMatrix: function (t, e, n) { const i = In.clamp, r = t.elements, o = r[0], s = r[4], a = r[8], c = r[1], l = r[5], h = r[9], u = r[2], p = r[6], d = r[10]; switch (e = e || this._order) { case "XYZ": this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(p, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0); break; case "ZXY": this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(c, o)); break; case "ZYX": this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-h, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !1 !== n && this._onChangeCallback(), this }, setFromQuaternion: function (t, e, n) { return ni.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ni, e, n) }, setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: function (t) { return ii.setFromEuler(this), this.setFromQuaternion(ii, t) }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new Xn(this._x, this._y, this._z) }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }), Object.assign(oi.prototype, { set: function (t) { this.mask = 1 << t | 0 }, enable: function (t) { this.mask |= 1 << t | 0 }, enableAll: function () { this.mask = -1 }, toggle: function (t) { this.mask ^= 1 << t | 0 }, disable: function (t) { this.mask &= ~(1 << t | 0) }, disableAll: function () { this.mask = 0 }, test: function (t) { return 0 != (this.mask & t.mask) } }); let si = 0; const ai = new Xn, ci = new jn, li = new ei, hi = new Xn, ui = new Xn, pi = new Xn, di = new jn, fi = new Xn(1, 0, 0), mi = new Xn(0, 1, 0), gi = new Xn(0, 0, 1), vi = { type: "added" }, yi = { type: "removed" }; function xi() { Object.defineProperty(this, "id", { value: si++ }), this.uuid = In.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = xi.DefaultUp.clone(); const t = new Xn, e = new ri, n = new jn, i = new Xn(1, 1, 1); e._onChange(function () { n.setFromEuler(e, !1) }), n._onChange(function () { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new ei }, normalMatrix: { value: new Bn } }), this.matrix = new ei, this.matrixWorld = new ei, this.matrixAutoUpdate = xi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new oi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } function _i() { xi.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } xi.DefaultUp = new Xn(0, 1, 0), xi.DefaultMatrixAutoUpdate = !0, xi.prototype = Object.assign(Object.create(Pn.prototype), { constructor: xi, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function (t, e) { return ci.setFromAxisAngle(t, e), this.quaternion.multiply(ci), this }, rotateOnWorldAxis: function (t, e) { return ci.setFromAxisAngle(t, e), this.quaternion.premultiply(ci), this }, rotateX: function (t) { return this.rotateOnAxis(fi, t) }, rotateY: function (t) { return this.rotateOnAxis(mi, t) }, rotateZ: function (t) { return this.rotateOnAxis(gi, t) }, translateOnAxis: function (t, e) { return ai.copy(t).applyQuaternion(this.quaternion), this.position.add(ai.multiplyScalar(e)), this }, translateX: function (t) { return this.translateOnAxis(fi, t) }, translateY: function (t) { return this.translateOnAxis(mi, t) }, translateZ: function (t) { return this.translateOnAxis(gi, t) }, localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function (t) { return t.applyMatrix4(li.getInverse(this.matrixWorld)) }, lookAt: function (t, e, n) { t.isVector3 ? hi.copy(t) : hi.set(t, e, n); const i = this.parent; this.updateWorldMatrix(!0, !1), ui.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? li.lookAt(ui, hi, this.up) : li.lookAt(hi, ui, this.up), this.quaternion.setFromRotationMatrix(li), i && (li.extractRotation(i.matrixWorld), ci.setFromRotationMatrix(li), this.quaternion.premultiply(ci.inverse())) }, add: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(vi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(yi)), this }, attach: function (t) { return this.updateWorldMatrix(!0, !1), li.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), li.multiply(t.parent.matrixWorld)), t.applyMatrix4(li), t.updateWorldMatrix(!1, !1), this.add(t), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Xn), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new jn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ui, t, pi), t }, getWorldScale: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Xn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ui, di, t), t }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Xn), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverse(t) }, traverseVisible: function (t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) }, traverseAncestors: function (t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++)t[e].updateWorldMatrix(!1, !0) } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { i.geometry = r(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; r(t.shapes, i) } else r(t.shapes, n) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, i = this.material.length; n < i; n++)e.push(r(t.materials, this.material[n])); i.material = e } else i.material = r(t.materials, this.material); if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++)i.children.push(this.children[e].toJSON(t).object) } if (e) { const e = o(t.geometries), i = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes); e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a) } return n.object = i, n; function o(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let n = 0; n < t.children.length; n++) { const e = t.children[n]; this.add(e.clone()) } return this } }), _i.prototype = Object.assign(Object.create(xi.prototype), { constructor: _i, isScene: !0, copy: function (t, e) { return xi.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, toJSON: function (t) { const e = xi.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const bi = [new Xn, new Xn, new Xn, new Xn, new Xn, new Xn, new Xn, new Xn], wi = new Xn, Mi = new Ii, Si = new Xn, Ti = new Xn, Ei = new Xn, Ai = new Xn, Li = new Xn, Ri = new Xn, Ci = new Xn, Pi = new Xn, Oi = new Xn, Di = new Xn; function Ii(t, e) { this.min = void 0 !== t ? t : new Xn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Xn(-1 / 0, -1 / 0, -1 / 0) } function Ni(t, e, n, i, r) { for (let o = 0, s = t.length - 3; o <= s; o += 3) { Di.fromArray(t, o); const s = r.x * Math.abs(Di.x) + r.y * Math.abs(Di.y) + r.z * Math.abs(Di.z), a = e.dot(Di), c = n.dot(Di), l = i.dot(Di); if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1 } return !0 } Object.assign(Ii.prototype, { isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.length; a < c; a += 3) { const c = t[a], l = t[a + 1], h = t[a + 2]; c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > o && (o = l), h > s && (s = h) } return this.min.set(e, n, i), this.max.set(r, o, s), this }, setFromBufferAttribute: function (t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.count; a < c; a++) { const c = t.getX(a), l = t.getY(a), h = t.getZ(a); c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > o && (o = l), h > s && (s = h) } return this.min.set(e, n, i), this.max.set(r, o, s), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { const n = wi.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }, setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Xn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Xn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: function (t) { t.updateWorldMatrix(!1, !1); const e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Mi.copy(e.boundingBox), Mi.applyMatrix4(t.matrixWorld), this.union(Mi)); const n = t.children; for (let i = 0, r = n.length; i < r; i++)this.expandByObject(n[i]); return this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Xn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: function (t) { return this.clampPoint(t.center, wi), wi.distanceToSquared(t.center) <= t.radius * t.radius }, intersectsPlane: function (t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }, intersectsTriangle: function (t) { if (this.isEmpty()) return !1; this.getCenter(Ci), Pi.subVectors(this.max, Ci), Si.subVectors(t.a, Ci), Ti.subVectors(t.b, Ci), Ei.subVectors(t.c, Ci), Ai.subVectors(Ti, Si), Li.subVectors(Ei, Ti), Ri.subVectors(Si, Ei); let e = [0, -Ai.z, Ai.y, 0, -Li.z, Li.y, 0, -Ri.z, Ri.y, Ai.z, 0, -Ai.x, Li.z, 0, -Li.x, Ri.z, 0, -Ri.x, -Ai.y, Ai.x, 0, -Li.y, Li.x, 0, -Ri.y, Ri.x, 0]; return !!Ni(e, Si, Ti, Ei, Pi) && (!!Ni(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Si, Ti, Ei, Pi) && (Oi.crossVectors(Ai, Li), Ni(e = [Oi.x, Oi.y, Oi.z], Si, Ti, Ei, Pi))) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Xn), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return wi.copy(t).clamp(this.min, this.max).sub(t).length() }, getBoundingSphere: function (t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(wi).length(), t }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: function (t) { return this.isEmpty() ? this : (bi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), bi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), bi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), bi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), bi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), bi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), bi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), bi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(bi), this) }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); const Bi = new Ii; function Fi(t, e) { this.center = void 0 !== t ? t : new Xn, this.radius = void 0 !== e ? e : -1 } Object.assign(Fi.prototype, { set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: function (t, e) { const n = this.center; void 0 !== e ? n.copy(e) : Bi.setFromPoints(t).getCenter(n); let i = 0; for (let r = 0, o = t.length; r < o; r++)i = Math.max(i, n.distanceToSquared(t[r])); return this.radius = Math.sqrt(i), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, isEmpty: function () { return this.radius < 0 }, makeEmpty: function () { return this.center.set(0, 0, 0), this.radius = -1, this }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (t, e) { const n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Xn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, getBoundingBox: function (t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Ii), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }); const Ui = new Xn, Gi = new Xn, zi = new Xn, Hi = new Xn, ki = new Xn, Vi = new Xn, ji = new Xn; function Wi(t, e) { this.origin = void 0 !== t ? t : new Xn, this.direction = void 0 !== e ? e : new Xn(0, 0, -1) } Object.assign(Wi.prototype, { set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Xn), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: function (t) { return this.origin.copy(this.at(t, Ui)), this }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Xn), e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: function (t) { const e = Ui.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Ui.copy(this.direction).multiplyScalar(e).add(this.origin), Ui.distanceToSquared(t)) }, distanceSqToSegment: function (t, e, n, i) { Gi.copy(t).add(e).multiplyScalar(.5), zi.copy(e).sub(t).normalize(), Hi.copy(this.origin).sub(Gi); const r = .5 * t.distanceTo(e), o = -this.direction.dot(zi), s = Hi.dot(this.direction), a = -Hi.dot(zi), c = Hi.lengthSq(), l = Math.abs(1 - o * o); let h, u, p, d; if (l > 0) if (u = o * s - a, d = r * l, (h = o * a - s) >= 0) if (u >= -d) if (u <= d) { const t = 1 / l; p = (h *= t) * (h + o * (u *= t) + 2 * s) + u * (o * h + u + 2 * a) + c } else u = r, p = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; else u = -r, p = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; else u <= -d ? p = -(h = Math.max(0, -(-o * r + s))) * h + (u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c : u <= d ? (h = 0, p = (u = Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c) : p = -(h = Math.max(0, -(o * r + s))) * h + (u = h > 0 ? r : Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c; else u = o > 0 ? -r : r, p = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(zi).multiplyScalar(u).add(Gi), p }, intersectSphere: function (t, e) { Ui.subVectors(t.center, this.origin); const n = Ui.dot(this.direction), i = Ui.dot(Ui) - n * n, r = t.radius * t.radius; if (i > r) return null; const o = Math.sqrt(r - i), s = n - o, a = n + o; return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e) }, intersectsSphere: function (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, distanceToPlane: function (t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null }, intersectPlane: function (t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) }, intersectsPlane: function (t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { let n, i, r, o, s, a; const c = 1 / this.direction.x, l = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return c >= 0 ? (n = (t.min.x - u.x) * c, i = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c, i = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (s = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e))) }, intersectsBox: function (t) { return null !== this.intersectBox(t, Ui) }, intersectTriangle: function (t, e, n, i, r) { ki.subVectors(e, t), Vi.subVectors(n, t), ji.crossVectors(ki, Vi); let o, s = this.direction.dot(ji); if (s > 0) { if (i) return null; o = 1 } else { if (!(s < 0)) return null; o = -1, s = -s } Hi.subVectors(this.origin, t); const a = o * this.direction.dot(Vi.crossVectors(Hi, Vi)); if (a < 0) return null; const c = o * this.direction.dot(ki.cross(Hi)); if (c < 0) return null; if (a + c > s) return null; const l = -o * Hi.dot(ji); return l < 0 ? null : this.at(l / s, r) }, applyMatrix4: function (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }); const qi = new Xn, Xi = new Xn, Yi = new Bn; function Zi(t, e) { this.normal = void 0 !== t ? t : new Xn(1, 0, 0), this.constant = void 0 !== e ? e : 0 } Object.assign(Zi.prototype, { isPlane: !0, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function (t, e, n) { const i = qi.subVectors(n, e).cross(Xi.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Xn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, intersectLine: function (t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Xn); const n = t.delta(qi), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; const r = -(t.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start) }, intersectsLine: function (t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Xn), t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function (t, e) { const n = e || Yi.getNormalMatrix(t), i = this.coplanarPoint(qi).applyMatrix4(t), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this }, translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }); const Ji = new Xn, Qi = new Xn, Ki = new Xn, $i = new Xn, tr = new Xn, er = new Xn, nr = new Xn, ir = new Xn, rr = new Xn, or = new Xn; function sr(t, e, n) { this.a = void 0 !== t ? t : new Xn, this.b = void 0 !== e ? e : new Xn, this.c = void 0 !== n ? n : new Xn } Object.assign(sr, { getNormal: function (t, e, n, i) { void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Xn), i.subVectors(n, e), Ji.subVectors(t, e), i.cross(Ji); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) }, getBarycoord: function (t, e, n, i, r) { Ji.subVectors(i, e), Qi.subVectors(n, e), Ki.subVectors(t, e); const o = Ji.dot(Ji), s = Ji.dot(Qi), a = Ji.dot(Ki), c = Qi.dot(Qi), l = Qi.dot(Ki), h = o * c - s * s; if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Xn), 0 === h) return r.set(-2, -1, -1); const u = 1 / h, p = (c * a - s * l) * u, d = (o * l - s * a) * u; return r.set(1 - p - d, d, p) }, containsPoint: function (t, e, n, i) { return sr.getBarycoord(t, e, n, i, $i), $i.x >= 0 && $i.y >= 0 && $i.x + $i.y <= 1 }, getUV: function (t, e, n, i, r, o, s, a) { return this.getBarycoord(t, e, n, i, $i), a.set(0, 0), a.addScaledVector(r, $i.x), a.addScaledVector(o, $i.y), a.addScaledVector(s, $i.z), a }, isFrontFacing: function (t, e, n, i) { return Ji.subVectors(n, e), Qi.subVectors(t, e), Ji.cross(Qi).dot(i) < 0 } }), Object.assign(sr.prototype, { set: function (t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }, setFromPointsAndIndices: function (t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, getArea: function () { return Ji.subVectors(this.c, this.b), Qi.subVectors(this.a, this.b), .5 * Ji.cross(Qi).length() }, getMidpoint: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Xn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (t) { return sr.getNormal(this.a, this.b, this.c, t) }, getPlane: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Zi), t.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (t, e) { return sr.getBarycoord(t, this.a, this.b, this.c, e) }, getUV: function (t, e, n, i, r) { return sr.getUV(t, this.a, this.b, this.c, e, n, i, r) }, containsPoint: function (t) { return sr.containsPoint(t, this.a, this.b, this.c) }, isFrontFacing: function (t) { return sr.isFrontFacing(this.a, this.b, this.c, t) }, intersectsBox: function (t) { return t.intersectsTriangle(this) }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Xn); const n = this.a, i = this.b, r = this.c; let o, s; tr.subVectors(i, n), er.subVectors(r, n), ir.subVectors(t, n); const a = tr.dot(ir), c = er.dot(ir); if (a <= 0 && c <= 0) return e.copy(n); rr.subVectors(t, i); const l = tr.dot(rr), h = er.dot(rr); if (l >= 0 && h <= l) return e.copy(i); const u = a * h - l * c; if (u <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(tr, o); or.subVectors(t, r); const p = tr.dot(or), d = er.dot(or); if (d >= 0 && p <= d) return e.copy(r); const f = p * c - a * d; if (f <= 0 && c >= 0 && d <= 0) return s = c / (c - d), e.copy(n).addScaledVector(er, s); const m = l * d - p * h; if (m <= 0 && h - l >= 0 && p - d >= 0) return nr.subVectors(r, i), s = (h - l) / (h - l + (p - d)), e.copy(i).addScaledVector(nr, s); const g = 1 / (m + f + u); return o = f * g, s = u * g, e.copy(n).addScaledVector(tr, o).addScaledVector(er, s) }, equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }); const ar = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, cr = { h: 0, s: 0, l: 0 }, lr = { h: 0, s: 0, l: 0 }; function hr(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } function ur(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function pr(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function dr(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } function fr(t, e, n, i, r, o) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Xn, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new hr, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0 } Object.assign(hr.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { return this.r = t, this.g = t, this.b = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, n) { return this.r = t, this.g = e, this.b = n, this }, setHSL: function (t, e, n) { if (t = In.euclideanModulo(t, 1), e = In.clamp(e, 0, 1), n = In.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + e) : n + e - n * e, r = 2 * n - i; this.r = ur(r, i, t + 1 / 3), this.g = ur(r, i, t), this.b = ur(r, i, t - 1 / 3) } return this }, setStyle: function (t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { let t; const i = n[1], r = n[2]; switch (i) { case "rgb": case "rgba": if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this; if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this; break; case "hsl": case "hsla": if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) { const n = parseFloat(t[1]) / 360, i = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100; return e(t[5]), this.setHSL(n, i, r) } } } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) { const t = n[1], e = t.length; if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this }, setColorName: function (t) { const e = ar[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }, convertGammaToLinear: function (t) { return this.copyGammaToLinear(this, t), this }, convertLinearToGamma: function (t) { return this.copyLinearToGamma(this, t), this }, copySRGBToLinear: function (t) { return this.r = pr(t.r), this.g = pr(t.g), this.b = pr(t.b), this }, copyLinearToSRGB: function (t) { return this.r = dr(t.r), this.g = dr(t.g), this.b = dr(t.b), this }, convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); const e = this.r, n = this.g, i = this.b, r = Math.max(e, n, i), o = Math.min(e, n, i); let s, a; const c = (o + r) / 2; if (o === r) s = 0, a = 0; else { const t = r - o; switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o), r) { case e: s = (n - i) / t + (n < i ? 6 : 0); break; case n: s = (i - e) / t + 2; break; case i: s = (e - n) / t + 4 }s /= 6 } return t.h = s, t.s = a, t.l = c, t }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (t, e, n) { return this.getHSL(cr), cr.h += t, cr.s += e, cr.l += n, this.setHSL(cr.h, cr.s, cr.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, lerpHSL: function (t, e) { this.getHSL(cr), t.getHSL(lr); const n = In.lerp(cr.h, lr.h, e), i = In.lerp(cr.s, lr.s, e), r = In.lerp(cr.l, lr.l, e); return this.setHSL(n, i, r), this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, fromBufferAttribute: function (t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }, toJSON: function () { return this.getHex() } }), hr.NAMES = ar, Object.assign(fr.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }); let mr = 0; function gr() { Object.defineProperty(this, "id", { value: mr++ }), this.uuid = In.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = v, this.side = u, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = P, this.blendDst = O, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = H, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = bn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = an, this.stencilZFail = an, this.stencilZPass = an, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function vr(t) { gr.call(this), this.type = "MeshBasicMaterial", this.color = new hr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) } gr.prototype = Object.assign(Object.create(Pn.prototype), { constructor: gr, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const i = this[e]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== u && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) { const e = i(t.textures), r = i(t.images); e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r) } return n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let i = 0; i !== t; ++i)n[i] = e[i].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(gr.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), vr.prototype = Object.create(gr.prototype), vr.prototype.constructor = vr, vr.prototype.isMeshBasicMaterial = !0, vr.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }; const yr = new Xn, xr = new Nn; function _r(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = wn, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function br(t, e, n) { _r.call(this, new Int8Array(t), e, n) } function wr(t, e, n) { _r.call(this, new Uint8Array(t), e, n) } function Mr(t, e, n) { _r.call(this, new Uint8ClampedArray(t), e, n) } function Sr(t, e, n) { _r.call(this, new Int16Array(t), e, n) } function Tr(t, e, n) { _r.call(this, new Uint16Array(t), e, n) } function Er(t, e, n) { _r.call(this, new Int32Array(t), e, n) } function Ar(t, e, n) { _r.call(this, new Uint32Array(t), e, n) } function Lr(t, e, n) { _r.call(this, new Float32Array(t), e, n) } function Rr(t, e, n) { _r.call(this, new Float64Array(t), e, n) } function Cr() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function Pr(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n)t[n] > e && (e = t[n]); return e } Object.defineProperty(_r.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(_r.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new hr), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b } return this }, copyVector2sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Nn), e[n++] = r.x, e[n++] = r.y } return this }, copyVector3sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Xn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z } return this }, copyVector4sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Hn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w } return this }, applyMatrix3: function (t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)xr.fromBufferAttribute(this, e), xr.applyMatrix3(t), this.setXY(e, xr.x, xr.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)yr.fromBufferAttribute(this, e), yr.applyMatrix3(t), this.setXYZ(e, yr.x, yr.y, yr.z); return this }, applyMatrix4: function (t) { for (let e = 0, n = this.count; e < n; e++)yr.x = this.getX(e), yr.y = this.getY(e), yr.z = this.getZ(e), yr.applyMatrix4(t), this.setXYZ(e, yr.x, yr.y, yr.z); return this }, applyNormalMatrix: function (t) { for (let e = 0, n = this.count; e < n; e++)yr.x = this.getX(e), yr.y = this.getY(e), yr.z = this.getZ(e), yr.applyNormalMatrix(t), this.setXYZ(e, yr.x, yr.y, yr.z); return this }, transformDirection: function (t) { for (let e = 0, n = this.count; e < n; e++)yr.x = this.getX(e), yr.y = this.getY(e), yr.z = this.getZ(e), yr.transformDirection(t), this.setXYZ(e, yr.x, yr.y, yr.z); return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), br.prototype = Object.create(_r.prototype), br.prototype.constructor = br, wr.prototype = Object.create(_r.prototype), wr.prototype.constructor = wr, Mr.prototype = Object.create(_r.prototype), Mr.prototype.constructor = Mr, Sr.prototype = Object.create(_r.prototype), Sr.prototype.constructor = Sr, Tr.prototype = Object.create(_r.prototype), Tr.prototype.constructor = Tr, Er.prototype = Object.create(_r.prototype), Er.prototype.constructor = Er, Ar.prototype = Object.create(_r.prototype), Ar.prototype.constructor = Ar, Lr.prototype = Object.create(_r.prototype), Lr.prototype.constructor = Lr, Rr.prototype = Object.create(_r.prototype), Rr.prototype.constructor = Rr, Object.assign(Cr.prototype, { computeGroups: function (t) { const e = []; let n, i, r = void 0; const o = t.faces; for (i = 0; i < o.length; i++) { const t = o[i]; t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = { start: 3 * i, materialIndex: r }) } void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e }, fromGeometry: function (t) { const e = t.faces, n = t.vertices, i = t.faceVertexUvs, r = i[0] && i[0].length > 0, o = i[1] && i[1].length > 0, s = t.morphTargets, a = s.length; let c; if (a > 0) { c = []; for (let t = 0; t < a; t++)c[t] = { name: s[t].name, data: [] }; this.morphTargets.position = c } const l = t.morphNormals, h = l.length; let u; if (h > 0) { u = []; for (let t = 0; t < h; t++)u[t] = { name: l[t].name, data: [] }; this.morphTargets.normal = u } const p = t.skinIndices, d = t.skinWeights, f = p.length === n.length, m = d.length === n.length; n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (let g = 0; g < e.length; g++) { const t = e[g]; this.vertices.push(n[t.a], n[t.b], n[t.c]); const v = t.vertexNormals; if (3 === v.length) this.normals.push(v[0], v[1], v[2]); else { const e = t.normal; this.normals.push(e, e, e) } const y = t.vertexColors; if (3 === y.length) this.colors.push(y[0], y[1], y[2]); else { const e = t.color; this.colors.push(e, e, e) } if (!0 === r) { const t = i[0][g]; void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new Nn, new Nn, new Nn)) } if (!0 === o) { const t = i[1][g]; void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new Nn, new Nn, new Nn)) } for (let e = 0; e < a; e++) { const n = s[e].vertices; c[e].data.push(n[t.a], n[t.b], n[t.c]) } for (let e = 0; e < h; e++) { const t = l[e].vertexNormals[g]; u[e].data.push(t.a, t.b, t.c) } f && this.skinIndices.push(p[t.a], p[t.b], p[t.c]), m && this.skinWeights.push(d[t.a], d[t.b], d[t.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this } }); let Or = 1; const Dr = new ei, Ir = new xi, Nr = new Xn, Br = new Ii, Fr = new Ii, Ur = new Xn; function Gr() { Object.defineProperty(this, "id", { value: Or += 2 }), this.uuid = In.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } Gr.prototype = Object.assign(Object.create(Pn.prototype), { constructor: Gr, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (Pr(t) > 65535 ? Ar : Tr)(t, 1) : this.index = t }, getAttribute: function (t) { return this.attributes[t] }, setAttribute: function (t, e) { return this.attributes[t] = e, this }, deleteAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, n) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix4: function (t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new Bn).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (t) { return Dr.makeRotationX(t), this.applyMatrix4(Dr), this }, rotateY: function (t) { return Dr.makeRotationY(t), this.applyMatrix4(Dr), this }, rotateZ: function (t) { return Dr.makeRotationZ(t), this.applyMatrix4(Dr), this }, translate: function (t, e, n) { return Dr.makeTranslation(t, e, n), this.applyMatrix4(Dr), this }, scale: function (t, e, n) { return Dr.makeScale(t, e, n), this.applyMatrix4(Dr), this }, lookAt: function (t) { return Ir.lookAt(t), Ir.updateMatrix(), this.applyMatrix4(Ir.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Nr).negate(), this.translate(Nr.x, Nr.y, Nr.z), this }, setFromObject: function (t) { const e = t.geometry; if (t.isPoints || t.isLine) { const t = new Lr(3 * e.vertices.length, 3), n = new Lr(3 * e.colors.length, 3); if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) { const t = new Lr(e.lineDistances.length, 1); this.setAttribute("lineDistance", t.copyArray(e.lineDistances)) } null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, setFromPoints: function (t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new Lr(e, 3)), this }, updateFromObject: function (t) { let e = t.geometry; if (t.isMesh) { let t = e.__directGeometry; if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e); t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t } if (!0 === e.verticesNeedUpdate) { const t = this.attributes.position; void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1 } if (!0 === e.normalsNeedUpdate) { const t = this.attributes.normal; void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1 } if (!0 === e.colorsNeedUpdate) { const t = this.attributes.color; void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1 } if (e.uvsNeedUpdate) { const t = this.attributes.uv; void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1 } if (e.lineDistancesNeedUpdate) { const t = this.attributes.lineDistance; void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1 } return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Cr).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { const e = new Float32Array(3 * t.vertices.length); if (this.setAttribute("position", new _r(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) { const e = new Float32Array(3 * t.normals.length); this.setAttribute("normal", new _r(e, 3).copyVector3sArray(t.normals)) } if (t.colors.length > 0) { const e = new Float32Array(3 * t.colors.length); this.setAttribute("color", new _r(e, 3).copyColorsArray(t.colors)) } if (t.uvs.length > 0) { const e = new Float32Array(2 * t.uvs.length); this.setAttribute("uv", new _r(e, 2).copyVector2sArray(t.uvs)) } if (t.uvs2.length > 0) { const e = new Float32Array(2 * t.uvs2.length); this.setAttribute("uv2", new _r(e, 2).copyVector2sArray(t.uvs2)) } this.groups = t.groups; for (const n in t.morphTargets) { const e = [], i = t.morphTargets[n]; for (let t = 0, n = i.length; t < n; t++) { const n = i[t], r = new Lr(3 * n.data.length, 3); r.name = n.name, e.push(r.copyVector3sArray(n.data)) } this.morphAttributes[n] = e } if (t.skinIndices.length > 0) { const e = new Lr(4 * t.skinIndices.length, 4); this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices)) } if (t.skinWeights.length > 0) { const e = new Lr(4 * t.skinWeights.length, 4); this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights)) } return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Ii); const t = this.attributes.position, e = this.morphAttributes.position; if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, i = e.length; n < i; n++) { const t = e[n]; Br.setFromBufferAttribute(t), this.morphTargetsRelative ? (Ur.addVectors(this.boundingBox.min, Br.min), this.boundingBox.expandByPoint(Ur), Ur.addVectors(this.boundingBox.max, Br.max), this.boundingBox.expandByPoint(Ur)) : (this.boundingBox.expandByPoint(Br.min), this.boundingBox.expandByPoint(Br.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Fi); const t = this.attributes.position, e = this.morphAttributes.position; if (t) { const n = this.boundingSphere.center; if (Br.setFromBufferAttribute(t), e) for (let t = 0, r = e.length; t < r; t++) { const n = e[t]; Fr.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ur.addVectors(Br.min, Fr.min), Br.expandByPoint(Ur), Ur.addVectors(Br.max, Fr.max), Br.expandByPoint(Ur)) : (Br.expandByPoint(Fr.min), Br.expandByPoint(Fr.max)) } Br.getCenter(n); let i = 0; for (let e = 0, r = t.count; e < r; e++)Ur.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Ur)); if (e) for (let r = 0, o = e.length; r < o; r++) { const o = e[r], s = this.morphTargetsRelative; for (let e = 0, r = o.count; e < r; e++)Ur.fromBufferAttribute(o, e), s && (Nr.fromBufferAttribute(t, e), Ur.add(Nr)), i = Math.max(i, n.distanceToSquared(Ur)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeVertexNormals: function () { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new _r(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const i = new Xn, r = new Xn, o = new Xn, s = new Xn, a = new Xn, c = new Xn, l = new Xn, h = new Xn; if (t) for (let u = 0, p = t.count; u < p; u += 3) { const p = t.getX(u + 0), d = t.getX(u + 1), f = t.getX(u + 2); i.fromBufferAttribute(e, p), r.fromBufferAttribute(e, d), o.fromBufferAttribute(e, f), l.subVectors(o, r), h.subVectors(i, r), l.cross(h), s.fromBufferAttribute(n, p), a.fromBufferAttribute(n, d), c.fromBufferAttribute(n, f), s.add(l), a.add(l), c.add(l), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(f, c.x, c.y, c.z) } else for (let t = 0, u = e.count; t < u; t += 3)i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, r), h.subVectors(i, r), l.cross(h), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z); this.normalizeNormals(), n.needsUpdate = !0 } }, merge: function (t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const i in n) { if (void 0 === t.attributes[i]) continue; const r = n[i].array, o = t.attributes[i], s = o.array, a = o.itemSize * e, c = Math.min(s.length, r.length - a); for (let t = 0, e = a; t < c; t++, e++)r[e] = s[t] } return this }, normalizeNormals: function () { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)Ur.fromBufferAttribute(t, e), Ur.normalize(), t.setXYZ(e, Ur.x, Ur.y, Ur.z) }, toNonIndexed: function () { function t(t, e) { const n = t.array, i = t.itemSize, r = t.normalized, o = new n.constructor(e.length * i); let s = 0, a = 0; for (let c = 0, l = e.length; c < l; c++) { s = e[c] * i; for (let t = 0; t < i; t++)o[a++] = n[s++] } return new _r(o, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; const e = new Gr, n = this.index.array, i = this.attributes; for (const s in i) { const r = t(i[s], n); e.setAttribute(s, r) } const r = this.morphAttributes; for (const s in r) { const i = [], o = r[s]; for (let e = 0, r = o.length; e < r; e++) { const r = t(o[e], n); i.push(r) } e.morphAttributes[s] = i } e.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let s = 0, a = o.length; s < a; s++) { const t = o[s]; e.addGroup(t.start, t.count, t.materialIndex) } return e }, toJSON: function () { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const a in n) { const e = n[a], i = e.toJSON(t.data); "" !== e.name && (i.name = e.name), t.data.attributes[a] = i } const i = {}; let r = !1; for (const a in this.morphAttributes) { const e = this.morphAttributes[a], n = []; for (let i = 0, r = e.length; i < r; i++) { const r = e[i], o = r.toJSON(t.data); "" !== r.name && (o.name = r.name), n.push(o) } n.length > 0 && (i[a] = n, r = !0) } r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o))); const s = this.boundingSphere; return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t }, clone: function () { return (new Gr).copy(this) }, copy: function (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const i = t.attributes; for (const c in i) { const t = i[c]; this.setAttribute(c, t.clone(e)) } const r = t.morphAttributes; for (const c in r) { const t = [], n = r[c]; for (let i = 0, r = n.length; i < r; i++)t.push(n[i].clone(e)); this.morphAttributes[c] = t } this.morphTargetsRelative = t.morphTargetsRelative; const o = t.groups; for (let c = 0, l = o.length; c < l; c++) { const t = o[c]; this.addGroup(t.start, t.count, t.materialIndex) } const s = t.boundingBox; null !== s && (this.boundingBox = s.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const zr = new ei, Hr = new Wi, kr = new Fi, Vr = new Xn, jr = new Xn, Wr = new Xn, qr = new Xn, Xr = new Xn, Yr = new Xn, Zr = new Xn, Jr = new Xn, Qr = new Xn, Kr = new Nn, $r = new Nn, to = new Nn, eo = new Xn, no = new Xn; function io(t, e) { xi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new vr, this.updateMorphTargets() } function ro(t, e, n, i, r, o, s, a) { let c; if (null === (c = e.side === p ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, e.side !== d, a))) return null; no.copy(a), no.applyMatrix4(t.matrixWorld); const l = n.ray.origin.distanceTo(no); return l < n.near || l > n.far ? null : { distance: l, point: no.clone(), object: t } } function oo(t, e, n, i, r, o, s, a, c, l, h, u) { Vr.fromBufferAttribute(r, l), jr.fromBufferAttribute(r, h), Wr.fromBufferAttribute(r, u); const p = t.morphTargetInfluences; if (e.morphTargets && o && p) { Zr.set(0, 0, 0), Jr.set(0, 0, 0), Qr.set(0, 0, 0); for (let t = 0, e = o.length; t < e; t++) { const e = p[t], n = o[t]; 0 !== e && (qr.fromBufferAttribute(n, l), Xr.fromBufferAttribute(n, h), Yr.fromBufferAttribute(n, u), s ? (Zr.addScaledVector(qr, e), Jr.addScaledVector(Xr, e), Qr.addScaledVector(Yr, e)) : (Zr.addScaledVector(qr.sub(Vr), e), Jr.addScaledVector(Xr.sub(jr), e), Qr.addScaledVector(Yr.sub(Wr), e))) } Vr.add(Zr), jr.add(Jr), Wr.add(Qr) } t.isSkinnedMesh && (t.boneTransform(l, Vr), t.boneTransform(h, jr), t.boneTransform(u, Wr)); const d = ro(t, e, n, i, Vr, jr, Wr, eo); if (d) { a && (Kr.fromBufferAttribute(a, l), $r.fromBufferAttribute(a, h), to.fromBufferAttribute(a, u), d.uv = sr.getUV(eo, Vr, jr, Wr, Kr, $r, to, new Nn)), c && (Kr.fromBufferAttribute(c, l), $r.fromBufferAttribute(c, h), to.fromBufferAttribute(c, u), d.uv2 = sr.getUV(eo, Vr, jr, Wr, Kr, $r, to, new Nn)); const t = new fr(l, h, u); sr.getNormal(Vr, jr, Wr, t.normal), d.face = t } return d } io.prototype = Object.assign(Object.create(xi.prototype), { constructor: io, isMesh: !0, copy: function (t) { return xi.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (t, e) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), kr.copy(n.boundingSphere), kr.applyMatrix4(r), !1 === t.ray.intersectsSphere(kr)) return; if (zr.getInverse(r), Hr.copy(t.ray).applyMatrix4(zr), null !== n.boundingBox && !1 === Hr.intersectsBox(n.boundingBox)) return; let o; if (n.isBufferGeometry) { const r = n.index, s = n.attributes.position, a = n.morphAttributes.position, c = n.morphTargetsRelative, l = n.attributes.uv, h = n.attributes.uv2, u = n.groups, p = n.drawRange; if (null !== r) if (Array.isArray(i)) for (let n = 0, d = u.length; n < d; n++) { const d = u[n], f = i[d.materialIndex]; for (let n = Math.max(d.start, p.start), i = Math.min(d.start + d.count, p.start + p.count); n < i; n += 3) { const i = r.getX(n), u = r.getX(n + 1), p = r.getX(n + 2); (o = oo(this, f, t, Hr, s, a, c, l, h, i, u, p)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = d.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, p.start), u = Math.min(r.count, p.start + p.count); n < u; n += 3) { const u = r.getX(n), p = r.getX(n + 1), d = r.getX(n + 2); (o = oo(this, i, t, Hr, s, a, c, l, h, u, p, d)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } else if (void 0 !== s) if (Array.isArray(i)) for (let n = 0, d = u.length; n < d; n++) { const r = u[n], d = i[r.materialIndex]; for (let n = Math.max(r.start, p.start), i = Math.min(r.start + r.count, p.start + p.count); n < i; n += 3) { (o = oo(this, d, t, Hr, s, a, c, l, h, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, p.start), r = Math.min(s.count, p.start + p.count); n < r; n += 3) { (o = oo(this, i, t, Hr, s, a, c, l, h, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } } else if (n.isGeometry) { const r = Array.isArray(i), s = n.vertices, a = n.faces; let c; const l = n.faceVertexUvs[0]; l.length > 0 && (c = l); for (let n = 0, h = a.length; n < h; n++) { const l = a[n], h = r ? i[l.materialIndex] : i; if (void 0 === h) continue; const u = s[l.a], p = s[l.b], d = s[l.c]; if (o = ro(this, h, t, Hr, u, p, d, eo)) { if (c && c[n]) { const t = c[n]; Kr.copy(t[0]), $r.copy(t[1]), to.copy(t[2]), o.uv = sr.getUV(eo, u, p, d, Kr, $r, to, new Nn) } o.face = l, o.faceIndex = n, e.push(o) } } } } }); let so = 0; const ao = new ei, co = new xi, lo = new Xn; function ho() { Object.defineProperty(this, "id", { value: so += 2 }), this.uuid = In.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } ho.prototype = Object.assign(Object.create(Pn.prototype), { constructor: ho, isGeometry: !0, applyMatrix4: function (t) { const e = (new Bn).getNormalMatrix(t); for (let n = 0, i = this.vertices.length; n < i; n++) { this.vertices[n].applyMatrix4(t) } for (let n = 0, i = this.faces.length; n < i; n++) { const t = this.faces[n]; t.normal.applyMatrix3(e).normalize(); for (let n = 0, i = t.vertexNormals.length; n < i; n++)t.vertexNormals[n].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function (t) { return ao.makeRotationX(t), this.applyMatrix4(ao), this }, rotateY: function (t) { return ao.makeRotationY(t), this.applyMatrix4(ao), this }, rotateZ: function (t) { return ao.makeRotationZ(t), this.applyMatrix4(ao), this }, translate: function (t, e, n) { return ao.makeTranslation(t, e, n), this.applyMatrix4(ao), this }, scale: function (t, e, n) { return ao.makeScale(t, e, n), this.applyMatrix4(ao), this }, lookAt: function (t) { return co.lookAt(t), co.updateMatrix(), this.applyMatrix4(co.matrix), this }, fromBufferGeometry: function (t) { const e = this, n = null !== t.index ? t.index : void 0, i = t.attributes; if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; const r = i.position, o = i.normal, s = i.color, a = i.uv, c = i.uv2; void 0 !== c && (this.faceVertexUvs[1] = []); for (let u = 0; u < r.count; u++)e.vertices.push((new Xn).fromBufferAttribute(r, u)), void 0 !== s && e.colors.push((new hr).fromBufferAttribute(s, u)); function l(t, n, i, r) { const l = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()], h = new fr(t, n, i, void 0 === o ? [] : [(new Xn).fromBufferAttribute(o, t), (new Xn).fromBufferAttribute(o, n), (new Xn).fromBufferAttribute(o, i)], l, r); e.faces.push(h), void 0 !== a && e.faceVertexUvs[0].push([(new Nn).fromBufferAttribute(a, t), (new Nn).fromBufferAttribute(a, n), (new Nn).fromBufferAttribute(a, i)]), void 0 !== c && e.faceVertexUvs[1].push([(new Nn).fromBufferAttribute(c, t), (new Nn).fromBufferAttribute(c, n), (new Nn).fromBufferAttribute(c, i)]) } const h = t.groups; if (h.length > 0) for (let u = 0; u < h.length; u++) { const t = h[u], e = t.start; for (let i = e, r = e + t.count; i < r; i += 3)void 0 !== n ? l(n.getX(i), n.getX(i + 1), n.getX(i + 2), t.materialIndex) : l(i, i + 1, i + 2, t.materialIndex) } else if (void 0 !== n) for (let u = 0; u < n.count; u += 3)l(n.getX(u), n.getX(u + 1), n.getX(u + 2)); else for (let u = 0; u < r.count; u += 3)l(u, u + 1, u + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(lo).negate(), this.translate(lo.x, lo.y, lo.z), this }, normalize: function () { this.computeBoundingSphere(); const t = this.boundingSphere.center, e = this.boundingSphere.radius, n = 0 === e ? 1 : 1 / e, i = new ei; return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this }, computeFaceNormals: function () { const t = new Xn, e = new Xn; for (let n = 0, i = this.faces.length; n < i; n++) { const i = this.faces[n], r = this.vertices[i.a], o = this.vertices[i.b], s = this.vertices[i.c]; t.subVectors(s, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t) } }, computeVertexNormals: function (t) { void 0 === t && (t = !0); const e = new Array(this.vertices.length); for (let n = 0, i = this.vertices.length; n < i; n++)e[n] = new Xn; if (t) { const t = new Xn, n = new Xn; for (let i = 0, r = this.faces.length; i < r; i++) { const r = this.faces[i], o = this.vertices[r.a], s = this.vertices[r.b], a = this.vertices[r.c]; t.subVectors(a, s), n.subVectors(o, s), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t) } } else { this.computeFaceNormals(); for (let t = 0, n = this.faces.length; t < n; t++) { const n = this.faces[t]; e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal) } } for (let n = 0, i = this.vertices.length; n < i; n++)e[n].normalize(); for (let n = 0, i = this.faces.length; n < i; n++) { const t = this.faces[n], i = t.vertexNormals; 3 === i.length ? (i[0].copy(e[t.a]), i[1].copy(e[t.b]), i[2].copy(e[t.c])) : (i[0] = e[t.a].clone(), i[1] = e[t.b].clone(), i[2] = e[t.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { this.computeFaceNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], n = e.vertexNormals; 3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { for (let e = 0, n = this.faces.length; e < n; e++) { const t = this.faces[e]; t.__originalFaceNormal ? t.__originalFaceNormal.copy(t.normal) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || (t.__originalVertexNormals = []); for (let e = 0, n = t.vertexNormals.length; e < n; e++)t.__originalVertexNormals[e] ? t.__originalVertexNormals[e].copy(t.vertexNormals[e]) : t.__originalVertexNormals[e] = t.vertexNormals[e].clone() } const t = new ho; t.faces = this.faces; for (let e = 0, n = this.morphTargets.length; e < n; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; const t = this.morphNormals[e].faceNormals, n = this.morphNormals[e].vertexNormals; for (let e = 0, i = this.faces.length; e < i; e++) { const e = new Xn, i = { a: new Xn, b: new Xn, c: new Xn }; t.push(e), n.push(i) } } const n = this.morphNormals[e]; t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], i = n.faceNormals[t], r = n.vertexNormals[t]; i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2]) } } for (let e = 0, n = this.faces.length; e < n; e++) { const t = this.faces[e]; t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals } }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Ii), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Fi), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, n) { if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t); let i, r = this.vertices.length, o = this.vertices, s = t.vertices, a = this.faces, c = t.faces, l = this.colors, h = t.colors; void 0 === n && (n = 0), void 0 !== e && (i = (new Bn).getNormalMatrix(e)); for (let u = 0, p = s.length; u < p; u++) { const t = s[u].clone(); void 0 !== e && t.applyMatrix4(e), o.push(t) } for (let u = 0, p = h.length; u < p; u++)l.push(h[u].clone()); for (let u = 0, p = c.length; u < p; u++) { let t, e, o, s = c[u], l = s.vertexNormals, h = s.vertexColors; (t = new fr(s.a + r, s.b + r, s.c + r)).normal.copy(s.normal), void 0 !== i && t.normal.applyMatrix3(i).normalize(); for (let n = 0, r = l.length; n < r; n++)e = l[n].clone(), void 0 !== i && e.applyMatrix3(i).normalize(), t.vertexNormals.push(e); t.color.copy(s.color); for (let n = 0, i = h.length; n < i; n++)o = h[n], t.vertexColors.push(o.clone()); t.materialIndex = s.materialIndex + n, a.push(t) } for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) { const e = t.faceVertexUvs[u]; void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []); for (let t = 0, n = e.length; t < n; t++) { const n = e[t], i = []; for (let t = 0, e = n.length; t < e; t++)i.push(n[t].clone()); this.faceVertexUvs[u].push(i) } } }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { const t = {}, e = [], n = [], i = Math.pow(10, 4); for (let s = 0, a = this.vertices.length; s < a; s++) { const r = this.vertices[s], o = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i); void 0 === t[o] ? (t[o] = s, e.push(this.vertices[s]), n[s] = e.length - 1) : n[s] = n[t[o]] } const r = []; for (let s = 0, a = this.faces.length; s < a; s++) { const t = this.faces[s]; t.a = n[t.a], t.b = n[t.b], t.c = n[t.c]; const e = [t.a, t.b, t.c]; for (let n = 0; n < 3; n++)if (e[n] === e[(n + 1) % 3]) { r.push(s); break } } for (let s = r.length - 1; s >= 0; s--) { const t = r[s]; this.faces.splice(t, 1); for (let e = 0, n = this.faceVertexUvs.length; e < n; e++)this.faceVertexUvs[e].splice(t, 1) } const o = this.vertices.length - e.length; return this.vertices = e, o }, setFromPoints: function (t) { this.vertices = []; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; this.vertices.push(new Xn(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function () { const t = this.faces, e = t.length; for (let s = 0; s < e; s++)t[s]._id = s; t.sort(function (t, e) { return t.materialIndex - e.materialIndex }); const n = this.faceVertexUvs[0], i = this.faceVertexUvs[1]; let r, o; n && n.length === e && (r = []), i && i.length === e && (o = []); for (let s = 0; s < e; s++) { const e = t[s]._id; r && r.push(n[e]), o && o.push(i[e]) } r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o) }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } const e = []; for (let d = 0; d < this.vertices.length; d++) { const t = this.vertices[d]; e.push(t.x, t.y, t.z) } const n = [], i = [], r = {}, o = [], s = {}, a = [], c = {}; for (let d = 0; d < this.faces.length; d++) { const t = this.faces[d], e = !0, i = !1, r = void 0 !== this.faceVertexUvs[0][d], o = t.normal.length() > 0, s = t.vertexNormals.length > 0, a = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b, c = t.vertexColors.length > 0; let f = 0; if (f = l(f, 0, 0), f = l(f, 1, e), f = l(f, 2, i), f = l(f, 3, r), f = l(f, 4, o), f = l(f, 5, s), f = l(f, 6, a), f = l(f, 7, c), n.push(f), n.push(t.a, t.b, t.c), n.push(t.materialIndex), r) { const t = this.faceVertexUvs[0][d]; n.push(p(t[0]), p(t[1]), p(t[2])) } if (o && n.push(h(t.normal)), s) { const e = t.vertexNormals; n.push(h(e[0]), h(e[1]), h(e[2])) } if (a && n.push(u(t.color)), c) { const e = t.vertexColors; n.push(u(e[0]), u(e[1]), u(e[2])) } } function l(t, e, n) { return n ? t | 1 << e : t & ~(1 << e) } function h(t) { const e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== r[e] ? r[e] : (r[e] = i.length / 3, i.push(t.x, t.y, t.z), r[e]) } function u(t) { const e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== s[e] ? s[e] : (s[e] = o.length, o.push(t.getHex()), s[e]) } function p(t) { const e = t.x.toString() + t.y.toString(); return void 0 !== c[e] ? c[e] : (c[e] = a.length / 2, a.push(t.x, t.y), c[e]) } return t.data = {}, t.data.vertices = e, t.data.normals = i, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t }, clone: function () { return (new ho).copy(this) }, copy: function (t) { this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; const e = t.vertices; for (let u = 0, p = e.length; u < p; u++)this.vertices.push(e[u].clone()); const n = t.colors; for (let u = 0, p = n.length; u < p; u++)this.colors.push(n[u].clone()); const i = t.faces; for (let u = 0, p = i.length; u < p; u++)this.faces.push(i[u].clone()); for (let u = 0, p = t.faceVertexUvs.length; u < p; u++) { const e = t.faceVertexUvs[u]; void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []); for (let t = 0, n = e.length; t < n; t++) { const n = e[t], i = []; for (let t = 0, e = n.length; t < e; t++) { const e = n[t]; i.push(e.clone()) } this.faceVertexUvs[u].push(i) } } const r = t.morphTargets; for (let u = 0, p = r.length; u < p; u++) { const t = {}; if (t.name = r[u].name, void 0 !== r[u].vertices) { t.vertices = []; for (let e = 0, n = r[u].vertices.length; e < n; e++)t.vertices.push(r[u].vertices[e].clone()) } if (void 0 !== r[u].normals) { t.normals = []; for (let e = 0, n = r[u].normals.length; e < n; e++)t.normals.push(r[u].normals[e].clone()) } this.morphTargets.push(t) } const o = t.morphNormals; for (let u = 0, p = o.length; u < p; u++) { const t = {}; if (void 0 !== o[u].vertexNormals) { t.vertexNormals = []; for (let e = 0, n = o[u].vertexNormals.length; e < n; e++) { const n = o[u].vertexNormals[e], i = {}; i.a = n.a.clone(), i.b = n.b.clone(), i.c = n.c.clone(), t.vertexNormals.push(i) } } if (void 0 !== o[u].faceNormals) { t.faceNormals = []; for (let e = 0, n = o[u].faceNormals.length; e < n; e++)t.faceNormals.push(o[u].faceNormals[e].clone()) } this.morphNormals.push(t) } const s = t.skinWeights; for (let u = 0, p = s.length; u < p; u++)this.skinWeights.push(s[u].clone()); const a = t.skinIndices; for (let u = 0, p = a.length; u < p; u++)this.skinIndices.push(a[u].clone()); const c = t.lineDistances; for (let u = 0, p = c.length; u < p; u++)this.lineDistances.push(c[u]); const l = t.boundingBox; null !== l && (this.boundingBox = l.clone()); const h = t.boundingSphere; return null !== h && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); class uo extends ho { constructor(t, e, n, i, r, o) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }, this.fromBufferGeometry(new po(t, e, n, i, r, o)), this.mergeVertices() } } exports.CubeGeometry = exports.BoxGeometry = uo; class po extends Gr { constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) { super(), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }; const s = this; i = Math.floor(i), r = Math.floor(r), o = Math.floor(o); const a = [], c = [], l = [], h = []; let u = 0, p = 0; function d(t, e, n, i, r, o, d, f, m, g, v) { const y = o / m, x = d / g, _ = o / 2, b = d / 2, w = f / 2, M = m + 1, S = g + 1; let T = 0, E = 0; const A = new Xn; for (let s = 0; s < S; s++) { const o = s * x - b; for (let a = 0; a < M; a++) { const u = a * y - _; A[t] = u * i, A[e] = o * r, A[n] = w, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, l.push(A.x, A.y, A.z), h.push(a / m), h.push(1 - s / g), T += 1 } } for (let s = 0; s < g; s++)for (let t = 0; t < m; t++) { const e = u + t + M * s, n = u + t + M * (s + 1), i = u + (t + 1) + M * (s + 1), r = u + (t + 1) + M * s; a.push(e, n, r), a.push(n, i, r), E += 6 } s.addGroup(p, E, v), p += E, u += T } d("z", "y", "x", -1, -1, n, e, t, o, r, 0), d("z", "y", "x", 1, -1, n, e, -t, o, r, 1), d("x", "z", "y", 1, 1, t, n, e, i, o, 2), d("x", "z", "y", 1, -1, t, n, -e, i, o, 3), d("x", "y", "z", 1, -1, t, e, n, i, r, 4), d("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Lr(c, 3)), this.setAttribute("normal", new Lr(l, 3)), this.setAttribute("uv", new Lr(h, 2)) } } function fo(t) { const e = {}; for (const n in t) { e[n] = {}; for (const i in t[n]) { const r = t[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r } } return e } function mo(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = fo(t[n]); for (const t in i) e[t] = i[t] } return e } exports.BoxBufferGeometry = po; const go = { clone: fo, merge: mo }; exports.UniformsUtils = go; var vo = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", yo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function xo(t) { gr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = vo, this.fragmentShader = yo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function _o() { xi.call(this), this.type = "Camera", this.matrixWorldInverse = new ei, this.projectionMatrix = new ei, this.projectionMatrixInverse = new ei } function bo(t, e, n, i) { _o.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } xo.prototype = Object.create(gr.prototype), xo.prototype.constructor = xo, xo.prototype.isShaderMaterial = !0, xo.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = fo(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this }, xo.prototype.toJSON = function (t) { const e = gr.prototype.toJSON.call(this, t); e.uniforms = {}; for (const i in this.uniforms) { const n = this.uniforms[i].value; n && n.isTexture ? e.uniforms[i] = { type: "t", value: n.toJSON(t).uuid } : n && n.isColor ? e.uniforms[i] = { type: "c", value: n.getHex() } : n && n.isVector2 ? e.uniforms[i] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? e.uniforms[i] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? e.uniforms[i] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? e.uniforms[i] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? e.uniforms[i] = { type: "m4", value: n.toArray() } : e.uniforms[i] = { value: n } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e }, _o.prototype = Object.assign(Object.create(xi.prototype), { constructor: _o, isCamera: !0, copy: function (t, e) { return xi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Xn), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { xi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function (t, e) { xi.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), bo.prototype = Object.assign(Object.create(_o.prototype), { constructor: bo, isPerspectiveCamera: !0, copy: function (t, e) { return _o.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * In.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function () { const t = Math.tan(.5 * In.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * In.RAD2DEG * Math.atan(Math.tan(.5 * In.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, n, i, r, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { let t = this.near, e = t * Math.tan(.5 * In.DEG2RAD * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i, o = this.view; if (null !== this.view && this.view.enabled) { const t = o.fullWidth, s = o.fullHeight; r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s } const s = this.filmOffset; 0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = xi.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }); const wo = 90, Mo = 1; function So(t, e, n) { if (xi.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const i = new bo(wo, Mo, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Xn(1, 0, 0)), this.add(i); const r = new bo(wo, Mo, t, e); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Xn(-1, 0, 0)), this.add(r); const o = new bo(wo, Mo, t, e); o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new Xn(0, 1, 0)), this.add(o); const s = new bo(wo, Mo, t, e); s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Xn(0, -1, 0)), this.add(s); const a = new bo(wo, Mo, t, e); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Xn(0, 0, 1)), this.add(a); const c = new bo(wo, Mo, t, e); c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Xn(0, 0, -1)), this.add(c), this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); const l = t.xr.enabled, h = t.getRenderTarget(); t.xr.enabled = !1; const u = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(h), t.xr.enabled = l }, this.clear = function (t, e, i, r) { const o = t.getRenderTarget(); for (let s = 0; s < 6; s++)t.setRenderTarget(n, s), t.clear(e, i, r); t.setRenderTarget(o) } } function To(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), kn.call(this, t, t, e) } function Eo(t, e, n, i, r, o, s, a, c, l, h, u) { zn.call(this, null, o, s, a, c, l, i, r, h, u), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : ut, this.minFilter = void 0 !== l ? l : ut, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } So.prototype = Object.create(xi.prototype), So.prototype.constructor = So, To.prototype = Object.create(kn.prototype), To.prototype.constructor = To, To.prototype.isWebGLCubeRenderTarget = !0, To.prototype.fromEquirectangularTexture = function (t, e) { this.texture.type = e.type, this.texture.format = Nt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = new _i, i = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t", fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t" }, r = new xo({ name: "CubemapFromEquirect", uniforms: fo(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: p, blending: g }); r.uniforms.tEquirect.value = e; const o = new io(new po(5, 5, 5), r); return n.add(o), new So(1, 10, this).update(t, n), o.geometry.dispose(), o.material.dispose(), this }, Eo.prototype = Object.create(zn.prototype), Eo.prototype.constructor = Eo, Eo.prototype.isDataTexture = !0; const Ao = new Fi, Lo = new Xn; function Ro(t, e, n, i, r, o) { this.planes = [void 0 !== t ? t : new Zi, void 0 !== e ? e : new Zi, void 0 !== n ? n : new Zi, void 0 !== i ? i : new Zi, void 0 !== r ? r : new Zi, void 0 !== o ? o : new Zi] } Object.assign(Ro.prototype, { set: function (t, e, n, i, r, o) { const s = this.planes; return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this }, setFromProjectionMatrix: function (t) { const e = this.planes, n = t.elements, i = n[0], r = n[1], o = n[2], s = n[3], a = n[4], c = n[5], l = n[6], h = n[7], u = n[8], p = n[9], d = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = n[15]; return e[0].setComponents(s - i, h - a, f - u, y - m).normalize(), e[1].setComponents(s + i, h + a, f + u, y + m).normalize(), e[2].setComponents(s + r, h + c, f + p, y + g).normalize(), e[3].setComponents(s - r, h - c, f - p, y - g).normalize(), e[4].setComponents(s - o, h - l, f - d, y - v).normalize(), e[5].setComponents(s + o, h + l, f + d, y + v).normalize(), this }, intersectsObject: function (t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Ao.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ao) }, intersectsSprite: function (t) { return Ao.center.set(0, 0, 0), Ao.radius = .7071067811865476, Ao.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ao) }, intersectsSphere: function (t) { const e = this.planes, n = t.center, i = -t.radius; for (let r = 0; r < 6; r++) { if (e[r].distanceToPoint(n) < i) return !1 } return !0 }, intersectsBox: function (t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Lo.x = i.normal.x > 0 ? t.max.x : t.min.x, Lo.y = i.normal.y > 0 ? t.max.y : t.min.y, Lo.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Lo) < 0) return !1 } return !0 }, containsPoint: function (t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } }); const Co = { common: { diffuse: { value: new hr(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Bn }, uv2Transform: { value: new Bn }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Nn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new hr(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new hr(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Bn } }, sprite: { diffuse: { value: new hr(15658734) }, opacity: { value: 1 }, center: { value: new Nn(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Bn } } }; function Po() { let t = null, e = !1, n = null, i = null; function r(e, o) { n(e, o), i = t.requestAnimationFrame(r) } return { start: function () { !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function () { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function Oo(t, e) { const n = e.isWebGL2, i = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = i.get(e); n && (t.deleteBuffer(n.buffer), i.delete(e)) }, update: function (e, r) { e.isInterleavedBufferAttribute && (e = e.data); const o = i.get(e); void 0 === o ? i.set(e, function (e, n) { const i = e.array, r = e.usage, o = t.createBuffer(); t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback(); let s = 5126; return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121), { buffer: o, type: s, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, r)) : o.version < e.version && (function (e, i, r) { const o = i.array, s = i.updateRange; t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1) }(o.buffer, e, r), o.version = e.version) } } } function Do(t, e, n, i) { ho.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }, this.fromBufferGeometry(new Io(t, e, n, i)), this.mergeVertices() } function Io(t, e, n, i) { Gr.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; const r = (t = t || 1) / 2, o = (e = e || 1) / 2, s = Math.floor(n) || 1, a = Math.floor(i) || 1, c = s + 1, l = a + 1, h = t / s, u = e / a, p = [], d = [], f = [], m = []; for (let g = 0; g < l; g++) { const t = g * u - o; for (let e = 0; e < c; e++) { const n = e * h - r; d.push(n, -t, 0), f.push(0, 0, 1), m.push(e / s), m.push(1 - g / a) } } for (let g = 0; g < a; g++)for (let t = 0; t < s; t++) { const e = t + c * g, n = t + c * (g + 1), i = t + 1 + c * (g + 1), r = t + 1 + c * g; p.push(e, n, r), p.push(n, i, r) } this.setIndex(p), this.setAttribute("position", new Lr(d, 3)), this.setAttribute("normal", new Lr(f, 3)), this.setAttribute("uv", new Lr(m, 2)) } exports.UniformsLib = Co, Do.prototype = Object.create(ho.prototype), Do.prototype.constructor = Do, Io.prototype = Object.create(Gr.prototype), Io.prototype.constructor = Io; var No = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", Bo = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", Fo = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", Uo = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", Go = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", zo = "vec3 transformed = vec3( position );", Ho = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", ko = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", Vo = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", jo = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", Wo = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", qo = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", Xo = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", Yo = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", Zo = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", Jo = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", Qo = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", Ko = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", $o = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif", ts = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", es = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", ns = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", is = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", rs = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", os = "gl_FragColor = linearToOutputTexel( gl_FragColor );", ss = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", as = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", cs = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", ls = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", hs = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", us = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", ps = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", ds = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fs = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", ms = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gs = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", vs = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", ys = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", xs = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", _s = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", bs = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", ws = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", Ms = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", Ss = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", Ts = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", Es = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", As = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", Ls = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", Rs = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", Cs = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", Ps = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", Os = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", Ds = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", Is = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", Ns = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", Bs = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", Fs = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", Us = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", Gs = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", zs = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", Hs = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", ks = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", Vs = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", js = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", Ws = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", qs = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", Xs = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", Ys = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", Zs = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", Js = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", Qs = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", Ks = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", $s = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", ta = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", ea = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", na = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", ia = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", ra = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", oa = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", sa = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", aa = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", ca = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", la = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", ha = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", ua = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", pa = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", da = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", fa = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", ma = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", ga = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", va = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", ya = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", xa = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", _a = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", ba = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", wa = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", Ma = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", Sa = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", Ta = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", Ea = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", Aa = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", La = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", Ra = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", Ca = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", Pa = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", Oa = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", Da = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", Ia = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", Na = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", Ba = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Fa = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", Ua = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Ga = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", za = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Ha = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", ka = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Va = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", ja = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Wa = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", qa = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", Xa = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", Ya = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", Za = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", Ja = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", Qa = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", Ka = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", $a = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", tc = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", ec = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"; const nc = { alphamap_fragment: No, alphamap_pars_fragment: Bo, alphatest_fragment: Fo, aomap_fragment: Uo, aomap_pars_fragment: Go, begin_vertex: zo, beginnormal_vertex: Ho, bsdfs: ko, bumpmap_pars_fragment: Vo, clipping_planes_fragment: jo, clipping_planes_pars_fragment: Wo, clipping_planes_pars_vertex: qo, clipping_planes_vertex: Xo, color_fragment: Yo, color_pars_fragment: Zo, color_pars_vertex: Jo, color_vertex: Qo, common: Ko, cube_uv_reflection_fragment: $o, defaultnormal_vertex: ts, displacementmap_pars_vertex: es, displacementmap_vertex: ns, emissivemap_fragment: is, emissivemap_pars_fragment: rs, encodings_fragment: os, encodings_pars_fragment: ss, envmap_fragment: as, envmap_common_pars_fragment: cs, envmap_pars_fragment: ls, envmap_pars_vertex: hs, envmap_physical_pars_fragment: bs, envmap_vertex: us, fog_vertex: ps, fog_pars_vertex: ds, fog_fragment: fs, fog_pars_fragment: ms, gradientmap_pars_fragment: gs, lightmap_fragment: vs, lightmap_pars_fragment: ys, lights_lambert_vertex: xs, lights_pars_begin: _s, lights_toon_fragment: ws, lights_toon_pars_fragment: Ms, lights_phong_fragment: Ss, lights_phong_pars_fragment: Ts, lights_physical_fragment: Es, lights_physical_pars_fragment: As, lights_fragment_begin: Ls, lights_fragment_maps: Rs, lights_fragment_end: Cs, logdepthbuf_fragment: Ps, logdepthbuf_pars_fragment: Os, logdepthbuf_pars_vertex: Ds, logdepthbuf_vertex: Is, map_fragment: Ns, map_pars_fragment: Bs, map_particle_fragment: Fs, map_particle_pars_fragment: Us, metalnessmap_fragment: Gs, metalnessmap_pars_fragment: zs, morphnormal_vertex: Hs, morphtarget_pars_vertex: ks, morphtarget_vertex: Vs, normal_fragment_begin: js, normal_fragment_maps: Ws, normalmap_pars_fragment: qs, clearcoat_normal_fragment_begin: Xs, clearcoat_normal_fragment_maps: Ys, clearcoat_pars_fragment: Zs, packing: Js, premultiplied_alpha_fragment: Qs, project_vertex: Ks, dithering_fragment: $s, dithering_pars_fragment: ta, roughnessmap_fragment: ea, roughnessmap_pars_fragment: na, shadowmap_pars_fragment: ia, shadowmap_pars_vertex: ra, shadowmap_vertex: oa, shadowmask_pars_fragment: sa, skinbase_vertex: aa, skinning_pars_vertex: ca, skinning_vertex: la, skinnormal_vertex: ha, specularmap_fragment: ua, specularmap_pars_fragment: pa, tonemapping_fragment: da, tonemapping_pars_fragment: fa, transmissionmap_fragment: ma, transmissionmap_pars_fragment: ga, uv_pars_fragment: va, uv_pars_vertex: ya, uv_vertex: xa, uv2_pars_fragment: _a, uv2_pars_vertex: ba, uv2_vertex: wa, worldpos_vertex: Ma, background_frag: Sa, background_vert: Ta, cube_frag: Ea, cube_vert: Aa, depth_frag: La, depth_vert: Ra, distanceRGBA_frag: Ca, distanceRGBA_vert: Pa, equirect_frag: Oa, equirect_vert: Da, linedashed_frag: Ia, linedashed_vert: Na, meshbasic_frag: Ba, meshbasic_vert: Fa, meshlambert_frag: Ua, meshlambert_vert: Ga, meshmatcap_frag: za, meshmatcap_vert: Ha, meshtoon_frag: ka, meshtoon_vert: Va, meshphong_frag: ja, meshphong_vert: Wa, meshphysical_frag: qa, meshphysical_vert: Xa, normal_frag: Ya, normal_vert: Za, points_frag: Ja, points_vert: Qa, shadow_frag: Ka, shadow_vert: $a, sprite_frag: tc, sprite_vert: ec }; exports.ShaderChunk = nc; const ic = { basic: { uniforms: mo([Co.common, Co.specularmap, Co.envmap, Co.aomap, Co.lightmap, Co.fog]), vertexShader: nc.meshbasic_vert, fragmentShader: nc.meshbasic_frag }, lambert: { uniforms: mo([Co.common, Co.specularmap, Co.envmap, Co.aomap, Co.lightmap, Co.emissivemap, Co.fog, Co.lights, { emissive: { value: new hr(0) } }]), vertexShader: nc.meshlambert_vert, fragmentShader: nc.meshlambert_frag }, phong: { uniforms: mo([Co.common, Co.specularmap, Co.envmap, Co.aomap, Co.lightmap, Co.emissivemap, Co.bumpmap, Co.normalmap, Co.displacementmap, Co.fog, Co.lights, { emissive: { value: new hr(0) }, specular: { value: new hr(1118481) }, shininess: { value: 30 } }]), vertexShader: nc.meshphong_vert, fragmentShader: nc.meshphong_frag }, standard: { uniforms: mo([Co.common, Co.envmap, Co.aomap, Co.lightmap, Co.emissivemap, Co.bumpmap, Co.normalmap, Co.displacementmap, Co.roughnessmap, Co.metalnessmap, Co.fog, Co.lights, { emissive: { value: new hr(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: nc.meshphysical_vert, fragmentShader: nc.meshphysical_frag }, toon: { uniforms: mo([Co.common, Co.aomap, Co.lightmap, Co.emissivemap, Co.bumpmap, Co.normalmap, Co.displacementmap, Co.gradientmap, Co.fog, Co.lights, { emissive: { value: new hr(0) } }]), vertexShader: nc.meshtoon_vert, fragmentShader: nc.meshtoon_frag }, matcap: { uniforms: mo([Co.common, Co.bumpmap, Co.normalmap, Co.displacementmap, Co.fog, { matcap: { value: null } }]), vertexShader: nc.meshmatcap_vert, fragmentShader: nc.meshmatcap_frag }, points: { uniforms: mo([Co.points, Co.fog]), vertexShader: nc.points_vert, fragmentShader: nc.points_frag }, dashed: { uniforms: mo([Co.common, Co.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: nc.linedashed_vert, fragmentShader: nc.linedashed_frag }, depth: { uniforms: mo([Co.common, Co.displacementmap]), vertexShader: nc.depth_vert, fragmentShader: nc.depth_frag }, normal: { uniforms: mo([Co.common, Co.bumpmap, Co.normalmap, Co.displacementmap, { opacity: { value: 1 } }]), vertexShader: nc.normal_vert, fragmentShader: nc.normal_frag }, sprite: { uniforms: mo([Co.sprite, Co.fog]), vertexShader: nc.sprite_vert, fragmentShader: nc.sprite_frag }, background: { uniforms: { uvTransform: { value: new Bn }, t2D: { value: null } }, vertexShader: nc.background_vert, fragmentShader: nc.background_frag }, cube: { uniforms: mo([Co.envmap, { opacity: { value: 1 } }]), vertexShader: nc.cube_vert, fragmentShader: nc.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: nc.equirect_vert, fragmentShader: nc.equirect_frag }, distanceRGBA: { uniforms: mo([Co.common, Co.displacementmap, { referencePosition: { value: new Xn }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: nc.distanceRGBA_vert, fragmentShader: nc.distanceRGBA_frag }, shadow: { uniforms: mo([Co.lights, Co.fog, { color: { value: new hr(0) }, opacity: { value: 1 } }]), vertexShader: nc.shadow_vert, fragmentShader: nc.shadow_frag } }; function rc(t, e, n, i) { const r = new hr(0); let o, s, a = 0, c = null, l = 0, h = null; function d(t, n) { e.buffers.color.setClear(t.r, t.g, t.b, n, i) } return { getClearColor: function () { return r }, setClearColor: function (t, e) { r.set(t), d(r, a = void 0 !== e ? e : 1) }, getClearAlpha: function () { return a }, setClearAlpha: function (t) { d(r, a = t) }, render: function (e, i, f, m) { let g = !0 === i.isScene ? i.background : null; const v = t.xr, y = v.getSession && v.getSession(); if (y && "additive" === y.environmentBlendMode && (g = null), null === g ? d(r, a) : g && g.isColor && (d(g, 1), m = !0), (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.isWebGLCubeRenderTarget || g.mapping === st)) { void 0 === s && ((s = new io(new po(1, 1, 1), new xo({ name: "BackgroundCubeMaterial", uniforms: fo(ic.cube.uniforms), vertexShader: ic.cube.vertexShader, fragmentShader: ic.cube.fragmentShader, side: p, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(s.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), n.update(s)); const i = g.isWebGLCubeRenderTarget ? g.texture : g; s.material.uniforms.envMap.value = i, s.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1, c === g && l === i.version && h === t.toneMapping || (s.material.needsUpdate = !0, c = g, l = i.version, h = t.toneMapping), e.unshift(s, s.geometry, s.material, 0, 0, null) } else g && g.isTexture && (void 0 === o && ((o = new io(new Io(2, 2), new xo({ name: "BackgroundMaterial", uniforms: fo(ic.background.uniforms), vertexShader: ic.background.vertexShader, fragmentShader: ic.background.fragmentShader, side: u, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), n.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), c === g && l === g.version && h === t.toneMapping || (o.material.needsUpdate = !0, c = g, l = g.version, h = t.toneMapping), e.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function oc(t, e, n, i) { const r = t.getParameter(34921), o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = i.isWebGL2 || null !== o, a = {}, c = p(null); let l = c; function h(e) { return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e) } function u(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e) } function p(t) { const e = [], n = [], i = []; for (let o = 0; o < r; o++)e[o] = 0, n[o] = 0, i[o] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {} } } function d() { const t = l.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function f(t) { m(t, 0) } function m(n, r) { const o = l.newAttributes, s = l.enabledAttributes, a = l.attributeDivisors; if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r) { (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r } } function g() { const e = l.newAttributes, n = l.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0) } function v(e, n, r, o, s, a) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a) } function y() { x(), l !== c && h((l = c).object) } function x() { c.geometry = null, c.program = null, c.wireframe = !1 } return { setup: function (r, c, u, y, x) { let _ = !1; if (s) { const e = function (e, n, r) { const s = !0 === r.wireframe; let c = a[e.id]; void 0 === c && (c = {}, a[e.id] = c); let l = c[n.id]; void 0 === l && (l = {}, c[n.id] = l); let h = l[s]; return void 0 === h && (h = p(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = h), h }(y, u, c); l !== e && h((l = e).object), (_ = function (t) { const e = l.attributes, n = t.attributes; if (Object.keys(e).length !== Object.keys(n).length) return !0; for (const i in n) { const t = e[i], r = n[i]; if (t.attribute !== r) return !0; if (t.data !== r.data) return !0 } return !1 }(y)) && function (t) { const e = {}, n = t.attributes; for (const i in n) { const t = n[i], r = {}; r.attribute = t, t.data && (r.data = t.data), e[i] = r } l.attributes = e }(y) } else { const t = !0 === c.wireframe; l.geometry === y.id && l.program === u.id && l.wireframe === t || (l.geometry = y.id, l.program = u.id, l.wireframe = t, _ = !0) } !0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function (r, o, s, a) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; d(); const c = a.attributes, l = s.getAttributes(), h = o.defaultAttributeValues; for (const e in l) { const i = l[e]; if (i >= 0) { const o = c[e]; if (void 0 !== o) { const e = o.normalized, r = o.itemSize, s = n.get(o); if (void 0 === s) continue; const c = s.buffer, l = s.type, h = s.bytesPerElement; if (o.isInterleavedBufferAttribute) { const n = o.data, s = n.stride, u = o.offset; n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, s * h, u * h) } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0) } else if ("instanceMatrix" === e) { const e = n.get(r.instanceMatrix); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48) } else if (void 0 !== h) { const n = h[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(i, n); break; case 3: t.vertexAttrib3fv(i, n); break; case 4: t.vertexAttrib4fv(i, n); break; default: t.vertexAttrib1fv(i, n) } } } } g() }(r, c, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const t in a) { const e = a[t]; for (const t in e) { const n = e[t]; for (const t in n) u(n[t].object), delete n[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const n in e) { const t = e[n]; for (const e in t) u(t[e].object), delete t[e]; delete e[n] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const n = a[e]; if (void 0 === n[t.id]) continue; const i = n[t.id]; for (const t in i) u(i[t].object), delete i[t]; delete n[t.id] } }, initAttributes: d, enableAttribute: f, disableUnusedAttributes: g } } function sc(t, e, n, i) { const r = i.isWebGL2; let o; this.setMode = function (t) { o = t }, this.render = function (e, i) { t.drawArrays(o, e, i), n.update(i, o, 1) }, this.renderInstances = function (i, s, a) { if (0 === a) return; let c, l; if (r) c = t, l = "drawArraysInstanced"; else if (l = "drawArraysInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[l](o, i, s, a), n.update(s, o, a) } } function ac(t, e, n) { let i; function r(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let s = void 0 !== n.precision ? n.precision : "highp"; const a = r(s); a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a); const c = !0 === n.logarithmicDepthBuffer, l = t.getParameter(34930), h = t.getParameter(35660), u = t.getParameter(3379), p = t.getParameter(34076), d = t.getParameter(34921), f = t.getParameter(36347), m = t.getParameter(36348), g = t.getParameter(36349), v = h > 0, y = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== i) return i; const n = e.get("EXT_texture_filter_anisotropic"); return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: o ? t.getParameter(36183) : 0 } } function cc() { const t = this; let e = null, n = 0, i = !1, r = !1; const o = new Zi, s = new Bn, a = { value: null, needsUpdate: !1 }; function c() { a.value !== e && (a.value = e, a.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0 } function l(e, n, i, r) { let c = null !== e ? e.length : 0, l = null; if (0 !== c) { if (l = a.value, !0 !== r || null === l) { const t = i + 4 * c, r = n.matrixWorldInverse; s.getNormalMatrix(r), (null === l || l.length < t) && (l = new Float32Array(t)); for (let n = 0, a = i; n !== c; ++n, a += 4)o.copy(e[n]).applyMatrix4(r, s), o.normal.toArray(l, a), l[a + 3] = o.constant } a.value = l, a.needsUpdate = !0 } return t.numPlanes = c, t.numIntersection = 0, l } this.uniform = a, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, o) { const s = 0 !== t.length || r || 0 !== n || i; return i = r, e = l(t, o, 0), n = t.length, s }, this.beginShadows = function () { r = !0, l(null) }, this.endShadows = function () { r = !1, c() }, this.setState = function (t, o, s, h, u, p) { if (!i || null === t || 0 === t.length || r && !s) r ? l(null) : c(); else { const i = r ? 0 : n, s = 4 * i; let c = u.clippingState || null; a.value = c, c = l(t, h, s, p); for (let t = 0; t !== s; ++t)c[t] = e[t]; u.clippingState = c, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += i } } } function lc(t) { const e = {}; return { has: function (n) { if (void 0 !== e[n]) return e[n]; let i; switch (n) { case "WEBGL_depth_texture": i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(n) }return e[n] = i, !!i }, get: function (t) { return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t] } } } function hc(t, e, n, i) { const r = new WeakMap, o = new WeakMap; function s(t) { const a = t.target, c = r.get(a); null !== c.index && e.remove(c.index); for (const n in c.attributes) e.remove(c.attributes[n]); a.removeEventListener("dispose", s), r.delete(a); const l = o.get(c); l && (e.remove(l), o.delete(c)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(t) { const n = [], i = t.index, r = t.attributes.position; let s = 0; if (null !== i) { const t = i.array; s = i.version; for (let e = 0, i = t.length; e < i; e += 3) { const i = t[e + 0], r = t[e + 1], o = t[e + 2]; n.push(i, r, r, o, o, i) } } else { const t = r.array; s = r.version; for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) { const t = e + 0, i = e + 1, r = e + 2; n.push(t, i, i, r, r, t) } } const a = new (Pr(n) > 65535 ? Ar : Tr)(n, 1); a.version = s; const c = o.get(t); c && e.remove(c), o.set(t, a) } return { get: function (t, e) { let i = r.get(e); return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Gr).setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i) }, update: function (t) { const n = t.attributes; for (const r in n) e.update(n[r], 34962); const i = t.morphAttributes; for (const r in i) { const t = i[r]; for (let n = 0, i = t.length; n < i; n++)e.update(t[n], 34962) } }, getWireframeAttribute: function (t) { const e = o.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && a(t) } else a(t); return o.get(t) } } } function uc(t, e, n, i) { const r = i.isWebGL2; let o, s, a; this.setMode = function (t) { o = t }, this.setIndex = function (t) { s = t.type, a = t.bytesPerElement }, this.render = function (e, i) { t.drawElements(o, i, s, e * a), n.update(i, o, 1) }, this.renderInstances = function (i, c, l) { if (0 === l) return; let h, u; if (r) h = t, u = "drawElementsInstanced"; else if (u = "drawElementsInstancedANGLE", null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); h[u](o, c, s, i * a, l), n.update(c, o, l) } } function pc(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, i) { switch (e.calls++, n) { case 4: e.triangles += i * (t / 3); break; case 1: e.lines += i * (t / 2); break; case 3: e.lines += i * (t - 1); break; case 2: e.lines += i * t; break; case 0: e.points += i * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function dc(t, e) { return t[0] - e[0] } function fc(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function mc(t) { const e = {}, n = new Float32Array(8), i = []; for (let r = 0; r < 8; r++)i[r] = [r, 0]; return { update: function (r, o, s, a) { const c = r.morphTargetInfluences, l = void 0 === c ? 0 : c.length; let h = e[o.id]; if (void 0 === h) { h = []; for (let t = 0; t < l; t++)h[t] = [t, 0]; e[o.id] = h } for (let t = 0; t < l; t++) { const e = h[t]; e[0] = t, e[1] = c[t] } h.sort(fc); for (let t = 0; t < 8; t++)t < l && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0); i.sort(dc); const u = s.morphTargets && o.morphAttributes.position, p = s.morphNormals && o.morphAttributes.normal; let d = 0; for (let t = 0; t < 8; t++) { const e = i[t], r = e[0], s = e[1]; r !== Number.MAX_SAFE_INTEGER && s ? (u && o.getAttribute("morphTarget" + t) !== u[r] && o.setAttribute("morphTarget" + t, u[r]), p && o.getAttribute("morphNormal" + t) !== p[r] && o.setAttribute("morphNormal" + t, p[r]), n[t] = s, d += s) : (u && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), p && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0) } const f = o.morphTargetsRelative ? 1 : 1 - d; a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n) } } } function gc(t, e, n, i) { let r = new WeakMap; return { update: function (t) { const o = i.render.frame, s = t.geometry, a = e.get(t, s); return r.get(a) !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), a }, dispose: function () { r = new WeakMap } } } function vc(t, e, n, i, r, o, s, a, c, l) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : nt, s = void 0 !== s ? s : It, zn.call(this, t, e, n, i, r, o, s, a, c, l), this.flipY = !1 } function yc(t, e, n, i) { zn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: i || 1 }, this.magFilter = ut, this.minFilter = ut, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function xc(t, e, n, i) { zn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: i || 1 }, this.magFilter = ut, this.minFilter = ut, this.wrapR = lt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } exports.ShaderLib = ic, ic.physical = { uniforms: mo([ic.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Nn(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new hr(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: nc.meshphysical_vert, fragmentShader: nc.meshphysical_frag }, vc.prototype = Object.create(zn.prototype), vc.prototype.constructor = vc, vc.prototype.isCubeTexture = !0, Object.defineProperty(vc.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), yc.prototype = Object.create(zn.prototype), yc.prototype.constructor = yc, yc.prototype.isDataTexture2DArray = !0, xc.prototype = Object.create(zn.prototype), xc.prototype.constructor = xc, xc.prototype.isDataTexture3D = !0; const _c = new zn, bc = new yc, wc = new xc, Mc = new vc, Sc = [], Tc = [], Ec = new Float32Array(16), Ac = new Float32Array(9), Lc = new Float32Array(4); function Rc(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; let r = e * n, o = Sc[r]; if (void 0 === o && (o = new Float32Array(r), Sc[r] = o), 0 !== e) { i.toArray(o, 0); for (let i = 1, r = 0; i !== e; ++i)r += n, t[i].toArray(o, r) } return o } function Cc(t, e) { if (t.length !== e.length) return !1; for (let n = 0, i = t.length; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function Pc(t, e) { for (let n = 0, i = e.length; n < i; n++)t[n] = e[n] } function Oc(t, e) { let n = Tc[e]; void 0 === n && (n = new Int32Array(e), Tc[e] = n); for (let i = 0; i !== e; ++i)n[i] = t.allocateTextureUnit(); return n } function Dc(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Ic(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (Cc(n, e)) return; t.uniform2fv(this.addr, e), Pc(n, e) } } function Nc(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (Cc(n, e)) return; t.uniform3fv(this.addr, e), Pc(n, e) } } function Bc(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (Cc(n, e)) return; t.uniform4fv(this.addr, e), Pc(n, e) } } function Fc(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (Cc(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), Pc(n, e) } else { if (Cc(n, i)) return; Lc.set(i), t.uniformMatrix2fv(this.addr, !1, Lc), Pc(n, i) } } function Uc(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (Cc(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), Pc(n, e) } else { if (Cc(n, i)) return; Ac.set(i), t.uniformMatrix3fv(this.addr, !1, Ac), Pc(n, i) } } function Gc(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (Cc(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), Pc(n, e) } else { if (Cc(n, i)) return; Ec.set(i), t.uniformMatrix4fv(this.addr, !1, Ec), Pc(n, i) } } function zc(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || _c, r) } function Hc(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || bc, r) } function kc(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || wc, r) } function Vc(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Mc, r) } function jc(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function Wc(t, e) { const n = this.cache; Cc(n, e) || (t.uniform2iv(this.addr, e), Pc(n, e)) } function qc(t, e) { const n = this.cache; Cc(n, e) || (t.uniform3iv(this.addr, e), Pc(n, e)) } function Xc(t, e) { const n = this.cache; Cc(n, e) || (t.uniform4iv(this.addr, e), Pc(n, e)) } function Yc(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function Zc(t) { switch (t) { case 5126: return Dc; case 35664: return Ic; case 35665: return Nc; case 35666: return Bc; case 35674: return Fc; case 35675: return Uc; case 35676: return Gc; case 5124: case 35670: return jc; case 35667: case 35671: return Wc; case 35668: case 35672: return qc; case 35669: case 35673: return Xc; case 5125: return Yc; case 35678: case 36198: case 36298: case 36306: case 35682: return zc; case 35679: case 36299: case 36307: return kc; case 35680: case 36300: case 36308: case 36293: return Vc; case 36289: case 36303: case 36311: case 36292: return Hc } } function Jc(t, e) { t.uniform1fv(this.addr, e) } function Qc(t, e) { t.uniform1iv(this.addr, e) } function Kc(t, e) { t.uniform2iv(this.addr, e) } function $c(t, e) { t.uniform3iv(this.addr, e) } function tl(t, e) { t.uniform4iv(this.addr, e) } function el(t, e) { const n = Rc(e, this.size, 2); t.uniform2fv(this.addr, n) } function nl(t, e) { const n = Rc(e, this.size, 3); t.uniform3fv(this.addr, n) } function il(t, e) { const n = Rc(e, this.size, 4); t.uniform4fv(this.addr, n) } function rl(t, e) { const n = Rc(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function ol(t, e) { const n = Rc(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function sl(t, e) { const n = Rc(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function al(t, e, n) { const i = e.length, r = Oc(n, i); t.uniform1iv(this.addr, r); for (let o = 0; o !== i; ++o)n.safeSetTexture2D(e[o] || _c, r[o]) } function cl(t, e, n) { const i = e.length, r = Oc(n, i); t.uniform1iv(this.addr, r); for (let o = 0; o !== i; ++o)n.safeSetTextureCube(e[o] || Mc, r[o]) } function ll(t) { switch (t) { case 5126: return Jc; case 35664: return el; case 35665: return nl; case 35666: return il; case 35674: return rl; case 35675: return ol; case 35676: return sl; case 5124: case 35670: return Qc; case 35667: case 35671: return Kc; case 35668: case 35672: return $c; case 35669: case 35673: return tl; case 35678: case 36198: case 36298: case 36306: case 35682: return al; case 35680: case 36300: case 36308: case 36293: return cl } } function hl(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = Zc(e.type) } function ul(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = ll(e.type) } function pl(t) { this.id = t, this.seq = [], this.map = {} } ul.prototype.updateCache = function (t) { let e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Pc(e, t) }, pl.prototype.setValue = function (t, e, n) { const i = this.seq; for (let r = 0, o = i.length; r !== o; ++r) { const o = i[r]; o.setValue(t, e[o.id], n) } }; const dl = /([\w\d_]+)(\])?(\[|\.)?/g; function fl(t, e) { t.seq.push(e), t.map[e.id] = e } function ml(t, e, n) { const i = t.name, r = i.length; for (dl.lastIndex = 0; ;) { const o = dl.exec(i), s = dl.lastIndex; let a = o[1], c = "]" === o[2], l = o[3]; if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === r) { fl(n, void 0 === l ? new hl(a, t, e) : new ul(a, t, e)); break } { let t = n.map[a]; void 0 === t && fl(n, t = new pl(a)), n = t } } } function gl(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let i = 0; i < n; ++i) { const n = t.getActiveUniform(e, i); ml(n, t.getUniformLocation(e, n.name), this) } } function vl(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i } gl.prototype.setValue = function (t, e, n, i) { const r = this.map[e]; void 0 !== r && r.setValue(t, n, i) }, gl.prototype.setOptional = function (t, e, n) { const i = e[n]; void 0 !== i && this.setValue(t, n, i) }, gl.upload = function (t, e, n, i) { for (let r = 0, o = e.length; r !== o; ++r) { const o = e[r], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, i) } }, gl.seqWithValue = function (t, e) { const n = []; for (let i = 0, r = t.length; i !== r; ++i) { const r = t[i]; r.id in e && n.push(r) } return n }; let yl = 0; function xl(t) { const e = t.split("\n"); for (let n = 0; n < e.length; n++)e[n] = n + 1 + ": " + e[n]; return e.join("\n") } function _l(t) { switch (t) { case Xe: return ["Linear", "( value )"]; case Ye: return ["sRGB", "( value )"]; case Je: return ["RGBE", "( value )"]; case Ke: return ["RGBM", "( value, 7.0 )"]; case $e: return ["RGBM", "( value, 16.0 )"]; case tn: return ["RGBD", "( value, 256.0 )"]; case Ze: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case Qe: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } } function bl(t, e, n) { const i = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim(); return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + xl(t.getShaderSource(e)) } function wl(t, e) { const n = _l(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function Ml(t, e) { const n = _l(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function Sl(t, e) { let n; switch (e) { case J: n = "Linear"; break; case Q: n = "Reinhard"; break; case K: n = "OptimizedCineon"; break; case $: n = "ACESFilmic"; break; case tt: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function Tl(t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ll).join("\n") } function El(t) { const e = []; for (const n in t) { const i = t[n]; !1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") } function Al(t, e) { const n = {}, i = t.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const i = t.getActiveAttrib(e, r).name; n[i] = t.getAttribLocation(e, i) } return n } function Ll(t) { return "" !== t } function Rl(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Cl(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const Pl = /^[ \t]*#include +<([\w\d./]+)>/gm; function Ol(t) { return t.replace(Pl, Dl) } function Dl(t, e) { const n = nc[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return Ol(n) } const Il = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Nl = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g; function Bl(t) { return t.replace(Nl, Ul).replace(Il, Fl) } function Fl(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ul(t, e, n, i) } function Ul(t, e, n, i) { let r = ""; for (let o = parseInt(e); o < parseInt(n); o++)r += i.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o); return r } function Gl(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function zl(t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === c ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"), e } function Hl(t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case nt: case it: e = "ENVMAP_TYPE_CUBE"; break; case st: case at: e = "ENVMAP_TYPE_CUBE_UV"; break; case rt: case ot: e = "ENVMAP_TYPE_EQUIREC" }return e } function kl(t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case it: case ot: case at: e = "ENVMAP_MODE_REFRACTION" }return e } function Vl(t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case q: e = "ENVMAP_BLENDING_MULTIPLY"; break; case X: e = "ENVMAP_BLENDING_MIX"; break; case Y: e = "ENVMAP_BLENDING_ADD" }return e } function jl(t, e, n, i) { const r = t.getContext(), o = n.defines; let s = n.vertexShader, a = n.fragmentShader; const c = zl(n), l = Hl(n), h = kl(n), u = Vl(n), p = t.gammaFactor > 0 ? t.gammaFactor : 1, d = n.isWebGL2 ? "" : Tl(n), f = El(o), m = r.createProgram(); let g, v; n.isRawShaderMaterial ? ((g = [f].filter(Ll).join("\n")).length > 0 && (g += "\n"), (v = [d, f].filter(Ll).join("\n")).length > 0 && (v += "\n")) : (g = [Gl(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ll).join("\n"), v = [d, Gl(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Z ? "#define TONE_MAPPING" : "", n.toneMapping !== Z ? nc.tonemapping_pars_fragment : "", n.toneMapping !== Z ? Sl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", nc.encodings_pars_fragment, n.map ? wl("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? wl("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? wl("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? wl("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? wl("lightMapTexelToLinear", n.lightMapEncoding) : "", Ml("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ll).join("\n")), s = Cl(s = Rl(s = Ol(s), n), n), a = Cl(a = Rl(a = Ol(a), n), n), s = Bl(s), a = Bl(a), n.isWebGL2 && !n.isRawShaderMaterial && (g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", "out highp vec4 pc_fragColor;", "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const y = v + a, x = vl(r, 35633, g + s), _ = vl(r, 35632, y); if (r.attachShader(m, x), r.attachShader(m, _), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) { const t = r.getProgramInfoLog(m).trim(), e = r.getShaderInfoLog(x).trim(), n = r.getShaderInfoLog(_).trim(); let i = !0, o = !0; if (!1 === r.getProgramParameter(m, 35714)) { i = !1; const e = bl(r, x, "vertex"), n = bl(r, _, "fragment"); console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n) } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1); o && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: g }, fragmentShader: { log: n, prefix: v } }) } let b, w; return r.deleteShader(x), r.deleteShader(_), this.getUniforms = function () { return void 0 === b && (b = new gl(r, m)), b }, this.getAttributes = function () { return void 0 === w && (w = Al(r, m)), w }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0 }, this.name = n.shaderName, this.id = yl++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = _, this } function Wl(t, e, n, i) { const r = [], o = n.isWebGL2, s = n.logarithmicDepthBuffer, a = n.floatVertexTextures, c = n.maxVertexUniforms, l = n.vertexTextures; let h = n.precision; const u = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function m(t) { let e; return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Xe, e } return { getParameters: function (i, r, f, g, v, y, x) { const _ = g.fog, b = i.isMeshStandardMaterial ? g.environment : null, w = i.envMap || b, M = u[i.type], S = x.isSkinnedMesh ? function (t) { const e = t.skeleton.bones; if (a) return 1024; { const t = c, n = Math.floor((t - 20) / 4), i = Math.min(n, e.length); return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i } }(x) : 0; let T, E; if (null !== i.precision && (h = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", h, "instead."), M) { const t = ic[M]; T = t.vertexShader, E = t.fragmentShader } else T = i.vertexShader, E = i.fragmentShader; const A = t.getRenderTarget(); return { isWebGL2: o, shaderID: M, shaderName: i.type, vertexShader: T, fragmentShader: E, defines: i.defines, isRawShaderMaterial: i.isRawShaderMaterial, isShaderMaterial: i.isShaderMaterial, precision: h, instancing: !0 === x.isInstancedMesh, supportsVertexTextures: l, outputEncoding: null !== A ? m(A.texture) : t.outputEncoding, map: !!i.map, mapEncoding: m(i.map), matcap: !!i.matcap, matcapEncoding: m(i.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: m(w), envMapCubeUV: !!w && (w.mapping === st || w.mapping === at), lightMap: !!i.lightMap, lightMapEncoding: m(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: m(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: i.normalMapType === on, tangentSpaceNormalMap: i.normalMapType === rn, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmissionMap: !!i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap), fog: !!_, useFog: i.fog, fogExp2: _ && _.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: s, skinning: i.skinning && S > 0, maxBones: S, useVertexTexture: a, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: r.directional.length, numPointLights: r.point.length, numSpotLights: r.spot.length, numRectAreaLights: r.rectArea.length, numHemiLights: r.hemi.length, numDirLightShadows: r.directionalShadowMap.length, numPointLightShadows: r.pointShadowMap.length, numSpotLightShadows: r.spotShadowMap.length, numClippingPlanes: v, numClipIntersection: y, dithering: i.dithering, shadowMapEnabled: t.shadowMap.enabled && f.length > 0, shadowMapType: t.shadowMap.type, toneMapping: i.toneMapped ? t.toneMapping : Z, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === d, flipSided: i.side === p, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"), rendererExtensionDrawBuffers: o || null !== e.get("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: o || null !== e.get("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); if (void 0 === e.isRawShaderMaterial) { for (let t = 0; t < f.length; t++)n.push(e[f[t]]); n.push(t.outputEncoding), n.push(t.gammaFactor) } return n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = u[t.type]; let n; if (e) { const t = ic[e]; n = go.clone(t.uniforms) } else n = t.uniforms; return n }, acquireProgram: function (e, n) { let o; for (let t = 0, i = r.length; t < i; t++) { const e = r[t]; if (e.cacheKey === n) { ++(o = e).usedTimes; break } } return void 0 === o && (o = new jl(t, n, e, i), r.push(o)), o }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = r.indexOf(t); r[e] = r[r.length - 1], r.pop(), t.destroy() } }, programs: r } } function ql() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, i) { t.get(e)[n] = i }, dispose: function () { t = new WeakMap } } } function Xl(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function Yl(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function Zl(t) { const e = []; let n = 0; const i = [], r = [], o = { id: -1 }; function s(i, r, s, a, c, l) { let h = e[n]; const u = t.get(s); return void 0 === h ? (h = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: c, group: l }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || o, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = c, h.group = l), n++, h } return { opaque: i, transparent: r, init: function () { n = 0, i.length = 0, r.length = 0 }, push: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).push(l) }, unshift: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).unshift(l) }, finish: function () { for (let t = n, i = e.length; t < i; t++) { const n = e[t]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (t, e) { i.length > 1 && i.sort(t || Xl), r.length > 1 && r.sort(e || Yl) } } } function Jl(t) { let e = new WeakMap; function n(t) { const i = t.target; i.removeEventListener("dispose", n), e.delete(i) } return { get: function (i, r) { const o = e.get(i); let s; return void 0 === o ? (s = new Zl(t), e.set(i, new WeakMap), e.get(i).set(r, s), i.addEventListener("dispose", n)) : void 0 === (s = o.get(r)) && (s = new Zl(t), o.set(r, s)), s }, dispose: function () { e = new WeakMap } } } function Ql() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new Xn, color: new hr }; break; case "SpotLight": n = { position: new Xn, direction: new Xn, color: new hr, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Xn, color: new hr, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Xn, skyColor: new hr, groundColor: new hr }; break; case "RectAreaLight": n = { color: new hr, position: new Xn, halfWidth: new Xn, halfHeight: new Xn } }return t[e.id] = n, n } } } function Kl() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Nn }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Nn, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } } let $l = 0; function th(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function eh() { const t = new Ql, e = Kl(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let s = 0; s < 9; s++)n.probe.push(new Xn); const i = new Xn, r = new ei, o = new ei; return { setup: function (s, a, c) { let l = 0, h = 0, u = 0; for (let t = 0; t < 9; t++)n.probe[t].set(0, 0, 0); let p = 0, d = 0, f = 0, m = 0, g = 0, v = 0, y = 0, x = 0; const _ = c.matrixWorldInverse; s.sort(th); for (let w = 0, M = s.length; w < M; w++) { const a = s[w], c = a.color, b = a.intensity, M = a.distance, S = a.shadow && a.shadow.map ? a.shadow.map.texture : null; if (a.isAmbientLight) l += c.r * b, h += c.g * b, u += c.b * b; else if (a.isLightProbe) for (let t = 0; t < 9; t++)n.probe[t].addScaledVector(a.sh.coefficients[t], b); else if (a.isDirectionalLight) { const r = t.get(a); if (r.color.copy(a.color).multiplyScalar(a.intensity), r.direction.setFromMatrixPosition(a.matrixWorld), i.setFromMatrixPosition(a.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(_), a.castShadow) { const t = a.shadow, i = e.get(a); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.directionalShadow[p] = i, n.directionalShadowMap[p] = S, n.directionalShadowMatrix[p] = a.shadow.matrix, v++ } n.directional[p] = r, p++ } else if (a.isSpotLight) { const r = t.get(a); if (r.position.setFromMatrixPosition(a.matrixWorld), r.position.applyMatrix4(_), r.color.copy(c).multiplyScalar(b), r.distance = M, r.direction.setFromMatrixPosition(a.matrixWorld), i.setFromMatrixPosition(a.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(_), r.coneCos = Math.cos(a.angle), r.penumbraCos = Math.cos(a.angle * (1 - a.penumbra)), r.decay = a.decay, a.castShadow) { const t = a.shadow, i = e.get(a); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.spotShadow[f] = i, n.spotShadowMap[f] = S, n.spotShadowMatrix[f] = a.shadow.matrix, x++ } n.spot[f] = r, f++ } else if (a.isRectAreaLight) { const e = t.get(a); e.color.copy(c).multiplyScalar(b), e.position.setFromMatrixPosition(a.matrixWorld), e.position.applyMatrix4(_), o.identity(), r.copy(a.matrixWorld), r.premultiply(_), o.extractRotation(r), e.halfWidth.set(.5 * a.width, 0, 0), e.halfHeight.set(0, .5 * a.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), n.rectArea[m] = e, m++ } else if (a.isPointLight) { const i = t.get(a); if (i.position.setFromMatrixPosition(a.matrixWorld), i.position.applyMatrix4(_), i.color.copy(a.color).multiplyScalar(a.intensity), i.distance = a.distance, i.decay = a.decay, a.castShadow) { const t = a.shadow, i = e.get(a); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, n.pointShadow[d] = i, n.pointShadowMap[d] = S, n.pointShadowMatrix[d] = a.shadow.matrix, y++ } n.point[d] = i, d++ } else if (a.isHemisphereLight) { const e = t.get(a); e.direction.setFromMatrixPosition(a.matrixWorld), e.direction.transformDirection(_), e.direction.normalize(), e.skyColor.copy(a.color).multiplyScalar(b), e.groundColor.copy(a.groundColor).multiplyScalar(b), n.hemi[g] = e, g++ } } n.ambient[0] = l, n.ambient[1] = h, n.ambient[2] = u; const b = n.hash; b.directionalLength === p && b.pointLength === d && b.spotLength === f && b.rectAreaLength === m && b.hemiLength === g && b.numDirectionalShadows === v && b.numPointShadows === y && b.numSpotShadows === x || (n.directional.length = p, n.spot.length = f, n.rectArea.length = m, n.point.length = d, n.hemi.length = g, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = x, n.spotShadowMap.length = x, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotShadowMatrix.length = x, b.directionalLength = p, b.pointLength = d, b.spotLength = f, b.rectAreaLength = m, b.hemiLength = g, b.numDirectionalShadows = v, b.numPointShadows = y, b.numSpotShadows = x, n.version = $l++) }, state: n } } function nh() { const t = new eh, e = [], n = []; return { init: function () { e.length = 0, n.length = 0 }, state: { lightsArray: e, shadowsArray: n, lights: t }, setupLights: function (i) { t.setup(e, n, i) }, pushLight: function (t) { e.push(t) }, pushShadow: function (t) { n.push(t) } } } function ih() { let t = new WeakMap; function e(n) { const i = n.target; i.removeEventListener("dispose", e), t.delete(i) } return { get: function (n, i) { let r; return !1 === t.has(n) ? (r = new nh, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new nh, t.get(n).set(i, r)) : r = t.get(n).get(i), r }, dispose: function () { t = new WeakMap } } } function rh(t) { gr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = en, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } function oh(t) { gr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Xn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } rh.prototype = Object.create(gr.prototype), rh.prototype.constructor = rh, rh.prototype.isMeshDepthMaterial = !0, rh.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, oh.prototype = Object.create(gr.prototype), oh.prototype.constructor = oh, oh.prototype.isMeshDistanceMaterial = !0, oh.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }; var sh = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", ah = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function ch(t, e, n) { let i = new Ro; const r = new Nn, o = new Nn, s = new Hn, a = [], l = [], f = {}, m = { 0: p, 1: u, 2: d }, v = new xo({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Nn }, radius: { value: 4 } }, vertexShader: ah, fragmentShader: sh }), y = v.clone(); y.defines.HORIZONAL_PASS = 1; const x = new Gr; x.setAttribute("position", new _r(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const _ = new io(x, v), b = this; function w(n, i) { const r = e.update(_); v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, v, _, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, _, null) } function M(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = a[i]; return void 0 === r && (r = new rh({ depthPacking: nn, morphTargets: t, skinning: e }), a[i] = r), r } function S(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = l[i]; return void 0 === r && (r = new oh({ morphTargets: t, skinning: e }), l[i] = r), r } function T(e, n, i, r, o, s, a) { let c = null, l = M, u = e.customDepthMaterial; if (!0 === r.isPointLight && (l = S, u = e.customDistanceMaterial), void 0 === u) { let t = !1; !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0); let r = !1; !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), c = l(t, r, !0 === e.isInstancedMesh) } else c = u; if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { const t = c.uuid, e = i.uuid; let n = f[t]; void 0 === n && (n = {}, f[t] = n); let r = n[e]; void 0 === r && (r = c.clone(), n[e] = r), c = r } return c.visible = i.visible, c.wireframe = i.wireframe, c.side = a === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : m[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = o, c.farDistance = s), c } function E(n, r, o, s, a) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === h) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld); const i = e.update(n), r = n.material; if (Array.isArray(r)) { const e = i.groups; for (let c = 0, l = e.length; c < l; c++) { const l = e[c], h = r[l.materialIndex]; if (h && h.visible) { const e = T(n, i, h, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, l) } } } else if (r.visible) { const e = T(n, i, r, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, null) } } const c = n.children; for (let t = 0, e = c.length; t < e; t++)E(c[t], r, o, s, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = c, this.render = function (e, a, c) { if (!1 === b.enabled) return; if (!1 === b.autoUpdate && !1 === b.needsUpdate) return; if (0 === e.length) return; const l = t.getRenderTarget(), u = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), d = t.state; d.setBlending(g), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let f = 0, m = e.length; f < m; f++) { const l = e[f], u = l.shadow; if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue; if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", l, "has no shadow."); continue } r.copy(u.mapSize); const p = u.getFrameExtents(); if (r.multiply(p), o.copy(u.mapSize), (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / p.x), r.x = o.x * p.x, u.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / p.y), r.y = o.y * p.y, u.mapSize.y = o.y)), null === u.map && !u.isPointLightShadow && this.type === h) { const t = { minFilter: gt, magFilter: gt, format: Nt, stencilBuffer: !1 }; u.map = new kn(r.x, r.y, t), u.map.texture.name = l.name + ".shadowMap", u.mapPass = new kn(r.x, r.y, t), u.camera.updateProjectionMatrix() } if (null === u.map) { const t = { minFilter: ut, magFilter: ut, format: Nt, stencilBuffer: !1 }; u.map = new kn(r.x, r.y, t), u.map.texture.name = l.name + ".shadowMap", u.camera.updateProjectionMatrix() } t.setRenderTarget(u.map), t.clear(); const m = u.getViewportCount(); for (let t = 0; t < m; t++) { const e = u.getViewport(t); s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(s), u.updateMatrices(l, t), i = u.getFrustum(), E(a, c, u.camera, l, this.type) } u.isPointLightShadow || this.type !== h || w(u, c), u.needsUpdate = !1 } b.needsUpdate = !1, t.setRenderTarget(l, u, p) } } function lh(t, e, n) { const s = n.isWebGL2; const a = new function () { let e = !1; const n = new Hn; let i = null; const r = new Hn(0, 0, 0, 0); return { setMask: function (n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function (t) { e = t }, setClear: function (e, i, o, s, a) { !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n)) }, reset: function () { e = !1, i = null, r.set(-1, 0, 0, 0) } } }, c = new function () { let e = !1, n = null, i = null, r = null; return { setTest: function (t) { t ? ft(2929) : mt(2929) }, setMask: function (i) { n === i || e || (t.depthMask(i), n = i) }, setFunc: function (e) { if (i !== e) { if (e) switch (e) { case U: t.depthFunc(512); break; case G: t.depthFunc(519); break; case z: t.depthFunc(513); break; case H: t.depthFunc(515); break; case k: t.depthFunc(514); break; case V: t.depthFunc(518); break; case j: t.depthFunc(516); break; case W: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); i = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, n = null, i = null, r = null } } }, l = new function () { let e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null; return { setTest: function (t) { e || (t ? ft(2960) : mt(2960)) }, setMask: function (i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function (e, n, s) { i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s) }, setOp: function (e, n, i) { s === e && a === n && c === i || (t.stencilOp(e, n, i), s = e, a = n, c = i) }, setLocked: function (t) { e = t }, setClear: function (e) { l !== e && (t.clearStencil(e), l = e) }, reset: function () { e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null } } }; let h = {}, u = null, f = null, m = null, q = null, X = null, Y = null, Z = null, J = null, Q = null, K = !1, $ = null, tt = null, et = null, nt = null, it = null; const rt = t.getParameter(35661); let ot = !1, st = 0; const at = t.getParameter(7938); -1 !== at.indexOf("WebGL") ? (st = parseFloat(/^WebGL\ ([0-9])/.exec(at)[1]), ot = st >= 1) : -1 !== at.indexOf("OpenGL ES") && (st = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(at)[1]), ot = st >= 2); let ct = null, lt = {}; const ht = new Hn, ut = new Hn; function pt(e, n, i) { const r = new Uint8Array(4), o = t.createTexture(); t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let s = 0; s < i; s++)t.texImage2D(n + s, 0, 6408, 1, 1, 0, 6408, 5121, r); return o } const dt = {}; function ft(e) { !0 !== h[e] && (t.enable(e), h[e] = !0) } function mt(e) { !1 !== h[e] && (t.disable(e), h[e] = !1) } dt[3553] = pt(3553, 3553, 1), dt[34067] = pt(34067, 34069, 6), a.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), ft(2929), c.setFunc(H), xt(!1), _t(r), ft(2884), yt(g); const gt = { [w]: 32774, [M]: 32778, [S]: 32779 }; if (s) gt[T] = 32775, gt[E] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (gt[T] = t.MIN_EXT, gt[E] = t.MAX_EXT) } const vt = { [A]: 0, [L]: 1, [R]: 768, [P]: 770, [F]: 776, [N]: 774, [D]: 772, [C]: 769, [O]: 771, [B]: 775, [I]: 773 }; function yt(e, n, i, r, o, s, a, c) { if (e !== g) { if (f || (ft(3042), f = !0), e === b) o = o || n, s = s || i, a = a || r, n === q && o === Z || (t.blendEquationSeparate(gt[n], gt[o]), q = n, Z = o), i === X && r === Y && s === J && a === Q || (t.blendFuncSeparate(vt[i], vt[r], vt[s], vt[a]), X = i, Y = r, J = s, Q = a), m = e, K = null; else if (e !== m || c !== K) { if (q === w && Z === w || (t.blendEquation(32774), q = w, Z = w), c) switch (e) { case v: t.blendFuncSeparate(1, 771, 1, 771); break; case y: t.blendFunc(1, 1); break; case x: t.blendFuncSeparate(0, 0, 769, 771); break; case _: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case v: t.blendFuncSeparate(770, 771, 1, 771); break; case y: t.blendFunc(770, 1); break; case x: t.blendFunc(0, 769); break; case _: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }X = null, Y = null, J = null, Q = null, m = e, K = c } } else f && (mt(3042), f = !1) } function xt(e) { $ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), $ = e) } function _t(e) { e !== i ? (ft(2884), e !== tt && (e === r ? t.cullFace(1029) : e === o ? t.cullFace(1028) : t.cullFace(1032))) : mt(2884), tt = e } function bt(e, n, i) { e ? (ft(32823), nt === n && it === i || (t.polygonOffset(n, i), nt = n, it = i)) : mt(32823) } function wt(e) { void 0 === e && (e = 33984 + rt - 1), ct !== e && (t.activeTexture(e), ct = e) } return { buffers: { color: a, depth: c, stencil: l }, enable: ft, disable: mt, useProgram: function (e) { return u !== e && (t.useProgram(e), u = e, !0) }, setBlending: yt, setMaterial: function (t, e) { t.side === d ? mt(2884) : ft(2884); let n = t.side === p; e && (n = !n), xt(n), t.blending === v && !1 === t.transparent ? yt(g) : yt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), c.setFunc(t.depthFunc), c.setTest(t.depthTest), c.setMask(t.depthWrite), a.setMask(t.colorWrite); const i = t.stencilWrite; l.setTest(i), i && (l.setMask(t.stencilWriteMask), l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), bt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: xt, setCullFace: _t, setLineWidth: function (e) { e !== et && (ot && t.lineWidth(e), et = e) }, setPolygonOffset: bt, setScissorTest: function (t) { t ? ft(3089) : mt(3089) }, activeTexture: wt, bindTexture: function (e, n) { null === ct && wt(); let i = lt[ct]; void 0 === i && (i = { type: void 0, texture: void 0 }, lt[ct] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || dt[e]), i.type = e, i.texture = n) }, unbindTexture: function () { const e = lt[ct]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (e) { !1 === ht.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ht.copy(e)) }, viewport: function (e) { !1 === ut.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ut.copy(e)) }, reset: function () { h = {}, ct = null, lt = {}, u = null, m = null, $ = null, tt = null, a.reset(), c.reset(), l.reset() } } } function hh(t, e, n, i, r, o, s) { const a = r.isWebGL2, c = r.maxTextures, l = r.maxCubemapSize, h = r.maxTextureSize, u = r.maxSamples, p = new WeakMap; let d, f = !1; try { f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (G) { } function m(t, e) { return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(t, e, n, i) { let r = 1; if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const i = e ? In.floorPowerOfTwo : Math.floor, o = i(r * t.width), s = i(r * t.height); void 0 === d && (d = m(o, s)); const a = n ? m(o, s) : d; return a.width = o, a.height = s, a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function v(t) { return In.isPowerOfTwo(t.width) && In.isPowerOfTwo(t.height) } function y(t, e) { return t.generateMipmaps && e && t.minFilter !== ut && t.minFilter !== gt } function x(e, n, r, o) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E } function _(n, i, r) { if (!1 === a) return i; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let o = i; return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o } function b(t) { return t === ut || t === pt || t === ft ? 9728 : 9729 } function w(e) { const n = e.target; n.removeEventListener("dispose", w), function (e) { const n = i.get(e); if (void 0 === n.__webglInit) return; t.deleteTexture(n.__webglTexture), i.remove(e) }(n), n.isVideoTexture && p.delete(n), s.memory.textures-- } function M(e) { const n = e.target; n.removeEventListener("dispose", M), function (e) { const n = i.get(e), r = i.get(e.texture); if (!e) return; void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLCubeRenderTarget) for (let i = 0; i < 6; i++)t.deleteFramebuffer(n.__webglFramebuffer[i]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[i]); else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer); i.remove(e.texture), i.remove(e) }(n), s.memory.textures-- } let S = 0; function T(t, e) { const r = i.get(t); if (t.isVideoTexture && function (t) { const e = s.render.frame; p.get(t) !== e && (p.set(t, e), t.update()) }(t), t.version > 0 && r.__version !== t.version) { const n = t.image; if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== n.complete) return void O(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture) } function E(e, r) { if (6 !== e.image.length) return; const s = i.get(e); if (e.version > 0 && s.__version !== e.version) { P(s, e), n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY); const i = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), c = e.image[0] && e.image[0].isDataTexture, h = []; for (let t = 0; t < 6; t++)h[t] = i || c ? c ? e.image[t].image : e.image[t] : g(e.image[t], !1, !0, l); const u = h[0], p = v(u) || a, d = o.convert(e.format), f = o.convert(e.type), m = _(e.internalFormat, d, f); let b; if (C(34067, e, p), i) { for (let t = 0; t < 6; t++) { b = h[t].mipmaps; for (let i = 0; i < b.length; i++) { const r = b[i]; e.format !== Nt && e.format !== It ? null !== d ? n.compressedTexImage2D(34069 + t, i, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, i, m, r.width, r.height, 0, d, f, r.data) } } s.__maxMipLevel = b.length - 1 } else { b = e.mipmaps; for (let t = 0; t < 6; t++)if (c) { n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, d, f, h[t].data); for (let e = 0; e < b.length; e++) { const i = b[e].image[t].image; n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, d, f, i.data) } } else { n.texImage2D(34069 + t, 0, m, d, f, h[t]); for (let e = 0; e < b.length; e++) { const i = b[e]; n.texImage2D(34069 + t, e + 1, m, d, f, i.image[t]) } } s.__maxMipLevel = b.length } y(e, p) && x(34067, e, u.width, u.height), s.__version = e.version, e.onUpdate && e.onUpdate(e) } else n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture) } function A(t, e) { n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture) } const L = { [ct]: 10497, [lt]: 33071, [ht]: 33648 }, R = { [ut]: 9728, [pt]: 9984, [ft]: 9986, [gt]: 9729, [vt]: 9985, [xt]: 9987 }; function C(n, o, s) { s ? (t.texParameteri(n, 10242, L[o.wrapS]), t.texParameteri(n, 10243, L[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[o.wrapR]), t.texParameteri(n, 10240, R[o.magFilter]), t.texParameteri(n, 10241, R[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === lt && o.wrapT === lt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(o.magFilter)), t.texParameteri(n, 10241, b(o.minFilter)), o.minFilter !== ut && o.minFilter !== gt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); const c = e.get("EXT_texture_filter_anisotropic"); if (c) { if (o.type === At && null === e.get("OES_texture_float_linear")) return; if (o.type === Lt && null === (a || e.get("OES_texture_half_float_linear"))) return; (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy) } } function P(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), s.memory.textures++) } function O(e, i, r) { let s = 3553; i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), P(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment); const c = function (t) { return !a && (t.wrapS !== lt || t.wrapT !== lt || t.minFilter !== ut && t.minFilter !== gt) }(i) && !1 === v(i.image), l = g(i.image, c, !1, h), u = v(l) || a, p = o.convert(i.format); let d, f = o.convert(i.type), m = _(i.internalFormat, p, f); C(s, i, u); const b = i.mipmaps; if (i.isDepthTexture) m = 6402, a ? m = i.type === At ? 36012 : i.type === Et ? 33190 : i.type === Ot ? 35056 : 33189 : i.type === At && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Gt && 6402 === m && i.type !== St && i.type !== Et && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = St, f = o.convert(i.type)), i.format === zt && 6402 === m && (m = 34041, i.type !== Ot && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Ot, f = o.convert(i.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, p, f, null); else if (i.isDataTexture) if (b.length > 0 && u) { for (let t = 0, e = b.length; t < e; t++)d = b[t], n.texImage2D(3553, t, m, d.width, d.height, 0, p, f, d.data); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, l.width, l.height, 0, p, f, l.data), e.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let t = 0, e = b.length; t < e; t++)d = b[t], i.format !== Nt && i.format !== It ? null !== p ? n.compressedTexImage2D(3553, t, m, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, d.width, d.height, 0, p, f, d.data); e.__maxMipLevel = b.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, p, f, l.data), e.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, p, f, l.data), e.__maxMipLevel = 0; else if (b.length > 0 && u) { for (let t = 0, e = b.length; t < e; t++)d = b[t], n.texImage2D(3553, t, m, p, f, d); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, p, f, l), e.__maxMipLevel = 0; y(i, u) && x(s, i, l.width, l.height), e.__version = i.version, i.onUpdate && i.onUpdate(i) } function D(e, r, s, a) { const c = o.convert(r.texture.format), l = o.convert(r.texture.type), h = _(r.texture.internalFormat, c, l); n.texImage2D(a, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function I(e, n, i) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === At ? r = 36012 : e.type === Et && (r = 33190)); const i = B(n); t.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else t.renderbufferStorage(36161, r, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { if (i) { const e = B(n); t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height) } else t.renderbufferStorage(36161, 34041, n.width, n.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = o.convert(n.texture.format), r = o.convert(n.texture.type), s = _(n.texture.internalFormat, e, r); if (i) { const e = B(n); t.renderbufferStorageMultisample(36161, e, s, n.width, n.height) } else t.renderbufferStorage(36161, s, n.width, n.height) } t.bindRenderbuffer(36161, null) } function N(e) { const n = i.get(e), r = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture) { if (r) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, n) { if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), T(n.depthTexture, 0); const r = i.get(n.depthTexture).__webglTexture; if (n.depthTexture.format === Gt) t.framebufferTexture2D(36160, 36096, 3553, r, 0); else { if (n.depthTexture.format !== zt) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, r, 0) } }(n.__webglFramebuffer, e) } else if (r) { n.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), I(n.__webglDepthbuffer[i], e, !1) } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), I(n.__webglDepthbuffer, e, !1); t.bindFramebuffer(36160, null) } function B(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0 } let F = !1, U = !1; this.allocateTextureUnit = function () { const t = S; return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), S += 1, t }, this.resetTextureUnits = function () { S = 0 }, this.setTexture2D = T, this.setTexture2DArray = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? O(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? O(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = E, this.setTextureCubeDynamic = A, this.setupRenderTarget = function (e) { const r = i.get(e), c = i.get(e.texture); e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), s.memory.textures++; const l = !0 === e.isWebGLCubeRenderTarget, h = !0 === e.isWebGLMultisampleRenderTarget, u = v(e) || a; if (!a || e.texture.format !== It || e.texture.type !== At && e.texture.type !== Lt || (e.texture.format = Nt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) { r.__webglFramebuffer = []; for (let e = 0; e < 6; e++)r.__webglFramebuffer[e] = t.createFramebuffer() } else if (r.__webglFramebuffer = t.createFramebuffer(), h) if (a) { r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer); const n = o.convert(e.texture.format), i = o.convert(e.texture.type), s = _(e.texture.internalFormat, n, i), a = B(e); t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), I(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (l) { n.bindTexture(34067, c.__webglTexture), C(34067, e.texture, u); for (let t = 0; t < 6; t++)D(r.__webglFramebuffer[t], e, 36064, 34069 + t); y(e.texture, u) && x(34067, e.texture, e.width, e.height), n.bindTexture(34067, null) } else n.bindTexture(3553, c.__webglTexture), C(3553, e.texture, u), D(r.__webglFramebuffer, e, 36064, 3553), y(e.texture, u) && x(3553, e.texture, e.width, e.height), n.bindTexture(3553, null); e.depthBuffer && N(e) }, this.updateRenderTargetMipmap = function (t) { const e = t.texture; if (y(e, v(t) || a)) { const r = t.isWebGLCubeRenderTarget ? 34067 : 3553, o = i.get(e).__webglTexture; n.bindTexture(r, o), x(r, e, t.width, t.height), n.bindTexture(r, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (a) { const n = i.get(e); t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer); const r = e.width, o = e.height; let s = 16384; e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), T(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLCubeRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? E(t, e) : A(t, e) } } function uh(t, e, n) { const i = n.isWebGL2; return { convert: function (t) { let n; if (t === bt) return 5121; if (t === Rt) return 32819; if (t === Ct) return 32820; if (t === Pt) return 33635; if (t === wt) return 5120; if (t === Mt) return 5122; if (t === St) return 5123; if (t === Tt) return 5124; if (t === Et) return 5125; if (t === At) return 5126; if (t === Lt) return i ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null; if (t === Dt) return 6406; if (t === It) return 6407; if (t === Nt) return 6408; if (t === Bt) return 6409; if (t === Ft) return 6410; if (t === Gt) return 6402; if (t === zt) return 34041; if (t === Ht) return 6403; if (t === kt) return 36244; if (t === Vt) return 33319; if (t === jt) return 33320; if (t === Wt) return 36248; if (t === qt) return 36249; if (t === Xt || t === Yt || t === Zt || t === Jt) { if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null; if (t === Xt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === Yt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === Qt || t === Kt || t === $t || t === te) { if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null; if (t === Qt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === Kt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === $t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === te) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === ee) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === ne || t === ie) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) { if (t === ne) return n.COMPRESSED_RGB8_ETC2; if (t === ie) return n.COMPRESSED_RGBA8_ETC2_EAC } return t === re || t === oe || t === se || t === ae || t === ce || t === le || t === he || t === ue || t === pe || t === de || t === fe || t === me || t === ge || t === ve || t === xe || t === _e || t === be || t === we || t === Me || t === Se || t === Te || t === Ee || t === Ae || t === Le || t === Re || t === Ce || t === Pe || t === Oe ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : t === ye ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : t === Ot ? i ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function ph(t) { bo.call(this), this.cameras = t || [] } function dh() { xi.call(this), this.type = "Group" } function fh() { this._targetRay = null, this._grip = null, this._hand = null } function mh(t, e) { const n = this; let i = null, r = 1, o = null, s = "local-floor", a = null; const c = [], l = new Map, h = new bo; h.layers.enable(1), h.viewport = new Hn; const u = new bo; u.layers.enable(2), u.viewport = new Hn; const p = [h, u], d = new ph; d.layers.enable(1), d.layers.enable(2); let f = null, m = null; function g(t) { const e = l.get(t.inputSource); e && e.dispatchEvent({ type: t.type }) } function v() { l.forEach(function (t, e) { t.disconnect(e) }), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function y(t) { o = t, S.setContext(i), S.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } function x(t) { const e = i.inputSources; for (let n = 0; n < c.length; n++)l.set(e[n], c[n]); for (let n = 0; n < t.removed.length; n++) { const e = t.removed[n], i = l.get(e); i && (i.dispatchEvent({ type: "disconnected", data: e }), l.delete(e)) } for (let n = 0; n < t.added.length; n++) { const e = t.added[n], i = l.get(e); i && i.dispatchEvent({ type: "connected", data: e }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = c[t]; return void 0 === e && (e = new fh, c[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = c[t]; return void 0 === e && (e = new fh, c[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = c[t]; return void 0 === e && (e = new fh, c[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return i }, this.setSession = function (t) { if (null !== (i = t)) { i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v); const t = e.getContextAttributes(); !0 !== t.xrCompatible && e.makeXRCompatible(); const n = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r }, o = new XRWebGLLayer(i, e, n); i.updateRenderState({ baseLayer: o }), i.requestReferenceSpace(s).then(y), i.addEventListener("inputsourceschange", x) } }; const _ = new Xn, b = new Xn; function w(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } this.getCamera = function (t) { d.near = u.near = h.near = t.near, d.far = u.far = h.far = t.far, f === d.near && m === d.far || (i.updateRenderState({ depthNear: d.near, depthFar: d.far }), f = d.near, m = d.far); const e = t.parent, n = d.cameras; w(d, e); for (let i = 0; i < n.length; i++)w(n[i], e); t.matrixWorld.copy(d.matrixWorld); const r = t.children; for (let i = 0, o = r.length; i < o; i++)r[i].updateMatrixWorld(!0); return 2 === n.length ? function (t, e, n) { _.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld); const i = _.distanceTo(b), r = e.projectionMatrix.elements, o = n.projectionMatrix.elements, s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), c = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (o[8] + 1) / o[0], p = s * h, d = s * u, f = i / (-h + u), m = f * -h; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld); const g = s + f, v = a + f, y = p - m, x = d + (i - m), w = c * a / v * g, M = l * a / v * g; t.projectionMatrix.makePerspective(y, x, w, M, g, v) }(d, h, u) : d.projectionMatrix.copy(h.projectionMatrix), d }; let M = null; const S = new Po; S.setAnimationLoop(function (e, n) { if (null !== (a = n.getViewerPose(o))) { const e = a.views, n = i.renderState.baseLayer; t.setFramebuffer(n.framebuffer); let r = !1; e.length !== d.cameras.length && (d.cameras.length = 0, r = !0); for (let t = 0; t < e.length; t++) { const i = e[t], o = n.getViewport(i), s = p[t]; s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && d.matrix.copy(s.matrix), !0 === r && d.cameras.push(s) } } const r = i.inputSources; for (let t = 0; t < c.length; t++) { const e = c[t], i = r[t]; e.update(i, n, o) } M && M(e, n) }), this.setAnimationLoop = function (t) { M = t }, this.dispose = function () { } } function gh(t) { function e(e, n, i) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap); const r = n.envMap || i; if (r) { e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio; var o = t.get(r).__maxMipLevel; void 0 !== o && (e.maxMipLevel.value = o) } let s, a; n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? s = n.map : n.specularMap ? s = n.specularMap : n.displacementMap ? s = n.displacementMap : n.normalMap ? s = n.normalMap : n.bumpMap ? s = n.bumpMap : n.roughnessMap ? s = n.roughnessMap : n.metalnessMap ? s = n.metalnessMap : n.alphaMap ? s = n.alphaMap : n.emissiveMap && (s = n.emissiveMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), e.uv2Transform.value.copy(a.matrix)) } function n(t, e, n) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, i, r, o, s) { i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i, r), i.isMeshPhysicalMaterial ? function (t, e, i) { n(t, e, i), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === p && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap) }(t, i, r) : n(t, i, r)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) { e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) { let r; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(t, i, o, s) : i.isSpriteMaterial ? function (t, e) { let n; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function vh(t) { const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = void 0 !== t.context ? t.context : null, i = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, l = void 0 !== t.powerPreference ? t.powerPreference : "default", h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let u = null, p = null; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Xe, this.physicallyCorrectLights = !1, this.toneMapping = Z, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const d = this; let f = !1, m = null, g = 0, v = 0, y = null, x = null, _ = -1, b = null, w = null; const M = new Hn, S = new Hn; let T = null, E = e.width, A = e.height, L = 1, R = null, C = null; const P = new Hn(0, 0, E, A), O = new Hn(0, 0, E, A); let D = !1; const I = new Ro, N = new cc; let B = !1, F = !1; const U = new ei, G = new Xn, z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function H() { return null === y ? L : 1 } let k, V, j, W, q, X, Y, J, Q, K, $, tt, et, nt, it, rt, ot, st, at, ct = n; function lt(t, n) { for (let i = 0; i < t.length; i++) { const r = t[i], o = e.getContext(r, n); if (null !== o) return o } return null } try { const t = { alpha: i, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: h }; if (e.addEventListener("webglcontextlost", dt, !1), e.addEventListener("webglcontextrestored", ft, !1), null === ct) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === d.isWebGL1Renderer && e.shift(), null === (ct = lt(e, t))) throw lt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (St) { throw console.error("THREE.WebGLRenderer: " + St.message), St } function ht() { k = new lc(ct), !1 === (V = new ac(ct, k, t)).isWebGL2 && (k.get("WEBGL_depth_texture"), k.get("OES_texture_float"), k.get("OES_texture_half_float"), k.get("OES_texture_half_float_linear"), k.get("OES_standard_derivatives"), k.get("OES_element_index_uint"), k.get("OES_vertex_array_object"), k.get("ANGLE_instanced_arrays")), k.get("OES_texture_float_linear"), st = new uh(ct, k, V), (j = new lh(ct, k, V)).scissor(S.copy(O).multiplyScalar(L).floor()), j.viewport(M.copy(P).multiplyScalar(L).floor()), W = new pc(ct), q = new ql, X = new hh(ct, k, j, q, V, st, W), Y = new Oo(ct, V), at = new oc(ct, k, Y, V), J = new hc(ct, Y, W, at), Q = new gc(ct, J, Y, W), it = new mc(ct), K = new Wl(d, k, V, at), $ = new gh(q), tt = new Jl(q), et = new ih, nt = new rc(d, j, Q, a), rt = new sc(ct, k, W, V), ot = new uc(ct, k, W, V), W.programs = K.programs, d.capabilities = V, d.extensions = k, d.properties = q, d.renderLists = tt, d.state = j, d.info = W } ht(); const ut = new mh(d, ct); this.xr = ut; const pt = new ch(d, Q, V.maxTextureSize); function dt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0 } function ft() { console.log("THREE.WebGLRenderer: Context Restored."), f = !1, ht() } function mt(t) { const e = t.target; e.removeEventListener("dispose", mt), function (t) { gt(t), q.remove(t) }(e) } function gt(t) { const e = q.get(t).program; void 0 !== e && K.releaseProgram(e) } this.shadowMap = pt, this.getContext = function () { return ct }, this.getContextAttributes = function () { return ct.getContextAttributes() }, this.forceContextLoss = function () { const t = k.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = k.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return L }, this.setPixelRatio = function (t) { void 0 !== t && (L = t, this.setSize(E, A, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Nn), t.set(E, A) }, this.setSize = function (t, n, i) { ut.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, A = n, e.width = Math.floor(t * L), e.height = Math.floor(n * L), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Nn), t.set(E * L, A * L).floor() }, this.setDrawingBufferSize = function (t, n, i) { E = t, A = n, L = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Hn), t.copy(M) }, this.getViewport = function (t) { return t.copy(P) }, this.setViewport = function (t, e, n, i) { t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i), j.viewport(M.copy(P).multiplyScalar(L).floor()) }, this.getScissor = function (t) { return t.copy(O) }, this.setScissor = function (t, e, n, i) { t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), j.scissor(S.copy(O).multiplyScalar(L).floor()) }, this.getScissorTest = function () { return D }, this.setScissorTest = function (t) { j.setScissorTest(D = t) }, this.setOpaqueSort = function (t) { R = t }, this.setTransparentSort = function (t) { C = t }, this.getClearColor = function () { return nt.getClearColor() }, this.setClearColor = function () { nt.setClearColor.apply(nt, arguments) }, this.getClearAlpha = function () { return nt.getClearAlpha() }, this.setClearAlpha = function () { nt.setClearAlpha.apply(nt, arguments) }, this.clear = function (t, e, n) { let i = 0; (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ct.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", dt, !1), e.removeEventListener("webglcontextrestored", ft, !1), tt.dispose(), et.dispose(), q.dispose(), Q.dispose(), at.dispose(), ut.dispose(), yt.stop() }, this.renderBufferImmediate = function (t, e) { at.initAttributes(); const n = q.get(t); t.hasPositions && !n.position && (n.position = ct.createBuffer()), t.hasNormals && !n.normal && (n.normal = ct.createBuffer()), t.hasUvs && !n.uv && (n.uv = ct.createBuffer()), t.hasColors && !n.color && (n.color = ct.createBuffer()); const i = e.getAttributes(); t.hasPositions && (ct.bindBuffer(34962, n.position), ct.bufferData(34962, t.positionArray, 35048), at.enableAttribute(i.position), ct.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ct.bindBuffer(34962, n.normal), ct.bufferData(34962, t.normalArray, 35048), at.enableAttribute(i.normal), ct.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ct.bindBuffer(34962, n.uv), ct.bufferData(34962, t.uvArray, 35048), at.enableAttribute(i.uv), ct.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ct.bindBuffer(34962, n.color), ct.bufferData(34962, t.colorArray, 35048), at.enableAttribute(i.color), ct.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), at.disableUnusedAttributes(), ct.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, i, r, o) { null === e && (e = z); const s = r.isMesh && r.matrixWorld.determinant() < 0, a = Mt(t, e, i, r); j.setMaterial(i, s); let c = n.index; const l = n.attributes.position; if (null === c) { if (void 0 === l || 0 === l.count) return } else if (0 === c.count) return; let h, u = 1; !0 === i.wireframe && (c = J.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && it.update(r, n, i, a), at.setup(r, i, a, n, c); let p = rt; null !== c && (h = Y.get(c), (p = ot).setIndex(h)); const d = null !== c ? c.count : l.count, f = n.drawRange.start * u, m = n.drawRange.count * u, g = null !== o ? o.start * u : 0, v = null !== o ? o.count * u : 1 / 0, y = Math.max(f, g), x = Math.min(d, f + m, g + v) - 1, _ = Math.max(0, x - y + 1); if (0 !== _) { if (r.isMesh) !0 === i.wireframe ? (j.setLineWidth(i.wireframeLinewidth * H()), p.setMode(1)) : p.setMode(4); else if (r.isLine) { let t = i.linewidth; void 0 === t && (t = 1), j.setLineWidth(t * H()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3) } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4); if (r.isInstancedMesh) p.renderInstances(y, _, r.count); else if (n.isInstancedBufferGeometry) { const t = Math.min(n.instanceCount, n._maxInstanceCount); p.renderInstances(y, _, t) } else p.render(y, _) } }, this.compile = function (t, e) { (p = et.get(t, e)).init(), t.traverse(function (t) { t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t)) }), p.setupLights(e); const n = new WeakMap; t.traverse(function (e) { let i = e.material; if (i) if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { let o = i[r]; !1 === n.has(o) && (wt(o, t, e), n.set(o)) } else !1 === n.has(i) && (wt(i, t, e), n.set(i)) }) }; let vt = null; const yt = new Po; function xt(t, e, n) { const i = !0 === e.isScene ? e.overrideMaterial : null; for (let r = 0, o = t.length; r < o; r++) { const o = t[r], s = o.object, a = o.geometry, c = null === i ? o.material : i, l = o.group; if (n.isArrayCamera) { w = n; const t = n.cameras; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; s.layers.test(i.layers) && (j.viewport(M.copy(i.viewport)), p.setupLights(i), _t(s, e, i, a, c, l)) } } else w = null, _t(s, e, n, a, c, l) } } function _t(t, e, n, i, r, o) { if (t.onBeforeRender(d, e, n, i, r, o), p = et.get(e, w || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { const i = Mt(n, e, r, t); j.setMaterial(r), at.reset(), function (t, e) { t.render(function (t) { d.renderBufferImmediate(t, e) }) }(t, i) } else d.renderBufferDirect(n, e, i, r, t, o); t.onAfterRender(d, e, n, i, r, o), p = et.get(e, w || n) } function wt(t, e, n) { !0 !== e.isScene && (e = z); const i = q.get(t), r = p.state.lights, o = p.state.shadowsArray, s = r.state.version, a = K.getParameters(t, r.state, o, e, N.numPlanes, N.numIntersection, n), c = K.getProgramCacheKey(a); let l = i.program, h = !0; if (void 0 === l) t.addEventListener("dispose", mt); else if (l.cacheKey !== c) gt(t); else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, h = !1; else { if (void 0 !== a.shaderID) return; h = !1 } h && (a.uniforms = K.getUniforms(t, a), t.onBeforeCompile(a, d), l = K.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding); const u = l.getAttributes(); if (t.morphTargets) { t.numSupportedMorphTargets = 0; for (let e = 0; e < d.maxMorphTargets; e++)u["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++ } if (t.morphNormals) { t.numSupportedMorphNormals = 0; for (let e = 0; e < d.maxMorphNormals; e++)u["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++ } const f = i.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = N.numPlanes, i.numIntersection = N.numIntersection, f.clippingPlanes = N.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = s, i.needsLights && (f.ambientLightColor.value = r.state.ambient, f.lightProbe.value = r.state.probe, f.directionalLights.value = r.state.directional, f.directionalLightShadows.value = r.state.directionalShadow, f.spotLights.value = r.state.spot, f.spotLightShadows.value = r.state.spotShadow, f.rectAreaLights.value = r.state.rectArea, f.pointLights.value = r.state.point, f.pointLightShadows.value = r.state.pointShadow, f.hemisphereLights.value = r.state.hemi, f.directionalShadowMap.value = r.state.directionalShadowMap, f.directionalShadowMatrix.value = r.state.directionalShadowMatrix, f.spotShadowMap.value = r.state.spotShadowMap, f.spotShadowMatrix.value = r.state.spotShadowMatrix, f.pointShadowMap.value = r.state.pointShadowMap, f.pointShadowMatrix.value = r.state.pointShadowMatrix); const m = i.program.getUniforms(), g = gl.seqWithValue(m.seq, f); i.uniformsList = g } function Mt(t, e, n, i) { !0 !== e.isScene && (e = z), X.resetTextureUnits(); const r = e.fog, o = n.isMeshStandardMaterial ? e.environment : null, s = null === y ? d.outputEncoding : y.texture.encoding, a = q.get(n), c = p.state.lights; if (!0 === B && (!0 === F || t !== b)) { const e = t === b && n.id === _; N.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, a, e) } n.version === a.__version ? void 0 === a.program ? wt(n, e, i) : n.fog && a.fog !== r ? wt(n, e, i) : a.environment !== o ? wt(n, e, i) : a.needsLights && a.lightsStateVersion !== c.state.version ? wt(n, e, i) : void 0 === a.numClippingPlanes || a.numClippingPlanes === N.numPlanes && a.numIntersection === N.numIntersection ? a.outputEncoding !== s && wt(n, e, i) : wt(n, e, i) : (wt(n, e, i), a.__version = n.version); let l = !1, h = !1, u = !1; const f = a.program, m = f.getUniforms(), g = a.uniforms; if (j.useProgram(f.program) && (l = !0, h = !0, u = !0), n.id !== _ && (_ = n.id, h = !0), l || b !== t) { if (m.setValue(ct, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && m.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, h = !0, u = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const e = m.map.cameraPosition; void 0 !== e && e.setValue(ct, G.setFromMatrixPosition(t.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && m.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && m.setValue(ct, "viewMatrix", t.matrixWorldInverse) } if (n.skinning) { m.setOptional(ct, i, "bindMatrix"), m.setOptional(ct, i, "bindMatrixInverse"); const t = i.skeleton; if (t) { const e = t.bones; if (V.floatVertexTextures) { if (void 0 === t.boneTexture) { let n = Math.sqrt(4 * e.length); n = In.ceilPowerOfTwo(n), n = Math.max(n, 4); const i = new Float32Array(n * n * 4); i.set(t.boneMatrices); const r = new Eo(i, n, n, Nt, At); t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n } m.setValue(ct, "boneTexture", t.boneTexture, X), m.setValue(ct, "boneTextureSize", t.boneTextureSize) } else m.setOptional(ct, t, "boneMatrices") } } var v, x; return (h || a.receiveShadow !== i.receiveShadow) && (a.receiveShadow = i.receiveShadow, m.setValue(ct, "receiveShadow", i.receiveShadow)), h && (m.setValue(ct, "toneMappingExposure", d.toneMappingExposure), a.needsLights && (x = u, (v = g).ambientLightColor.needsUpdate = x, v.lightProbe.needsUpdate = x, v.directionalLights.needsUpdate = x, v.directionalLightShadows.needsUpdate = x, v.pointLights.needsUpdate = x, v.pointLightShadows.needsUpdate = x, v.spotLights.needsUpdate = x, v.spotLightShadows.needsUpdate = x, v.rectAreaLights.needsUpdate = x, v.hemisphereLights.needsUpdate = x), r && n.fog && $.refreshFogUniforms(g, r), $.refreshMaterialUniforms(g, n, o, L, A), void 0 !== g.ltc_1 && (g.ltc_1.value = Co.LTC_1), void 0 !== g.ltc_2 && (g.ltc_2.value = Co.LTC_2), gl.upload(ct, a.uniformsList, g, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (gl.upload(ct, a.uniformsList, g, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && m.setValue(ct, "center", i.center), m.setValue(ct, "modelViewMatrix", i.modelViewMatrix), m.setValue(ct, "normalMatrix", i.normalMatrix), m.setValue(ct, "modelMatrix", i.matrixWorld), f } yt.setAnimationLoop(function (t) { ut.isPresenting || vt && vt(t) }), "undefined" != typeof window && yt.setContext(window), this.setAnimationLoop = function (t) { vt = t, ut.setAnimationLoop(t), null === t ? yt.stop() : yt.start() }, this.render = function (t, e) { let n, i; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === f) return; at.resetDefaultState(), _ = -1, b = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ut.enabled && !0 === ut.isPresenting && (e = ut.getCamera(e)), !0 === t.isScene && t.onBeforeRender(d, t, e, n || y), (p = et.get(t, e)).init(), U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), I.setFromProjectionMatrix(U), F = this.localClippingEnabled, B = N.init(this.clippingPlanes, F, e), (u = tt.get(t, e)).init(), function t(e, n, i, r) { if (!1 === e.visible) return; const o = e.layers.test(n.layers); if (o) if (e.isGroup) i = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(n); else if (e.isLight) p.pushLight(e), e.castShadow && p.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || I.intersectsSprite(e)) { r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U); const t = Q.update(e), n = e.material; n.visible && u.push(e, t, n, i, G.z, null) } } else if (e.isImmediateRenderObject) r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U), u.push(e, null, e.material, i, G.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== W.render.frame && (e.skeleton.update(), e.skeleton.frame = W.render.frame), !e.frustumCulled || I.intersectsObject(e))) { r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U); const t = Q.update(e), n = e.material; if (Array.isArray(n)) { const r = t.groups; for (let o = 0, s = r.length; o < s; o++) { const s = r[o], a = n[s.materialIndex]; a && a.visible && u.push(e, t, a, i, G.z, s) } } else n.visible && u.push(e, t, n, i, G.z, null) } const s = e.children; for (let a = 0, c = s.length; a < c; a++)t(s[a], n, i, r) }(t, e, 0, d.sortObjects), u.finish(), !0 === d.sortObjects && u.sort(R, C), !0 === B && N.beginShadows(); const r = p.state.shadowsArray; pt.render(r, t, e), p.setupLights(e), !0 === B && N.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), nt.render(u, t, e, i); const o = u.opaque, s = u.transparent; o.length > 0 && xt(o, t, e), s.length > 0 && xt(s, t, e), !0 === t.isScene && t.onAfterRender(d, t, e), null !== y && (X.updateRenderTargetMipmap(y), X.updateMultisampleRenderTarget(y)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), u = null, p = null }, this.setFramebuffer = function (t) { m !== t && null === y && ct.bindFramebuffer(36160, t), m = t }, this.getActiveCubeFace = function () { return g }, this.getActiveMipmapLevel = function () { return v }, this.getRenderTarget = function () { return y }, this.setRenderTarget = function (t, e, n) { y = t, g = e, v = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t); let i = m, r = !1; if (t) { const n = q.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (i = n[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), S.copy(t.scissor), T = t.scissorTest } else M.copy(P).multiplyScalar(L).floor(), S.copy(O).multiplyScalar(L).floor(), T = D; if (x !== i && (ct.bindFramebuffer(36160, i), x = i), j.viewport(M), j.scissor(S), j.setScissorTest(T), r) { const i = q.get(t.texture); ct.framebufferTexture2D(36160, 36064, 34069 + (e || 0), i.__webglTexture, n || 0) } }, this.readRenderTargetPixels = function (t, e, n, i, r, o, s) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = q.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) { let s = !1; a !== x && (ct.bindFramebuffer(36160, a), s = !0); try { const a = t.texture, c = a.format, l = a.type; if (c !== Nt && st.convert(c) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(l === bt || st.convert(l) === ct.getParameter(35738) || l === At && (V.isWebGL2 || k.get("OES_texture_float") || k.get("WEBGL_color_buffer_float")) || l === Lt && (V.isWebGL2 ? k.get("EXT_color_buffer_float") : k.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === ct.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ct.readPixels(e, n, i, r, st.convert(c), st.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && ct.bindFramebuffer(36160, x) } } }, this.copyFramebufferToTexture = function (t, e, n) { void 0 === n && (n = 0); const i = Math.pow(2, -n), r = Math.floor(e.image.width * i), o = Math.floor(e.image.height * i), s = st.convert(e.format); X.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), j.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, i) { void 0 === i && (i = 0); const r = e.image.width, o = e.image.height, s = st.convert(n.format), a = st.convert(n.type); X.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : ct.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && ct.generateMipmap(3553), j.unbindTexture() }, this.initTexture = function (t) { X.setTexture2D(t, 0), j.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function yh(t) { vh.call(this, t) } function xh(t, e) { this.name = "", this.color = new hr(t), this.density = void 0 !== e ? e : 25e-5 } function _h(t, e, n) { this.name = "", this.color = new hr(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 } function bh(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = wn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = In.generateUUID() } ph.prototype = Object.assign(Object.create(bo.prototype), { constructor: ph, isArrayCamera: !0 }), dh.prototype = Object.assign(Object.create(xi.prototype), { constructor: dh, isGroup: !0 }), Object.assign(fh.prototype, { constructor: fh, getHandSpace: function () { if (null === this._hand && (this._hand = new dh, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand)) for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) { let t = new dh; t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t) } return this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new dh, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new dh, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }, disconnect: function (t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (t, e, n) { let i = null, r = null, o = null; const s = this._targetRay, a = this._grip, c = this._hand; if (t) if (t.hand) { o = !0; for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)if (t.hand[i]) { let r = e.getJointPose(t.hand[i], n); const o = c.joints[i]; null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = r.radius), o.visible = null !== r; const s = c.joints[window.XRHand.INDEX_PHALANX_TIP], a = c.joints[window.XRHand.THUMB_PHALANX_TIP], l = s.position.distanceTo(a.position), h = .02, u = .005; c.inputState.pinching && l > h + u ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && l <= h - u && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } } else null !== s && null !== (i = e.getPose(t.targetRaySpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)), null !== a && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)); return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== c && (c.visible = null !== o), this } }), Object.assign(mh.prototype, Pn.prototype), yh.prototype = Object.assign(Object.create(vh.prototype), { constructor: yh, isWebGL1Renderer: !0 }), Object.assign(xh.prototype, { isFogExp2: !0, clone: function () { return new xh(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(_h.prototype, { isFog: !0, clone: function () { return new _h(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Object.defineProperty(bh.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(bh.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function (t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = In.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new bh(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride); return e.setUsage(this.usage), e }, onUpload: function (t) { return this.onUploadCallback = t, this }, toJSON: function (t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = In.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); const wh = new Xn; function Mh(t, e, n, i) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i } function Sh(t) { gr.call(this), this.type = "SpriteMaterial", this.color = new hr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) } let Th; Object.defineProperties(Mh.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (t) { this.data.needsUpdate = t } } }), Object.assign(Mh.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (t) { for (let e = 0, n = this.data.count; e < n; e++)wh.x = this.getX(e), wh.y = this.getY(e), wh.z = this.getZ(e), wh.applyMatrix4(t), this.setXYZ(e, wh.x, wh.y, wh.z); return this }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }, clone: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new _r(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Mh(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }), Sh.prototype = Object.create(gr.prototype), Sh.prototype.constructor = Sh, Sh.prototype.isSpriteMaterial = !0, Sh.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }; const Eh = new Xn, Ah = new Xn, Lh = new Xn, Rh = new Nn, Ch = new Nn, Ph = new ei, Oh = new Xn, Dh = new Xn, Ih = new Xn, Nh = new Nn, Bh = new Nn, Fh = new Nn; function Uh(t) { if (xi.call(this), this.type = "Sprite", void 0 === Th) { Th = new Gr; const t = new bh(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); Th.setIndex([0, 1, 2, 0, 2, 3]), Th.setAttribute("position", new Mh(t, 3, 0, !1)), Th.setAttribute("uv", new Mh(t, 2, 3, !1)) } this.geometry = Th, this.material = void 0 !== t ? t : new Sh, this.center = new Nn(.5, .5) } function Gh(t, e, n, i, r, o) { Rh.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Ch.x = o * Rh.x - r * Rh.y, Ch.y = r * Rh.x + o * Rh.y) : Ch.copy(Rh), t.copy(e), t.x += Ch.x, t.y += Ch.y, t.applyMatrix4(Ph) } Uh.prototype = Object.assign(Object.create(xi.prototype), { constructor: Uh, isSprite: !0, raycast: function (t, e) { null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ah.setFromMatrixScale(this.matrixWorld), Ph.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Lh.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ah.multiplyScalar(-Lh.z); const n = this.material.rotation; let i, r; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); const o = this.center; Gh(Oh.set(-.5, -.5, 0), Lh, o, Ah, i, r), Gh(Dh.set(.5, -.5, 0), Lh, o, Ah, i, r), Gh(Ih.set(.5, .5, 0), Lh, o, Ah, i, r), Nh.set(0, 0), Bh.set(1, 0), Fh.set(1, 1); let s = t.ray.intersectTriangle(Oh, Dh, Ih, !1, Eh); if (null === s && (Gh(Dh.set(-.5, .5, 0), Lh, o, Ah, i, r), Bh.set(0, 1), null === (s = t.ray.intersectTriangle(Oh, Ih, Dh, !1, Eh)))) return; const a = t.ray.origin.distanceTo(Eh); a < t.near || a > t.far || e.push({ distance: a, point: Eh.clone(), uv: sr.getUV(Eh, Oh, Dh, Ih, Nh, Bh, Fh, new Nn), face: null, object: this }) }, copy: function (t) { return xi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this } }); const zh = new Xn, Hh = new Xn; function kh() { xi.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } function Vh(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), io.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ei, this.bindMatrixInverse = new ei } kh.prototype = Object.assign(Object.create(xi.prototype), { constructor: kh, isLOD: !0, copy: function (t) { xi.prototype.copy.call(this, t, !1); const e = t.levels; for (let n = 0, i = e.length; n < i; n++) { const t = e[n]; this.addLevel(t.object.clone(), t.distance) } return this.autoUpdate = t.autoUpdate, this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); const n = this.levels; let i; for (i = 0; i < n.length && !(e < n[i].distance); i++); return n.splice(i, 0, { distance: e, object: t }), this.add(t), this }, getCurrentLevel: function () { return this._currentLevel }, getObjectForDistance: function (t) { const e = this.levels; if (e.length > 0) { let n, i; for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object } return null }, raycast: function (t, e) { if (this.levels.length > 0) { zh.setFromMatrixPosition(this.matrixWorld); const n = t.ray.origin.distanceTo(zh); this.getObjectForDistance(n).raycast(t, e) } }, update: function (t) { const e = this.levels; if (e.length > 1) { zh.setFromMatrixPosition(t.matrixWorld), Hh.setFromMatrixPosition(this.matrixWorld); const n = zh.distanceTo(Hh) / t.zoom; let i, r; for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++)e[i - 1].object.visible = !1, e[i].object.visible = !0; for (this._currentLevel = i - 1; i < r; i++)e[i].object.visible = !1 } }, toJSON: function (t) { const e = xi.prototype.toJSON.call(this, t); !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = []; const n = this.levels; for (let i = 0, r = n.length; i < r; i++) { const t = n[i]; e.object.levels.push({ object: t.object.uuid, distance: t.distance }) } return e } }), Vh.prototype = Object.assign(Object.create(io.prototype), { constructor: Vh, isSkinnedMesh: !0, copy: function (t) { return io.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { const t = new Hn, e = this.geometry.attributes.skinWeight; for (let n = 0, i = e.count; n < i; n++) { t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n); const i = 1 / t.manhattanLength(); i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { io.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: function () { const t = new Xn, e = new Hn, n = new Hn, i = new Xn, r = new ei; return function (o, s) { const a = this.skeleton, c = this.geometry; e.fromBufferAttribute(c.attributes.skinIndex, o), n.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0); for (let l = 0; l < 4; l++) { const o = n.getComponent(l); if (0 !== o) { const n = e.getComponent(l); r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), s.addScaledVector(i.copy(t).applyMatrix4(r), o) } } return s.applyMatrix4(this.bindMatrixInverse) } }() }); const jh = new ei, Wh = new ei; function qh(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new ei) } } function Xh() { xi.call(this), this.type = "Bone" } Object.assign(qh.prototype, { calculateInverses: function () { this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new ei; this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e) } }, pose: function () { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.getInverse(this.boneInverses[t]) } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } }, update: function () { const t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let r = 0, o = t.length; r < o; r++) { const i = t[r] ? t[r].matrixWorld : Wh; jh.multiplyMatrices(i, e[r]), jh.toArray(n, 16 * r) } void 0 !== i && (i.needsUpdate = !0) }, clone: function () { return new qh(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } }, dispose: function () { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) } }), Xh.prototype = Object.assign(Object.create(xi.prototype), { constructor: Xh, isBone: !0 }); const Yh = new ei, Zh = new ei, Jh = [], Qh = new io; function Kh(t, e, n) { io.call(this, t, e), this.instanceMatrix = new _r(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1 } function $h(t) { gr.call(this), this.type = "LineBasicMaterial", this.color = new hr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) } Kh.prototype = Object.assign(Object.create(io.prototype), { constructor: Kh, isInstancedMesh: !0, copy: function (t) { return io.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this }, getMatrixAt: function (t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }, raycast: function (t, e) { const n = this.matrixWorld, i = this.count; if (Qh.geometry = this.geometry, Qh.material = this.material, void 0 !== Qh.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, Yh), Zh.multiplyMatrices(n, Yh), Qh.matrixWorld = Zh, Qh.raycast(t, Jh); for (let t = 0, n = Jh.length; t < n; t++) { const n = Jh[t]; n.instanceId = r, n.object = this, e.push(n) } Jh.length = 0 } }, setMatrixAt: function (t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }, updateMorphTargets: function () { } }), $h.prototype = Object.create(gr.prototype), $h.prototype.constructor = $h, $h.prototype.isLineBasicMaterial = !0, $h.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }; const tu = new Xn, eu = new Xn, nu = new ei, iu = new Wi, ru = new Fi; function ou(t, e, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), xi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new $h, this.updateMorphTargets() } ou.prototype = Object.assign(Object.create(xi.prototype), { constructor: ou, isLine: !0, copy: function (t) { return xi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = [0]; for (let t = 1, i = e.count; t < i; t++)tu.fromBufferAttribute(e, t - 1), eu.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += tu.distanceTo(eu); t.setAttribute("lineDistance", new Lr(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, n = t.lineDistances; n[0] = 0; for (let t = 1, i = e.length; t < i; t++)n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t]) } return this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Line.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), ru.copy(n.boundingSphere), ru.applyMatrix4(i), ru.radius += r, !1 === t.ray.intersectsSphere(ru)) return; nu.getInverse(i), iu.copy(t.ray).applyMatrix4(nu); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, a = new Xn, c = new Xn, l = new Xn, h = new Xn, u = this && this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const i = n.index, r = n.attributes.position.array; if (null !== i) { const n = i.array; for (let i = 0, o = n.length - 1; i < o; i += u) { const o = n[i], u = n[i + 1]; if (a.fromArray(r, 3 * o), c.fromArray(r, 3 * u), iu.distanceSqToSegment(a, c, h, l) > s) continue; h.applyMatrix4(this.matrixWorld); const p = t.ray.origin.distanceTo(h); p < t.near || p > t.far || e.push({ distance: p, point: l.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this }) } } else for (let n = 0, o = r.length / 3 - 1; n < o; n += u) { if (a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3), iu.distanceSqToSegment(a, c, h, l) > s) continue; h.applyMatrix4(this.matrixWorld); const i = t.ray.origin.distanceTo(h); i < t.near || i > t.far || e.push({ distance: i, point: l.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else if (n.isGeometry) { const i = n.vertices, r = i.length; for (let n = 0; n < r - 1; n += u) { if (iu.distanceSqToSegment(i[n], i[n + 1], h, l) > s) continue; h.applyMatrix4(this.matrixWorld); const r = t.ray.origin.distanceTo(h); r < t.near || r > t.far || e.push({ distance: r, point: l.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); const su = new Xn, au = new Xn; function cu(t, e) { ou.call(this, t, e), this.type = "LineSegments" } function lu(t, e) { ou.call(this, t, e), this.type = "LineLoop" } function hu(t) { gr.call(this), this.type = "PointsMaterial", this.color = new hr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } cu.prototype = Object.assign(Object.create(ou.prototype), { constructor: cu, isLineSegments: !0, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = []; for (let t = 0, i = e.count; t < i; t += 2)su.fromBufferAttribute(e, t), au.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + su.distanceTo(au); t.setAttribute("lineDistance", new Lr(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, n = t.lineDistances; for (let t = 0, i = e.length; t < i; t += 2)su.copy(e[t]), au.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + su.distanceTo(au) } return this } }), lu.prototype = Object.assign(Object.create(ou.prototype), { constructor: lu, isLineLoop: !0 }), hu.prototype = Object.create(gr.prototype), hu.prototype.constructor = hu, hu.prototype.isPointsMaterial = !0, hu.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }; const uu = new ei, pu = new Wi, du = new Fi, fu = new Xn; function mu(t, e) { xi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new hu, this.updateMorphTargets() } function gu(t, e, n, i, r, o, s) { const a = pu.distanceSqToPoint(t); if (a < n) { const n = new Xn; pu.closestPointToPoint(t, n), n.applyMatrix4(i); const c = r.ray.origin.distanceTo(n); if (c < r.near || c > r.far) return; o.push({ distance: c, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: s }) } } function vu(t, e, n, i, r, o, s, a, c) { zn.call(this, t, e, n, i, r, o, s, a, c), this.format = void 0 !== s ? s : It, this.minFilter = void 0 !== o ? o : gt, this.magFilter = void 0 !== r ? r : gt, this.generateMipmaps = !1; const l = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() { l.needsUpdate = !0, t.requestVideoFrameCallback(e) }) } function yu(t, e, n, i, r, o, s, a, c, l, h, u) { zn.call(this, null, o, s, a, c, l, i, r, h, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function xu(t, e, n, i, r, o, s, a, c) { zn.call(this, t, e, n, i, r, o, s, a, c), this.needsUpdate = !0 } function _u(t, e, n, i, r, o, s, a, c, l) { if ((l = void 0 !== l ? l : Gt) !== Gt && l !== zt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && l === Gt && (n = St), void 0 === n && l === zt && (n = Ot), zn.call(this, null, i, r, o, s, a, l, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== s ? s : ut, this.minFilter = void 0 !== a ? a : ut, this.flipY = !1, this.generateMipmaps = !1 } function bu(t) { Gr.call(this), this.type = "WireframeGeometry"; const e = [], n = [0, 0], i = {}, r = ["a", "b", "c"]; if (t && t.isGeometry) { const o = t.faces; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; for (let t = 0; t < 3; t++) { const o = e[r[t]], s = e[r[(t + 1) % 3]]; n[0] = Math.min(o, s), n[1] = Math.max(o, s); const a = n[0] + "," + n[1]; void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] }) } } for (const n in i) { const r = i[n]; let o = t.vertices[r.index1]; e.push(o.x, o.y, o.z), o = t.vertices[r.index2], e.push(o.x, o.y, o.z) } } else if (t && t.isBufferGeometry) { let r = new Xn; if (null !== t.index) { const o = t.attributes.position, s = t.index; let a = t.groups; 0 === a.length && (a = [{ start: 0, count: s.count, materialIndex: 0 }]); for (let t = 0, e = a.length; t < e; ++t) { const e = a[t], r = e.start; for (let t = r, o = r + e.count; t < o; t += 3)for (let e = 0; e < 3; e++) { const r = s.getX(t + e), o = s.getX(t + (e + 1) % 3); n[0] = Math.min(r, o), n[1] = Math.max(r, o); const a = n[0] + "," + n[1]; void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] }) } } for (const t in i) { const n = i[t]; r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z) } } else { const n = t.attributes.position; for (let t = 0, i = n.count / 3; t < i; t++)for (let o = 0; o < 3; o++) { const i = 3 * t + o; r.fromBufferAttribute(n, i), e.push(r.x, r.y, r.z); const s = 3 * t + (o + 1) % 3; r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z) } } } this.setAttribute("position", new Lr(e, 3)) } function wu(t, e, n) { ho.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new Mu(t, e, n)), this.mergeVertices() } function Mu(t, e, n) { Gr.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: n }; const i = [], r = [], o = [], s = [], a = new Xn, c = new Xn, l = new Xn, h = new Xn, u = new Xn; t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); const p = e + 1; for (let d = 0; d <= n; d++) { const i = d / n; for (let n = 0; n <= e; n++) { const p = n / e; t(p, i, c), r.push(c.x, c.y, c.z), p - 1e-5 >= 0 ? (t(p - 1e-5, i, l), h.subVectors(c, l)) : (t(p + 1e-5, i, l), h.subVectors(l, c)), i - 1e-5 >= 0 ? (t(p, i - 1e-5, l), u.subVectors(c, l)) : (t(p, i + 1e-5, l), u.subVectors(l, c)), a.crossVectors(h, u).normalize(), o.push(a.x, a.y, a.z), s.push(p, i) } } for (let d = 0; d < n; d++)for (let t = 0; t < e; t++) { const e = d * p + t, n = d * p + t + 1, r = (d + 1) * p + t + 1, o = (d + 1) * p + t; i.push(e, n, o), i.push(n, r, o) } this.setIndex(i), this.setAttribute("position", new Lr(r, 3)), this.setAttribute("normal", new Lr(o, 3)), this.setAttribute("uv", new Lr(s, 2)) } function Su(t, e, n, i) { ho.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }, this.fromBufferGeometry(new Tu(t, e, n, i)), this.mergeVertices() } function Tu(t, e, n, i) { Gr.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }, n = n || 1; const r = [], o = []; function s(t, e, n, i) { const r = Math.pow(2, i), o = []; for (let s = 0; s <= r; s++) { o[s] = []; const i = t.clone().lerp(n, s / r), a = e.clone().lerp(n, s / r), c = r - s; for (let t = 0; t <= c; t++)o[s][t] = 0 === t && s === r ? i : i.clone().lerp(a, t / c) } for (let s = 0; s < r; s++)for (let t = 0; t < 2 * (r - s) - 1; t++) { const e = Math.floor(t / 2); t % 2 == 0 ? (a(o[s][e + 1]), a(o[s + 1][e]), a(o[s][e])) : (a(o[s][e + 1]), a(o[s + 1][e + 1]), a(o[s + 1][e])) } } function a(t) { r.push(t.x, t.y, t.z) } function c(e, n) { const i = 3 * e; n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2] } function l(t, e, n, i) { i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5) } function h(t) { return Math.atan2(t.z, -t.x) } !function (t) { const n = new Xn, i = new Xn, r = new Xn; for (let o = 0; o < e.length; o += 3)c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t) }(i = i || 0), function (t) { const e = new Xn; for (let n = 0; n < r.length; n += 3)e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z }(n), function () { const t = new Xn; for (let n = 0; n < r.length; n += 3) { t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2]; const i = h(t) / 2 / Math.PI + .5, s = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5); o.push(i, 1 - s) } var e; (function () { const t = new Xn, e = new Xn, n = new Xn, i = new Xn, s = new Nn, a = new Nn, c = new Nn; for (let u = 0, p = 0; u < r.length; u += 9, p += 6) { t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), s.set(o[p + 0], o[p + 1]), a.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), i.copy(t).add(e).add(n).divideScalar(3); const d = h(i); l(s, p + 0, t, d), l(a, p + 2, e, d), l(c, p + 4, n, d) } })(), function () { for (let t = 0; t < o.length; t += 6) { const e = o[t + 0], n = o[t + 2], i = o[t + 4], r = Math.max(e, n, i), s = Math.min(e, n, i); r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1)) } }() }(), this.setAttribute("position", new Lr(r, 3)), this.setAttribute("normal", new Lr(r.slice(), 3)), this.setAttribute("uv", new Lr(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals() } function Eu(t, e) { ho.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Au(t, e)), this.mergeVertices() } function Au(t, e) { Tu.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Lu(t, e) { ho.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Ru(t, e)), this.mergeVertices() } function Ru(t, e) { Tu.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Cu(t, e) { ho.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Pu(t, e)), this.mergeVertices() } function Pu(t, e) { const n = (1 + Math.sqrt(5)) / 2, i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1]; Tu.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Ou(t, e) { ho.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Du(t, e)), this.mergeVertices() } function Du(t, e) { const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i]; Tu.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Iu(t, e, n, i, r, o) { ho.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."); const s = new Nu(t, e, n, i, r); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices() } function Nu(t, e, n, i, r) { Gr.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, e = e || 64, n = n || 1, i = i || 8, r = r || !1; const o = t.computeFrenetFrames(e, r); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const s = new Xn, a = new Xn, c = new Nn; let l = new Xn; const h = [], u = [], p = [], d = []; function f(r) { l = t.getPointAt(r / e, l); const c = o.normals[r], p = o.binormals[r]; for (let t = 0; t <= i; t++) { const e = t / i * Math.PI * 2, r = Math.sin(e), o = -Math.cos(e); a.x = o * c.x + r * p.x, a.y = o * c.y + r * p.y, a.z = o * c.z + r * p.z, a.normalize(), u.push(a.x, a.y, a.z), s.x = l.x + n * a.x, s.y = l.y + n * a.y, s.z = l.z + n * a.z, h.push(s.x, s.y, s.z) } } !function () { for (let t = 0; t < e; t++)f(t); f(!1 === r ? e : 0), function () { for (let t = 0; t <= e; t++)for (let n = 0; n <= i; n++)c.x = t / e, c.y = n / i, p.push(c.x, c.y) }(), function () { for (let t = 1; t <= e; t++)for (let e = 1; e <= i; e++) { const n = (i + 1) * (t - 1) + (e - 1), r = (i + 1) * t + (e - 1), o = (i + 1) * t + e, s = (i + 1) * (t - 1) + e; d.push(n, r, s), d.push(r, o, s) } }() }(), this.setIndex(d), this.setAttribute("position", new Lr(h, 3)), this.setAttribute("normal", new Lr(u, 3)), this.setAttribute("uv", new Lr(p, 2)) } function Bu(t, e, n, i, r, o, s) { ho.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: o }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Fu(t, e, n, i, r, o)), this.mergeVertices() } function Fu(t, e, n, i, r, o) { Gr.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: o }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3; const s = [], a = [], c = [], l = [], h = new Xn, u = new Xn, p = new Xn, d = new Xn, f = new Xn, m = new Xn, g = new Xn; for (let y = 0; y <= n; ++y) { const s = y / n * r * Math.PI * 2; v(s, r, o, t, p), v(s + .01, r, o, t, d), m.subVectors(d, p), g.addVectors(d, p), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize(); for (let t = 0; t <= i; ++t) { const r = t / i * Math.PI * 2, o = -e * Math.cos(r), s = e * Math.sin(r); h.x = p.x + (o * g.x + s * f.x), h.y = p.y + (o * g.y + s * f.y), h.z = p.z + (o * g.z + s * f.z), a.push(h.x, h.y, h.z), u.subVectors(h, p).normalize(), c.push(u.x, u.y, u.z), l.push(y / n), l.push(t / i) } } for (let y = 1; y <= n; y++)for (let t = 1; t <= i; t++) { const e = (i + 1) * (y - 1) + (t - 1), n = (i + 1) * y + (t - 1), r = (i + 1) * y + t, o = (i + 1) * (y - 1) + t; s.push(e, n, o), s.push(n, r, o) } function v(t, e, n, i, r) { const o = Math.cos(t), s = Math.sin(t), a = n / e * t, c = Math.cos(a); r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * s * .5, r.z = i * Math.sin(a) * .5 } this.setIndex(s), this.setAttribute("position", new Lr(a, 3)), this.setAttribute("normal", new Lr(c, 3)), this.setAttribute("uv", new Lr(l, 2)) } function Uu(t, e, n, i, r) { ho.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, this.fromBufferGeometry(new Gu(t, e, n, i, r)), this.mergeVertices() } function Gu(t, e, n, i, r) { Gr.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI; const o = [], s = [], a = [], c = [], l = new Xn, h = new Xn, u = new Xn; for (let p = 0; p <= n; p++)for (let o = 0; o <= i; o++) { const d = o / i * r, f = p / n * Math.PI * 2; h.x = (t + e * Math.cos(f)) * Math.cos(d), h.y = (t + e * Math.cos(f)) * Math.sin(d), h.z = e * Math.sin(f), s.push(h.x, h.y, h.z), l.x = t * Math.cos(d), l.y = t * Math.sin(d), u.subVectors(h, l).normalize(), a.push(u.x, u.y, u.z), c.push(o / i), c.push(p / n) } for (let p = 1; p <= n; p++)for (let t = 1; t <= i; t++) { const e = (i + 1) * p + t - 1, n = (i + 1) * (p - 1) + t - 1, r = (i + 1) * (p - 1) + t, s = (i + 1) * p + t; o.push(e, n, s), o.push(n, r, s) } this.setIndex(o), this.setAttribute("position", new Lr(s, 3)), this.setAttribute("normal", new Lr(a, 3)), this.setAttribute("uv", new Lr(c, 2)) } mu.prototype = Object.assign(Object.create(xi.prototype), { constructor: mu, isPoints: !0, copy: function (t) { return xi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Points.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), du.copy(n.boundingSphere), du.applyMatrix4(i), du.radius += r, !1 === t.ray.intersectsSphere(du)) return; uu.getInverse(i), pu.copy(t.ray).applyMatrix4(uu); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o; if (n.isBufferGeometry) { const r = n.index, o = n.attributes.position.array; if (null !== r) { const n = r.array; for (let r = 0, a = n.length; r < a; r++) { const a = n[r]; fu.fromArray(o, 3 * a), gu(fu, a, s, i, t, e, this) } } else for (let n = 0, a = o.length / 3; n < a; n++)fu.fromArray(o, 3 * n), gu(fu, n, s, i, t, e, this) } else { const r = n.vertices; for (let n = 0, o = r.length; n < o; n++)gu(r[n], n, s, i, t, e, this) } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }), vu.prototype = Object.assign(Object.create(zn.prototype), { constructor: vu, isVideoTexture: !0, update: function () { const t = this.image; !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), yu.prototype = Object.create(zn.prototype), yu.prototype.constructor = yu, yu.prototype.isCompressedTexture = !0, xu.prototype = Object.create(zn.prototype), xu.prototype.constructor = xu, xu.prototype.isCanvasTexture = !0, _u.prototype = Object.create(zn.prototype), _u.prototype.constructor = _u, _u.prototype.isDepthTexture = !0, bu.prototype = Object.create(Gr.prototype), bu.prototype.constructor = bu, wu.prototype = Object.create(ho.prototype), wu.prototype.constructor = wu, Mu.prototype = Object.create(Gr.prototype), Mu.prototype.constructor = Mu, Su.prototype = Object.create(ho.prototype), Su.prototype.constructor = Su, Tu.prototype = Object.create(Gr.prototype), Tu.prototype.constructor = Tu, Eu.prototype = Object.create(ho.prototype), Eu.prototype.constructor = Eu, Au.prototype = Object.create(Tu.prototype), Au.prototype.constructor = Au, Lu.prototype = Object.create(ho.prototype), Lu.prototype.constructor = Lu, Ru.prototype = Object.create(Tu.prototype), Ru.prototype.constructor = Ru, Cu.prototype = Object.create(ho.prototype), Cu.prototype.constructor = Cu, Pu.prototype = Object.create(Tu.prototype), Pu.prototype.constructor = Pu, Ou.prototype = Object.create(ho.prototype), Ou.prototype.constructor = Ou, Du.prototype = Object.create(Tu.prototype), Du.prototype.constructor = Du, Iu.prototype = Object.create(ho.prototype), Iu.prototype.constructor = Iu, Nu.prototype = Object.create(Gr.prototype), Nu.prototype.constructor = Nu, Nu.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, Bu.prototype = Object.create(ho.prototype), Bu.prototype.constructor = Bu, Fu.prototype = Object.create(Gr.prototype), Fu.prototype.constructor = Fu, Uu.prototype = Object.create(ho.prototype), Uu.prototype.constructor = Uu, Gu.prototype = Object.create(Gr.prototype), Gu.prototype.constructor = Gu; const zu = { triangulate: function (t, e, n) { n = n || 2; let i, r, o, s, a, c, l, h = e && e.length, u = h ? e[0] * n : t.length, p = Hu(t, 0, u, n, !0), d = []; if (!p || p.next === p.prev) return d; if (h && (p = Yu(t, e, p, n)), t.length > 80 * n) { i = o = t[0], r = s = t[1]; for (let e = n; e < u; e += n)(a = t[e]) < i && (i = a), (c = t[e + 1]) < r && (r = c), a > o && (o = a), c > s && (s = c); l = 0 !== (l = Math.max(o - i, s - r)) ? 1 / l : 0 } return Vu(p, d, n, i, r, l), d } }; function Hu(t, e, n, i, r) { let o, s; if (r === vp(t, e, n, i) > 0) for (o = e; o < n; o += i)s = fp(o, t[o], t[o + 1], s); else for (o = n - i; o >= e; o -= i)s = fp(o, t[o], t[o + 1], s); return s && sp(s, s.next) && (mp(s), s = s.next), s } function ku(t, e) { if (!t) return t; e || (e = t); let n, i = t; do { if (n = !1, i.steiner || !sp(i, i.next) && 0 !== op(i.prev, i, i.next)) i = i.next; else { if (mp(i), (i = e = i.prev) === i.next) break; n = !0 } } while (n || i !== e); return e } function Vu(t, e, n, i, r, o, s) { if (!t) return; !s && o && $u(t, i, r, o); let a, c, l = t; for (; t.prev !== t.next;)if (a = t.prev, c = t.next, o ? Wu(t, i, r, o) : ju(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), mp(t), t = c.next, l = c.next; else if ((t = c) === l) { s ? 1 === s ? Vu(t = qu(ku(t), e, n), e, n, i, r, o, 2) : 2 === s && Xu(t, e, n, i, r, o) : Vu(ku(t), e, n, i, r, o, 1); break } } function ju(t) { let e = t.prev, n = t, i = t.next; if (op(e, n, i) >= 0) return !1; let r = t.next.next; for (; r !== t.prev;) { if (ip(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && op(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function Wu(t, e, n, i) { let r = t.prev, o = t, s = t.next; if (op(r, o, s) >= 0) return !1; let a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, h = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, u = ep(a, c, e, n, i), p = ep(l, h, e, n, i), d = t.prevZ, f = t.nextZ; for (; d && d.z >= u && f && f.z <= p;) { if (d !== t.prev && d !== t.next && ip(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && op(d.prev, d, d.next) >= 0) return !1; if (d = d.prevZ, f !== t.prev && f !== t.next && ip(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && op(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; d && d.z >= u;) { if (d !== t.prev && d !== t.next && ip(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && op(d.prev, d, d.next) >= 0) return !1; d = d.prevZ } for (; f && f.z <= p;) { if (f !== t.prev && f !== t.next && ip(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && op(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function qu(t, e, n) { let i = t; do { let r = i.prev, o = i.next.next; !sp(r, o) && ap(r, i, i.next, o) && up(r, o) && up(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), mp(i), mp(i.next), i = t = o), i = i.next } while (i !== t); return ku(i) } function Xu(t, e, n, i, r, o) { let s = t; do { let t = s.next.next; for (; t !== s.prev;) { if (s.i !== t.i && rp(s, t)) { let a = dp(s, t); return s = ku(s, s.next), a = ku(a, a.next), Vu(s, e, n, i, r, o), void Vu(a, e, n, i, r, o) } t = t.next } s = s.next } while (s !== t) } function Yu(t, e, n, i) { let r, o, s, a, c, l = []; for (r = 0, o = e.length; r < o; r++)(c = Hu(t, s = e[r] * i, a = r < o - 1 ? e[r + 1] * i : t.length, i, !1)) === c.next && (c.steiner = !0), l.push(np(c)); for (l.sort(Zu), r = 0; r < l.length; r++)Ju(l[r], n), n = ku(n, n.next); return n } function Zu(t, e) { return t.x - e.x } function Ju(t, e) { if (e = Qu(t, e)) { const n = dp(e, t); ku(e, e.next), ku(n, n.next) } } function Qu(t, e) { let n, i = e, r = t.x, o = t.y, s = -1 / 0; do { if (o <= i.y && o >= i.next.y && i.next.y !== i.y) { let t = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (t <= r && t > s) { if (s = t, t === r) { if (o === i.y) return i; if (o === i.next.y) return i.next } n = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== e); if (!n) return null; if (r === s) return n; let a, c = n, l = n.x, h = n.y, u = 1 / 0; i = n; do { r >= i.x && i.x >= l && r !== i.x && ip(o < h ? r : s, o, l, h, o < h ? s : r, o, i.x, i.y) && (a = Math.abs(o - i.y) / (r - i.x), up(i, t) && (a < u || a === u && (i.x > n.x || i.x === n.x && Ku(n, i))) && (n = i, u = a)), i = i.next } while (i !== c); return n } function Ku(t, e) { return op(t.prev, t, e.prev) < 0 && op(e.next, t, t.next) < 0 } function $u(t, e, n, i) { let r = t; do { null === r.z && (r.z = ep(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t); r.prevZ.nextZ = null, r.prevZ = null, tp(r) } function tp(t) { let e, n, i, r, o, s, a, c, l = 1; do { for (n = t, t = null, o = null, s = 0; n;) { for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ); e++); for (c = l; a > 0 || c > 0 && i;)0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r; n = i } o.nextZ = null, l *= 2 } while (s > 1); return t } function ep(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function np(t) { let e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function ip(t, e, n, i, r, o, s, a) { return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0 } function rp(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !hp(t, e) && (up(t, e) && up(e, t) && pp(t, e) && (op(t.prev, t, e.prev) || op(t, e.prev, e)) || sp(t, e) && op(t.prev, t, t.next) > 0 && op(e.prev, e, e.next) > 0) } function op(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function sp(t, e) { return t.x === e.x && t.y === e.y } function ap(t, e, n, i) { const r = lp(op(t, e, n)), o = lp(op(t, e, i)), s = lp(op(n, i, t)), a = lp(op(n, i, e)); return r !== o && s !== a || (!(0 !== r || !cp(t, n, e)) || (!(0 !== o || !cp(t, i, e)) || (!(0 !== s || !cp(n, t, i)) || !(0 !== a || !cp(n, e, i))))) } function cp(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function lp(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function hp(t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && ap(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 } function up(t, e) { return op(t.prev, t, t.next) < 0 ? op(t, e, t.next) >= 0 && op(t, t.prev, e) >= 0 : op(t, e, t.prev) < 0 || op(t, t.next, e) < 0 } function pp(t, e) { let n = t, i = !1, r = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t); return i } function dp(t, e) { let n = new gp(t.i, t.x, t.y), i = new gp(e.i, e.x, e.y), r = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i } function fp(t, e, n, i) { const r = new gp(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function mp(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function gp(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function vp(t, e, n, i) { let r = 0; for (let o = e, s = n - i; o < n; o += i)r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return r } const yp = { area: function (t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }, isClockWise: function (t) { return yp.area(t) < 0 }, triangulateShape: function (t, e) { const n = [], i = [], r = []; xp(t), _p(n, t); let o = t.length; e.forEach(xp); for (let a = 0; a < e.length; a++)i.push(o), o += e[a].length, _p(n, e[a]); const s = zu.triangulate(n, i); for (let a = 0; a < s.length; a += 3)r.push(s.slice(a, a + 3)); return r } }; function xp(t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function _p(t, e) { for (let n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } function bp(t, e) { ho.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new wp(t, e)), this.mergeVertices() } function wp(t, e) { Gr.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; const n = this, i = [], r = []; for (let s = 0, a = t.length; s < a; s++) { o(t[s]) } function o(t) { const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1; let c = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled, h = void 0 !== e.bevelThickness ? e.bevelThickness : 6, u = void 0 !== e.bevelSize ? e.bevelSize : h - 2, p = void 0 !== e.bevelOffset ? e.bevelOffset : 0, d = void 0 !== e.bevelSegments ? e.bevelSegments : 3; const f = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : Mp; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount); let g, v, y, x, _, b = !1; f && (g = f.getSpacedPoints(a), b = !0, l = !1, v = f.computeFrenetFrames(a, !1), y = new Xn, x = new Xn, _ = new Xn), l || (d = 0, h = 0, u = 0, p = 0); const w = t.extractPoints(s); let M = w.shape; const S = w.holes; if (!yp.isClockWise(M)) { M = M.reverse(); for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; yp.isClockWise(e) && (S[t] = e.reverse()) } } const T = yp.triangulateShape(M, S), E = M; for (let e = 0, n = S.length; e < n; e++) { const t = S[e]; M = M.concat(t) } function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) } const L = M.length, R = T.length; function C(t, e, n) { let i, r, o; const s = t.x - e.x, a = t.y - e.y, c = n.x - t.x, l = n.y - t.y, h = s * s + a * a, u = s * l - a * c; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), p = Math.sqrt(c * c + l * l), d = e.x - a / u, f = e.y + s / u, m = ((n.x - l / p - d) * l - (n.y + c / p - f) * c) / (s * l - a * c), g = (i = d + s * m - t.x) * i + (r = f + a * m - t.y) * r; if (g <= 2) return new Nn(i, r); o = Math.sqrt(g / 2) } else { let t = !1; s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(h)) : (i = s, r = a, o = Math.sqrt(h / 2)) } return new Nn(i / o, r / o) } const P = []; for (let e = 0, n = E.length, i = n - 1, r = e + 1; e < n; e++, i++, r++)i === n && (i = 0), r === n && (r = 0), P[e] = C(E[e], E[i], E[r]); const O = []; let D, I = P.concat(); for (let e = 0, n = S.length; e < n; e++) { const t = S[e]; D = []; for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++)i === n && (i = 0), r === n && (r = 0), D[e] = C(t[e], t[i], t[r]); O.push(D), I = I.concat(D) } for (let e = 0; e < d; e++) { const t = e / d, n = h * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + p; for (let e = 0, r = E.length; e < r; e++) { const t = A(E[e], P[e], i); F(t.x, t.y, -n) } for (let e = 0, r = S.length; e < r; e++) { const t = S[e]; D = O[e]; for (let e = 0, r = t.length; e < r; e++) { const r = A(t[e], D[e], i); F(r.x, r.y, -n) } } } const N = u + p; for (let e = 0; e < L; e++) { const t = l ? A(M[e], I[e], N) : M[e]; b ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(x).add(y), F(_.x, _.y, _.z)) : F(t.x, t.y, 0) } for (let e = 1; e <= a; e++)for (let t = 0; t < L; t++) { const n = l ? A(M[t], I[t], N) : M[t]; b ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), _.copy(g[e]).add(x).add(y), F(_.x, _.y, _.z)) : F(n.x, n.y, c / a * e) } for (let e = d - 1; e >= 0; e--) { const t = e / d, n = h * Math.cos(t * Math.PI / 2), i = u * Math.sin(t * Math.PI / 2) + p; for (let e = 0, r = E.length; e < r; e++) { const t = A(E[e], P[e], i); F(t.x, t.y, c + n) } for (let e = 0, r = S.length; e < r; e++) { const t = S[e]; D = O[e]; for (let e = 0, r = t.length; e < r; e++) { const r = A(t[e], D[e], i); b ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, c + n) } } } function B(t, e) { let n = t.length; for (; --n >= 0;) { const i = n; let r = n - 1; r < 0 && (r = t.length - 1); for (let t = 0, n = a + 2 * d; t < n; t++) { const n = L * t, o = L * (t + 1); G(e + i + n, e + r + n, e + r + o, e + i + o) } } } function F(t, e, n) { o.push(t), o.push(e), o.push(n) } function U(t, e, r) { z(t), z(e), z(r); const o = i.length / 3, s = m.generateTopUV(n, i, o - 3, o - 2, o - 1); H(s[0]), H(s[1]), H(s[2]) } function G(t, e, r, o) { z(t), z(e), z(o), z(e), z(r), z(o); const s = i.length / 3, a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1); H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3]) } function z(t) { i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]) } function H(t) { r.push(t.x), r.push(t.y) } !function () { const t = i.length / 3; if (l) { let t = 0, e = L * t; for (let n = 0; n < R; n++) { const t = T[n]; U(t[2] + e, t[1] + e, t[0] + e) } e = L * (t = a + 2 * d); for (let n = 0; n < R; n++) { const t = T[n]; U(t[0] + e, t[1] + e, t[2] + e) } } else { for (let t = 0; t < R; t++) { const e = T[t]; U(e[2], e[1], e[0]) } for (let t = 0; t < R; t++) { const e = T[t]; U(e[0] + L * a, e[1] + L * a, e[2] + L * a) } } n.addGroup(t, i.length / 3 - t, 0) }(), function () { const t = i.length / 3; let e = 0; B(E, e), e += E.length; for (let n = 0, i = S.length; n < i; n++) { const t = S[n]; B(t, e), e += t.length } n.addGroup(t, i.length / 3 - t, 1) }() } this.setAttribute("position", new Lr(i, 3)), this.setAttribute("uv", new Lr(r, 2)), this.computeVertexNormals() } exports.ShapeUtils = yp, bp.prototype = Object.create(ho.prototype), bp.prototype.constructor = bp, bp.prototype.toJSON = function () { const t = ho.prototype.toJSON.call(this); return Sp(this.parameters.shapes, this.parameters.options, t) }, wp.prototype = Object.create(Gr.prototype), wp.prototype.constructor = wp, wp.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return Sp(this.parameters.shapes, this.parameters.options, t) }; const Mp = { generateTopUV: function (t, e, n, i, r) { const o = e[3 * n], s = e[3 * n + 1], a = e[3 * i], c = e[3 * i + 1], l = e[3 * r], h = e[3 * r + 1]; return [new Nn(o, s), new Nn(a, c), new Nn(l, h)] }, generateSideWallUV: function (t, e, n, i, r, o) { const s = e[3 * n], a = e[3 * n + 1], c = e[3 * n + 2], l = e[3 * i], h = e[3 * i + 1], u = e[3 * i + 2], p = e[3 * r], d = e[3 * r + 1], f = e[3 * r + 2], m = e[3 * o], g = e[3 * o + 1], v = e[3 * o + 2]; return Math.abs(a - h) < .01 ? [new Nn(s, 1 - c), new Nn(l, 1 - u), new Nn(p, 1 - f), new Nn(m, 1 - v)] : [new Nn(a, 1 - c), new Nn(h, 1 - u), new Nn(d, 1 - f), new Nn(g, 1 - v)] } }; function Sp(t, e, n) { if (n.shapes = [], Array.isArray(t)) for (let i = 0, r = t.length; i < r; i++) { const e = t[i]; n.shapes.push(e.uuid) } else n.shapes.push(t.uuid); return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n } function Tp(t, e) { ho.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Ep(t, e)), this.mergeVertices() } function Ep(t, e) { const n = (e = e || {}).font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ho; const i = n.generateShapes(t, e.size); e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), wp.call(this, i, e), this.type = "TextBufferGeometry" } function Ap(t, e, n, i, r, o, s) { ho.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new Lp(t, e, n, i, r, o, s)), this.mergeVertices() } function Lp(t, e, n, i, r, o, s) { Gr.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: s }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI; const a = Math.min(o + s, Math.PI); let c = 0; const l = [], h = new Xn, u = new Xn, p = [], d = [], f = [], m = []; for (let g = 0; g <= n; g++) { const p = [], v = g / n; let y = 0; 0 == g && 0 == o ? y = .5 / e : g == n && a == Math.PI && (y = -.5 / e); for (let n = 0; n <= e; n++) { const a = n / e; h.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s), h.y = t * Math.cos(o + v * s), h.z = t * Math.sin(i + a * r) * Math.sin(o + v * s), d.push(h.x, h.y, h.z), u.copy(h).normalize(), f.push(u.x, u.y, u.z), m.push(a + y, 1 - v), p.push(c++) } l.push(p) } for (let g = 0; g < n; g++)for (let t = 0; t < e; t++) { const e = l[g][t + 1], i = l[g][t], r = l[g + 1][t], s = l[g + 1][t + 1]; (0 !== g || o > 0) && p.push(e, i, s), (g !== n - 1 || a < Math.PI) && p.push(i, r, s) } this.setIndex(p), this.setAttribute("position", new Lr(d, 3)), this.setAttribute("normal", new Lr(f, 3)), this.setAttribute("uv", new Lr(m, 2)) } function Rp(t, e, n, i, r, o) { ho.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, this.fromBufferGeometry(new Cp(t, e, n, i, r, o)), this.mergeVertices() } function Cp(t, e, n, i, r, o) { Gr.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8; const s = [], a = [], c = [], l = []; let h = t; const u = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1), p = new Xn, d = new Nn; for (let f = 0; f <= i; f++) { for (let t = 0; t <= n; t++) { const i = r + t / n * o; p.x = h * Math.cos(i), p.y = h * Math.sin(i), a.push(p.x, p.y, p.z), c.push(0, 0, 1), d.x = (p.x / e + 1) / 2, d.y = (p.y / e + 1) / 2, l.push(d.x, d.y) } h += u } for (let f = 0; f < i; f++) { const t = f * (n + 1); for (let e = 0; e < n; e++) { const i = e + t, r = i, o = i + n + 1, a = i + n + 2, c = i + 1; s.push(r, o, c), s.push(o, a, c) } } this.setIndex(s), this.setAttribute("position", new Lr(a, 3)), this.setAttribute("normal", new Lr(c, 3)), this.setAttribute("uv", new Lr(l, 2)) } function Pp(t, e, n, i) { ho.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, this.fromBufferGeometry(new Op(t, e, n, i)), this.mergeVertices() } function Op(t, e, n, i) { Gr.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = In.clamp(i, 0, 2 * Math.PI); const r = [], o = [], s = [], a = 1 / e, c = new Xn, l = new Nn; for (let h = 0; h <= e; h++) { const r = n + h * a * i, u = Math.sin(r), p = Math.cos(r); for (let n = 0; n <= t.length - 1; n++)c.x = t[n].x * u, c.y = t[n].y, c.z = t[n].x * p, o.push(c.x, c.y, c.z), l.x = h / e, l.y = n / (t.length - 1), s.push(l.x, l.y) } for (let h = 0; h < e; h++)for (let e = 0; e < t.length - 1; e++) { const n = e + h * t.length, i = n, o = n + t.length, s = n + t.length + 1, a = n + 1; r.push(i, o, a), r.push(o, s, a) } if (this.setIndex(r), this.setAttribute("position", new Lr(o, 3)), this.setAttribute("uv", new Lr(s, 2)), this.computeVertexNormals(), i === 2 * Math.PI) { const n = this.attributes.normal.array, i = new Xn, r = new Xn, o = new Xn, s = e * t.length * 3; for (let e = 0, a = 0; e < t.length; e++, a += 3)i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[s + a + 0], r.y = n[s + a + 1], r.z = n[s + a + 2], o.addVectors(i, r).normalize(), n[a + 0] = n[s + a + 0] = o.x, n[a + 1] = n[s + a + 1] = o.y, n[a + 2] = n[s + a + 2] = o.z } } function Dp(t, e) { ho.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new Ip(t, e)), this.mergeVertices() } function Ip(t, e) { Gr.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12; const n = [], i = [], r = [], o = []; let s = 0, a = 0; if (!1 === Array.isArray(t)) c(t); else for (let l = 0; l < t.length; l++)c(t[l]), this.addGroup(s, a, l), s += a, a = 0; function c(t) { const s = i.length / 3, c = t.extractPoints(e); let l = c.shape; const h = c.holes; !1 === yp.isClockWise(l) && (l = l.reverse()); for (let e = 0, n = h.length; e < n; e++) { const t = h[e]; !0 === yp.isClockWise(t) && (h[e] = t.reverse()) } const u = yp.triangulateShape(l, h); for (let e = 0, n = h.length; e < n; e++) { const t = h[e]; l = l.concat(t) } for (let e = 0, n = l.length; e < n; e++) { const t = l[e]; i.push(t.x, t.y, 0), r.push(0, 0, 1), o.push(t.x, t.y) } for (let e = 0, i = u.length; e < i; e++) { const t = u[e], i = t[0] + s, r = t[1] + s, o = t[2] + s; n.push(i, r, o), a += 3 } } this.setIndex(n), this.setAttribute("position", new Lr(i, 3)), this.setAttribute("normal", new Lr(r, 3)), this.setAttribute("uv", new Lr(o, 2)) } function Np(t, e) { if (e.shapes = [], Array.isArray(t)) for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.shapes.push(i.uuid) } else e.shapes.push(t.uuid); return e } function Bp(t, e) { Gr.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1; const n = [], i = Math.cos(In.DEG2RAD * e), r = [0, 0], o = {}; let s, a, c; const l = ["a", "b", "c"]; let h; t.isBufferGeometry ? (h = new ho).fromBufferGeometry(t) : h = t.clone(), h.mergeVertices(), h.computeFaceNormals(); const u = h.vertices, p = h.faces; for (let d = 0, f = p.length; d < f; d++) { const t = p[d]; for (let e = 0; e < 3; e++)s = t[l[e]], a = t[l[(e + 1) % 3]], r[0] = Math.min(s, a), r[1] = Math.max(s, a), void 0 === o[c = r[0] + "," + r[1]] ? o[c] = { index1: r[0], index2: r[1], face1: d, face2: void 0 } : o[c].face2 = d } for (c in o) { const t = o[c]; if (void 0 === t.face2 || p[t.face1].normal.dot(p[t.face2].normal) <= i) { let e = u[t.index1]; n.push(e.x, e.y, e.z), e = u[t.index2], n.push(e.x, e.y, e.z) } } this.setAttribute("position", new Lr(n, 3)) } function Fp(t, e, n, i, r, o, s, a) { ho.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: s, thetaLength: a }, this.fromBufferGeometry(new Up(t, e, n, i, r, o, s, a)), this.mergeVertices() } function Up(t, e, n, i, r, o, s, a) { Gr.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: s, thetaLength: a }; const c = this; t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI; const l = [], h = [], u = [], p = []; let d = 0; const f = [], m = n / 2; let g = 0; function v(n) { let r, o; const f = new Nn, v = new Xn; let y = 0; const x = !0 === n ? t : e, _ = !0 === n ? 1 : -1; r = d; for (let t = 1; t <= i; t++)h.push(0, m * _, 0), u.push(0, _, 0), p.push(.5, .5), d++; o = d; for (let t = 0; t <= i; t++) { const e = t / i * a + s, n = Math.cos(e), r = Math.sin(e); v.x = x * r, v.y = m * _, v.z = x * n, h.push(v.x, v.y, v.z), u.push(0, _, 0), f.x = .5 * n + .5, f.y = .5 * r * _ + .5, p.push(f.x, f.y), d++ } for (let t = 0; t < i; t++) { const e = r + t, i = o + t; !0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e), y += 3 } c.addGroup(g, y, !0 === n ? 1 : 2), g += y } !function () { const o = new Xn, v = new Xn; let y = 0; const x = (e - t) / n; for (let c = 0; c <= r; c++) { const l = [], g = c / r, y = g * (e - t) + t; for (let t = 0; t <= i; t++) { const e = t / i, r = e * a + s, c = Math.sin(r), f = Math.cos(r); v.x = y * c, v.y = -g * n + m, v.z = y * f, h.push(v.x, v.y, v.z), o.set(c, x, f).normalize(), u.push(o.x, o.y, o.z), p.push(e, 1 - g), l.push(d++) } f.push(l) } for (let t = 0; t < i; t++)for (let e = 0; e < r; e++) { const n = f[e][t], i = f[e + 1][t], r = f[e + 1][t + 1], o = f[e][t + 1]; l.push(n, i, o), l.push(i, r, o), y += 6 } c.addGroup(g, y, 0), g += y }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.setAttribute("position", new Lr(h, 3)), this.setAttribute("normal", new Lr(u, 3)), this.setAttribute("uv", new Lr(p, 2)) } function Gp(t, e, n, i, r, o, s) { Fp.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: s } } function zp(t, e, n, i, r, o, s) { Up.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: s } } function Hp(t, e, n, i) { ho.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, this.fromBufferGeometry(new kp(t, e, n, i)), this.mergeVertices() } function kp(t, e, n, i) { Gr.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI; const r = [], o = [], s = [], a = [], c = new Xn, l = new Nn; o.push(0, 0, 0), s.push(0, 0, 1), a.push(.5, .5); for (let h = 0, u = 3; h <= e; h++, u += 3) { const r = n + h / e * i; c.x = t * Math.cos(r), c.y = t * Math.sin(r), o.push(c.x, c.y, c.z), s.push(0, 0, 1), l.x = (o[u] / t + 1) / 2, l.y = (o[u + 1] / t + 1) / 2, a.push(l.x, l.y) } for (let h = 1; h <= e; h++)r.push(h, h + 1, 0); this.setIndex(r), this.setAttribute("position", new Lr(o, 3)), this.setAttribute("normal", new Lr(s, 3)), this.setAttribute("uv", new Lr(a, 2)) } Tp.prototype = Object.create(ho.prototype), Tp.prototype.constructor = Tp, Ep.prototype = Object.create(wp.prototype), Ep.prototype.constructor = Ep, Ap.prototype = Object.create(ho.prototype), Ap.prototype.constructor = Ap, Lp.prototype = Object.create(Gr.prototype), Lp.prototype.constructor = Lp, Rp.prototype = Object.create(ho.prototype), Rp.prototype.constructor = Rp, Cp.prototype = Object.create(Gr.prototype), Cp.prototype.constructor = Cp, Pp.prototype = Object.create(ho.prototype), Pp.prototype.constructor = Pp, Op.prototype = Object.create(Gr.prototype), Op.prototype.constructor = Op, Dp.prototype = Object.create(ho.prototype), Dp.prototype.constructor = Dp, Dp.prototype.toJSON = function () { const t = ho.prototype.toJSON.call(this); return Np(this.parameters.shapes, t) }, Ip.prototype = Object.create(Gr.prototype), Ip.prototype.constructor = Ip, Ip.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return Np(this.parameters.shapes, t) }, Bp.prototype = Object.create(Gr.prototype), Bp.prototype.constructor = Bp, Fp.prototype = Object.create(ho.prototype), Fp.prototype.constructor = Fp, Up.prototype = Object.create(Gr.prototype), Up.prototype.constructor = Up, Gp.prototype = Object.create(Fp.prototype), Gp.prototype.constructor = Gp, zp.prototype = Object.create(Up.prototype), zp.prototype.constructor = zp, Hp.prototype = Object.create(ho.prototype), Hp.prototype.constructor = Hp, kp.prototype = Object.create(Gr.prototype), kp.prototype.constructor = kp; var Vp = Object.freeze({ __proto__: null, WireframeGeometry: bu, ParametricGeometry: wu, ParametricBufferGeometry: Mu, TetrahedronGeometry: Eu, TetrahedronBufferGeometry: Au, OctahedronGeometry: Lu, OctahedronBufferGeometry: Ru, IcosahedronGeometry: Cu, IcosahedronBufferGeometry: Pu, DodecahedronGeometry: Ou, DodecahedronBufferGeometry: Du, PolyhedronGeometry: Su, PolyhedronBufferGeometry: Tu, TubeGeometry: Iu, TubeBufferGeometry: Nu, TorusKnotGeometry: Bu, TorusKnotBufferGeometry: Fu, TorusGeometry: Uu, TorusBufferGeometry: Gu, TextGeometry: Tp, TextBufferGeometry: Ep, SphereGeometry: Ap, SphereBufferGeometry: Lp, RingGeometry: Rp, RingBufferGeometry: Cp, PlaneGeometry: Do, PlaneBufferGeometry: Io, LatheGeometry: Pp, LatheBufferGeometry: Op, ShapeGeometry: Dp, ShapeBufferGeometry: Ip, ExtrudeGeometry: bp, ExtrudeBufferGeometry: wp, EdgesGeometry: Bp, ConeGeometry: Gp, ConeBufferGeometry: zp, CylinderGeometry: Fp, CylinderBufferGeometry: Up, CircleGeometry: Hp, CircleBufferGeometry: kp, BoxGeometry: uo, BoxBufferGeometry: po }); function jp(t) { gr.call(this), this.type = "ShadowMaterial", this.color = new hr(0), this.transparent = !0, this.setValues(t) } function Wp(t) { xo.call(this, t), this.type = "RawShaderMaterial" } function qp(t) { gr.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new hr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new Nn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t) } function Xp(t) { qp.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Nn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t) } function Yp(t) { gr.call(this), this.type = "MeshPhongMaterial", this.color = new hr(16777215), this.specular = new hr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new Nn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Zp(t) { gr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new hr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new Nn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Jp(t) { gr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new Nn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Qp(t) { gr.call(this), this.type = "MeshLambertMaterial", this.color = new hr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Kp(t) { gr.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new hr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new Nn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function $p(t) { $h.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } jp.prototype = Object.create(gr.prototype), jp.prototype.constructor = jp, jp.prototype.isShadowMaterial = !0, jp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this }, Wp.prototype = Object.create(xo.prototype), Wp.prototype.constructor = Wp, Wp.prototype.isRawShaderMaterial = !0, qp.prototype = Object.create(gr.prototype), qp.prototype.constructor = qp, qp.prototype.isMeshStandardMaterial = !0, qp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this }, Xp.prototype = Object.create(qp.prototype), Xp.prototype.constructor = Xp, Xp.prototype.isMeshPhysicalMaterial = !0, Xp.prototype.copy = function (t) { return qp.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new hr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this }, Yp.prototype = Object.create(gr.prototype), Yp.prototype.constructor = Yp, Yp.prototype.isMeshPhongMaterial = !0, Yp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Zp.prototype = Object.create(gr.prototype), Zp.prototype.constructor = Zp, Zp.prototype.isMeshToonMaterial = !0, Zp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Jp.prototype = Object.create(gr.prototype), Jp.prototype.constructor = Jp, Jp.prototype.isMeshNormalMaterial = !0, Jp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Qp.prototype = Object.create(gr.prototype), Qp.prototype.constructor = Qp, Qp.prototype.isMeshLambertMaterial = !0, Qp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Kp.prototype = Object.create(gr.prototype), Kp.prototype.constructor = Kp, Kp.prototype.isMeshMatcapMaterial = !0, Kp.prototype.copy = function (t) { return gr.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, $p.prototype = Object.create($h.prototype), $p.prototype.constructor = $p, $p.prototype.isLineDashedMaterial = !0, $p.prototype.copy = function (t) { return $h.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var td = Object.freeze({ __proto__: null, ShadowMaterial: jp, SpriteMaterial: Sh, RawShaderMaterial: Wp, ShaderMaterial: xo, PointsMaterial: hu, MeshPhysicalMaterial: Xp, MeshStandardMaterial: qp, MeshPhongMaterial: Yp, MeshToonMaterial: Zp, MeshNormalMaterial: Jp, MeshLambertMaterial: Qp, MeshDepthMaterial: rh, MeshDistanceMaterial: oh, MeshBasicMaterial: vr, MeshMatcapMaterial: Kp, LineDashedMaterial: $p, LineBasicMaterial: $h, Material: gr }); const ed = { arraySlice: function (t, e, n) { return ed.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { const e = t.length, n = new Array(e); for (let i = 0; i !== e; ++i)n[i] = i; return n.sort(function (e, n) { return t[e] - t[n] }), n }, sortedArray: function (t, e, n) { const i = t.length, r = new t.constructor(i); for (let o = 0, s = 0; s !== i; ++o) { const i = n[o] * e; for (let n = 0; n !== e; ++n)r[s++] = t[i + n] } return r }, flattenJSON: function (t, e, n, i) { let r = 1, o = t[0]; for (; void 0 !== o && void 0 === o[i];)o = t[r++]; if (void 0 === o) return; let s = o[i]; if (void 0 !== s) if (Array.isArray(s)) do { void 0 !== (s = o[i]) && (e.push(o.time), n.push.apply(n, s)), o = t[r++] } while (void 0 !== o); else if (void 0 !== s.toArray) do { void 0 !== (s = o[i]) && (e.push(o.time), s.toArray(n, n.length)), o = t[r++] } while (void 0 !== o); else do { void 0 !== (s = o[i]) && (e.push(o.time), n.push(s)), o = t[r++] } while (void 0 !== o) }, subclip: function (t, e, n, i, r) { r = r || 30; const o = t.clone(); o.name = e; const s = []; for (let c = 0; c < o.tracks.length; ++c) { const t = o.tracks[c], e = t.getValueSize(), a = [], l = []; for (let o = 0; o < t.times.length; ++o) { const s = t.times[o] * r; if (!(s < n || s >= i)) { a.push(t.times[o]); for (let n = 0; n < e; ++n)l.push(t.values[o * e + n]) } } 0 !== a.length && (t.times = ed.convertArray(a, t.times.constructor), t.values = ed.convertArray(l, t.values.constructor), s.push(t)) } o.tracks = s; let a = 1 / 0; for (let c = 0; c < o.tracks.length; ++c)a > o.tracks[c].times[0] && (a = o.tracks[c].times[0]); for (let c = 0; c < o.tracks.length; ++c)o.tracks[c].shift(-1 * a); return o.resetDuration(), o }, makeClipAdditive: function (t, e, n, i) { void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30); const r = t.tracks.length, o = e / i; for (let s = 0; s < r; ++s) { const e = n.tracks[s], i = e.ValueTypeName; if ("bool" === i || "string" === i) continue; const r = t.tracks.find(function (t) { return t.name === e.name && t.ValueTypeName === i }); if (void 0 === r) continue; const a = e.getValueSize(), c = e.times.length - 1; let l; if (o <= e.times[0]) l = ed.arraySlice(e.values, 0, e.valueSize); else if (o >= e.times[c]) { const t = c * a; l = ed.arraySlice(e.values, t) } else { const t = e.createInterpolant(); t.evaluate(o), l = t.resultBuffer } if ("quaternion" === i) { new jn(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l) } const h = r.times.length; for (let t = 0; t < h; ++t) { const e = t * a; if ("quaternion" === i) jn.multiplyQuaternionsFlat(r.values, e, l, 0, r.values, e); else for (let t = 0; t < a; ++t)r.values[e + t] -= l[t] } } return t.blendMode = 2501, t } }; function nd(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n } function id(t, e, n, i) { nd.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function rd(t, e, n, i) { nd.call(this, t, e, n, i) } function od(t, e, n, i) { nd.call(this, t, e, n, i) } function sd(t, e, n, i) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = ed.convertArray(e, this.TimeBufferType), this.values = ed.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } function ad(t, e, n) { sd.call(this, t, e, n) } function cd(t, e, n, i) { sd.call(this, t, e, n, i) } function ld(t, e, n, i) { sd.call(this, t, e, n, i) } function hd(t, e, n, i) { nd.call(this, t, e, n, i) } function ud(t, e, n, i) { sd.call(this, t, e, n, i) } function pd(t, e, n, i) { sd.call(this, t, e, n, i) } function dd(t, e, n, i) { sd.call(this, t, e, n, i) } function fd(t, e, n, i) { this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : ke, this.uuid = In.generateUUID(), this.duration < 0 && this.resetDuration() } function md(t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return ld; case "vector": case "vector2": case "vector3": case "vector4": return dd; case "color": return cd; case "quaternion": return ud; case "bool": case "boolean": return ad; case "string": return pd }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) } function gd(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = md(t.type); if (void 0 === t.times) { const e = [], n = []; ed.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } exports.AnimationUtils = ed, Object.assign(nd.prototype, { evaluate: function (t) { let e = this.parameterPositions, n = this._cachedIndex, i = e[n], r = e[n - 1]; t: { e: { let o; n: { i: if (!(t < i)) { for (let o = n + 2; ;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === o) break; if (r = i, t < (i = e[++n])) break e } o = e.length; break n } if (t >= r) break t; { const s = e[1]; t < s && (n = 2, r = s); for (let o = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === o) break; if (i = r, t >= (r = e[--n - 1])) break e } o = n, n = 0 } } for (; n < o;) { const i = n + o >>> 1; t < e[i] ? o = i : n = i + 1 } if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, t, i) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i; for (let o = 0; o !== i; ++o)e[o] = n[r + o]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(nd.prototype, { beforeStart_: nd.prototype.copySampleValue_, afterEnd_: nd.prototype.copySampleValue_ }), id.prototype = Object.assign(Object.create(nd.prototype), { constructor: id, DefaultSettings_: { endingStart: Ge, endingEnd: Ge }, intervalChanged_: function (t, e, n) { let i = this.parameterPositions, r = t - 2, o = t + 1, s = i[r], a = i[o]; if (void 0 === s) switch (this.getSettings_().endingStart) { case 2401: r = t, s = 2 * e - n; break; case 2402: s = e + i[r = i.length - 2] - i[r + 1]; break; default: r = t, s = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case 2401: o = t, a = 2 * n - e; break; case 2402: o = 1, a = n + i[1] - i[0]; break; default: o = t - 1, a = e }const c = .5 * (n - e), l = this.valueSize; this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = o * l }, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - e) / (i - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f; for (let _ = 0; _ !== s; ++_)r[_] = g * o[l + _] + v * o[c + _] + y * o[a + _] + x * o[h + _]; return r } }), rd.prototype = Object.assign(Object.create(nd.prototype), { constructor: rd, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = (n - e) / (i - e), h = 1 - l; for (let u = 0; u !== s; ++u)r[u] = o[c + u] * h + o[a + u] * l; return r } }), od.prototype = Object.assign(Object.create(nd.prototype), { constructor: od, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(sd, { toJSON: function (t) { const e = t.constructor; let n; if (void 0 !== e.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: ed.convertArray(t.times, Array), values: ed.convertArray(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } }), Object.assign(sd.prototype, { constructor: sd, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new od(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new rd(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new id(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { let e; switch (t) { case 2300: e = this.InterpolantFactoryMethodDiscrete; break; case 2301: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] += t } return this }, scale: function (t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] *= t } return this }, trim: function (t, e) { const n = this.times, i = n.length; let r = 0, o = i - 1; for (; r !== i && n[r] < t;)++r; for (; -1 !== o && n[o] > e;)--o; if (++o, 0 !== r || o !== i) { r >= o && (r = (o = Math.max(o, 1)) - 1); const t = this.getValueSize(); this.times = ed.arraySlice(n, r, o), this.values = ed.arraySlice(this.values, r * t, o * t) } return this }, validate: function () { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let o = null; for (let s = 0; s !== r; s++) { const e = n[s]; if ("number" == typeof e && isNaN(e)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, e), t = !1; break } if (null !== o && o > e) { console.error("THREE.KeyframeTrack: Out of order keys.", this, s, e, o), t = !1; break } o = e } if (void 0 !== i && ed.isTypedArray(i)) for (let s = 0, a = i.length; s !== a; ++s) { const e = i[s]; if (isNaN(e)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, e), t = !1; break } } return t }, optimize: function () { const t = ed.arraySlice(this.times), e = ed.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = t.length - 1; let o = 1; for (let s = 1; s < r; ++s) { let r = !1; const a = t[s]; if (a !== t[s + 1] && (1 !== s || a !== a[0])) if (i) r = !0; else { const t = s * n, i = t - n, o = t + n; for (let s = 0; s !== n; ++s) { const n = e[t + s]; if (n !== e[i + s] || n !== e[o + s]) { r = !0; break } } } if (r) { if (s !== o) { t[o] = t[s]; const i = s * n, r = o * n; for (let t = 0; t !== n; ++t)e[r + t] = e[i + t] } ++o } } if (r > 0) { t[o] = t[r]; for (let t = r * n, i = o * n, s = 0; s !== n; ++s)e[i + s] = e[t + s]; ++o } return o !== t.length ? (this.times = ed.arraySlice(t, 0, o), this.values = ed.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this }, clone: function () { const t = ed.arraySlice(this.times, 0), e = ed.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } }), ad.prototype = Object.assign(Object.create(sd.prototype), { constructor: ad, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), cd.prototype = Object.assign(Object.create(sd.prototype), { constructor: cd, ValueTypeName: "color" }), ld.prototype = Object.assign(Object.create(sd.prototype), { constructor: ld, ValueTypeName: "number" }), hd.prototype = Object.assign(Object.create(nd.prototype), { constructor: hd, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (n - e) / (i - e); let c = t * s; for (let l = c + s; c !== l; c += 4)jn.slerpFlat(r, 0, o, c - s, o, c, a); return r } }), ud.prototype = Object.assign(Object.create(sd.prototype), { constructor: ud, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new hd(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), pd.prototype = Object.assign(Object.create(sd.prototype), { constructor: pd, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), dd.prototype = Object.assign(Object.create(sd.prototype), { constructor: dd, ValueTypeName: "vector" }), Object.assign(fd, { parse: function (t) { const e = [], n = t.tracks, i = 1 / (t.fps || 1); for (let r = 0, o = n.length; r !== o; ++r)e.push(gd(n[r]).scale(i)); return new fd(t.name, t.duration, e, t.blendMode) }, toJSON: function (t) { const e = [], n = t.tracks, i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let r = 0, o = n.length; r !== o; ++r)e.push(sd.toJSON(n[r])); return i }, CreateFromMorphTargetSequence: function (t, e, n, i) { const r = e.length, o = []; for (let s = 0; s < r; s++) { let t = [], a = []; t.push((s + r - 1) % r, s, (s + 1) % r), a.push(0, 1, 0); const c = ed.getKeyframeOrder(t); t = ed.sortedArray(t, 1, c), a = ed.sortedArray(a, 1, c), i || 0 !== t[0] || (t.push(r), a.push(a[0])), o.push(new ld(".morphTargetInfluences[" + e[s].name + "]", t, a).scale(1 / n)) } return new fd(t, -1, o) }, findByName: function (t, e) { let n = t; if (!Array.isArray(t)) { const e = t; n = e.geometry && e.geometry.animations || e.animations } for (let i = 0; i < n.length; i++)if (n[i].name === e) return n[i]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let s = 0, a = t.length; s < a; s++) { const e = t[s], n = e.name.match(r); if (n && n.length > 1) { const t = n[1]; let r = i[t]; r || (i[t] = r = []), r.push(e) } } const o = []; for (const s in i) o.push(fd.CreateFromMorphTargetSequence(s, i[s], e, n)); return o }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (t, e, n, i, r) { if (0 !== n.length) { const o = [], s = []; ed.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s)) } }, i = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode; let a = t.length || -1; const c = t.hierarchy || []; for (let l = 0; l < c.length; l++) { const t = c[l].keys; if (t && 0 !== t.length) if (t[0].morphTargets) { const e = {}; let n; for (n = 0; n < t.length; n++)if (t[n].morphTargets) for (let i = 0; i < t[n].morphTargets.length; i++)e[t[n].morphTargets[i]] = -1; for (const r in e) { const e = [], o = []; for (let i = 0; i !== t[n].morphTargets.length; ++i) { const i = t[n]; e.push(i.time), o.push(i.morphTarget === r ? 1 : 0) } i.push(new ld(".morphTargetInfluence[" + r + "]", e, o)) } a = e.length * (o || 1) } else { const r = ".bones[" + e[l].name + "]"; n(dd, r + ".position", t, "pos", i), n(ud, r + ".quaternion", t, "rot", i), n(dd, r + ".scale", t, "scl", i) } } return 0 === i.length ? null : new fd(r, a, i, s) } }), Object.assign(fd.prototype, { resetDuration: function () { let t = 0; for (let e = 0, n = this.tracks.length; e !== n; ++e) { const n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this }, trim: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new fd(this.name, this.duration, t, this.blendMode) } }); const vd = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; function yd(t, e, n) { const i = this; let r = !1, o = 0, s = 0, a = void 0; const c = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), r = !0 }, this.itemEnd = function (t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, s), o === s && (r = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function (t) { return a ? a(t) : t }, this.setURLModifier = function (t) { return a = t, this }, this.addHandler = function (t, e) { return c.push(t, e), this }, this.removeHandler = function (t) { const e = c.indexOf(t); return -1 !== e && c.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = c.length; e < n; e += 2) { const n = c[e], i = c[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return i } return null } } exports.Cache = vd; const xd = new yd; function _d(t) { this.manager = void 0 !== t ? t : xd, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {} } exports.DefaultLoadingManager = xd, Object.assign(_d.prototype, { load: function () { }, loadAsync: function (t, e) { const n = this; return new Promise(function (i, r) { n.load(t, i, e, r) }) }, parse: function () { }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }); const bd = {}; function wd(t) { _d.call(this, t) } function Md(t) { _d.call(this, t) } function Sd(t) { _d.call(this, t) } function Td(t) { _d.call(this, t) } function Ed(t) { _d.call(this, t) } function Ad(t) { _d.call(this, t) } function Ld(t) { _d.call(this, t) } function Rd() { this.type = "Curve", this.arcLengthDivisions = 200 } function Cd(t, e, n, i, r, o, s, a) { Rd.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0 } function Pd(t, e, n, i, r, o) { Cd.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve" } function Od() { let t = 0, e = 0, n = 0, i = 0; function r(r, o, s, a) { t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a } return { initCatmullRom: function (t, e, n, i, o) { r(e, n, o * (n - t), o * (i - e)) }, initNonuniformCatmullRom: function (t, e, n, i, o, s, a) { let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s, l = (n - e) / s - (i - e) / (s + a) + (i - n) / a; r(e, n, c *= s, l *= s) }, calc: function (r) { const o = r * r; return t + e * r + n * o + i * (o * r) } } } wd.prototype = Object.assign(Object.create(_d.prototype), { constructor: wd, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = vd.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; if (void 0 !== bd[t]) return void bd[t].push({ onLoad: e, onProgress: n, onError: i }); const s = t.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (s) { const n = s[1], o = !!s[2]; let a = s[3]; a = decodeURIComponent(a), o && (a = atob(a)); try { let o; const s = (this.responseType || "").toLowerCase(); switch (s) { case "arraybuffer": case "blob": const t = new Uint8Array(a.length); for (let n = 0; n < a.length; n++)t[n] = a.charCodeAt(n); o = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer; break; case "document": const e = new DOMParser; o = e.parseFromString(a, n); break; case "json": o = JSON.parse(a); break; default: o = a }setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0) } catch (c) { setTimeout(function () { i && i(c), r.manager.itemError(t), r.manager.itemEnd(t) }, 0) } } else { bd[t] = [], bd[t].push({ onLoad: e, onProgress: n, onError: i }), (a = new XMLHttpRequest).open("GET", t, !0), a.addEventListener("load", function (e) { const n = this.response, i = bd[t]; if (delete bd[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), vd.add(t, n); for (let t = 0, e = i.length; t < e; t++) { const e = i[t]; e.onLoad && e.onLoad(n) } r.manager.itemEnd(t) } else { for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; n.onError && n.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) } }, !1), a.addEventListener("progress", function (e) { const n = bd[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onProgress && i.onProgress(e) } }, !1), a.addEventListener("error", function (e) { const n = bd[t]; delete bd[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }, !1), a.addEventListener("abort", function (e) { const n = bd[t]; delete bd[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }, !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]); a.send(null) } return r.manager.itemStart(t), a }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this } }), Md.prototype = Object.assign(Object.create(_d.prototype), { constructor: Md, load: function (t, e, n, i) { const r = this, o = new wd(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (o) { i ? i(o) : console.error(o), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = []; for (let n = 0; n < t.length; n++) { const i = fd.parse(t[n]); e.push(i) } return e } }), Sd.prototype = Object.assign(Object.create(_d.prototype), { constructor: Sd, load: function (t, e, n, i) { const r = this, o = [], s = new yu; s.image = o; const a = new wd(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader); let c = 0; function l(l) { a.load(t[l], function (t) { const n = r.parse(t, !0); o[l] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (c += 1) && (1 === n.mipmapCount && (s.minFilter = gt), s.format = n.format, s.needsUpdate = !0, e && e(s)) }, n, i) } if (Array.isArray(t)) for (let h = 0, u = t.length; h < u; ++h)l(h); else a.load(t, function (t) { const n = r.parse(t, !0); if (n.isCubemap) { const t = n.mipmaps.length / n.mipmapCount; for (let e = 0; e < t; e++) { o[e] = { mipmaps: [] }; for (let t = 0; t < n.mipmapCount; t++)o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height } } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps; 1 === n.mipmapCount && (s.minFilter = gt), s.format = n.format, s.needsUpdate = !0, e && e(s) }, n, i); return s } }), Td.prototype = Object.assign(Object.create(_d.prototype), { constructor: Td, load: function (t, e, n, i) { const r = this, o = new Eo, s = new wd(this.manager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.load(t, function (t) { const n = r.parse(t); n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : lt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : lt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : gt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : gt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = xt), 1 === n.mipmapCount && (o.minFilter = gt), o.needsUpdate = !0, e && e(o, n)) }, n, i), o } }), Ed.prototype = Object.assign(Object.create(_d.prototype), { constructor: Ed, load: function (t, e, n, i) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = vd.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), vd.add(t, this), e && e(this), r.manager.itemEnd(t) } function c(e) { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) } return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s } }), Ad.prototype = Object.assign(Object.create(_d.prototype), { constructor: Ad, load: function (t, e, n, i) { const r = new vc, o = new Ed(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let s = 0; function a(n) { o.load(t[n], function (t) { r.images[n] = t, 6 === ++s && (r.needsUpdate = !0, e && e(r)) }, void 0, i) } for (let c = 0; c < t.length; ++c)a(c); return r } }), Ld.prototype = Object.assign(Object.create(_d.prototype), { constructor: Ld, load: function (t, e, n, i) { const r = new zn, o = new Ed(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (n) { r.image = n; const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); r.format = i ? It : Nt, r.needsUpdate = !0, void 0 !== e && e(r) }, n, i), r } }), Object.assign(Rd.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }, getPoints: function (t) { void 0 === t && (t = 5); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e }, getSpacedPoints: function (t) { void 0 === t && (t = 5); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e }, getLength: function () { const t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const e = []; let n, i = this.getPoint(0), r = 0; e.push(0); for (let o = 1; o <= t; o++)r += (n = this.getPoint(o / t)).distanceTo(i), e.push(r), i = n; return this.cacheArcLengths = e, e }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { const n = this.getLengths(); let i, r = 0, o = n.length; i = e || t * n[o - 1]; let s, a = 0, c = o - 1; for (; a <= c;)if ((s = n[r = Math.floor(a + (c - a) / 2)] - i) < 0) a = r + 1; else { if (!(s > 0)) { c = r; break } c = r - 1 } if (n[r = c] === i) return r / (o - 1); const l = n[r]; return (r + (i - l) / (n[r + 1] - l)) / (o - 1) }, getTangent: function (t, e) { let n = t - 1e-4, i = t + 1e-4; n < 0 && (n = 0), i > 1 && (i = 1); const r = this.getPoint(n), o = this.getPoint(i), s = e || (r.isVector2 ? new Nn : new Xn); return s.copy(o).sub(r).normalize(), s }, getTangentAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }, computeFrenetFrames: function (t, e) { const n = new Xn, i = [], r = [], o = [], s = new Xn, a = new ei; for (let p = 0; p <= t; p++) { const e = p / t; i[p] = this.getTangentAt(e, new Xn), i[p].normalize() } r[0] = new Xn, o[0] = new Xn; let c = Number.MAX_VALUE; const l = Math.abs(i[0].x), h = Math.abs(i[0].y), u = Math.abs(i[0].z); l <= c && (c = l, n.set(1, 0, 0)), h <= c && (c = h, n.set(0, 1, 0)), u <= c && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]); for (let p = 1; p <= t; p++) { if (r[p] = r[p - 1].clone(), o[p] = o[p - 1].clone(), s.crossVectors(i[p - 1], i[p]), s.length() > Number.EPSILON) { s.normalize(); const t = Math.acos(In.clamp(i[p - 1].dot(i[p]), -1, 1)); r[p].applyMatrix4(a.makeRotationAxis(s, t)) } o[p].crossVectors(i[p], r[p]) } if (!0 === e) { let e = Math.acos(In.clamp(r[0].dot(r[t]), -1, 1)); e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e); for (let n = 1; n <= t; n++)r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: o } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), Cd.prototype = Object.create(Rd.prototype), Cd.prototype.constructor = Cd, Cd.prototype.isEllipseCurve = !0, Cd.prototype.getPoint = function (t, e) { const n = e || new Nn, i = 2 * Math.PI; let r = this.aEndAngle - this.aStartAngle; const o = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i); const s = this.aStartAngle + t * r; let a = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s); if (0 !== this.aRotation) { const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, i = c - this.aY; a = n * t - i * e + this.aX, c = n * e + i * t + this.aY } return n.set(a, c) }, Cd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Cd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Cd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Pd.prototype = Object.create(Cd.prototype), Pd.prototype.constructor = Pd, Pd.prototype.isArcCurve = !0; const Dd = new Xn, Id = new Od, Nd = new Od, Bd = new Od; function Fd(t, e, n, i) { Rd.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== i ? i : .5 } function Ud(t, e, n, i, r) { const o = .5 * (i - e), s = .5 * (r - n), a = t * t; return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n } function Gd(t, e) { const n = 1 - t; return n * n * e } function zd(t, e) { return 2 * (1 - t) * t * e } function Hd(t, e) { return t * t * e } function kd(t, e, n, i) { return Gd(t, e) + zd(t, n) + Hd(t, i) } function Vd(t, e) { const n = 1 - t; return n * n * n * e } function jd(t, e) { const n = 1 - t; return 3 * n * n * t * e } function Wd(t, e) { return 3 * (1 - t) * t * t * e } function qd(t, e) { return t * t * t * e } function Xd(t, e, n, i, r) { return Vd(t, e) + jd(t, n) + Wd(t, i) + qd(t, r) } function Yd(t, e, n, i) { Rd.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Nn, this.v1 = e || new Nn, this.v2 = n || new Nn, this.v3 = i || new Nn } function Zd(t, e, n, i) { Rd.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Xn, this.v1 = e || new Xn, this.v2 = n || new Xn, this.v3 = i || new Xn } function Jd(t, e) { Rd.call(this), this.type = "LineCurve", this.v1 = t || new Nn, this.v2 = e || new Nn } function Qd(t, e) { Rd.call(this), this.type = "LineCurve3", this.v1 = t || new Xn, this.v2 = e || new Xn } function Kd(t, e, n) { Rd.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Nn, this.v1 = e || new Nn, this.v2 = n || new Nn } function $d(t, e, n) { Rd.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Xn, this.v1 = e || new Xn, this.v2 = n || new Xn } function tf(t) { Rd.call(this), this.type = "SplineCurve", this.points = t || [] } Fd.prototype = Object.create(Rd.prototype), Fd.prototype.constructor = Fd, Fd.prototype.isCatmullRomCurve3 = !0, Fd.prototype.getPoint = function (t, e) { const n = e || new Xn, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * t; let s, a, c, l, h = Math.floor(o), u = o - h; if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / r) + 1) * r : 0 === u && h === r - 1 && (h = r - 2, u = 1), this.closed || h > 0 ? s = i[(h - 1) % r] : (Dd.subVectors(i[0], i[1]).add(i[0]), s = Dd), a = i[h % r], c = i[(h + 1) % r], this.closed || h + 2 < r ? l = i[(h + 2) % r] : (Dd.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), l = Dd), "centripetal" === this.curveType || "chordal" === this.curveType) { const t = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(s.distanceToSquared(a), t), n = Math.pow(a.distanceToSquared(c), t), i = Math.pow(c.distanceToSquared(l), t); n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Id.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i), Nd.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i), Bd.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i) } else "catmullrom" === this.curveType && (Id.initCatmullRom(s.x, a.x, c.x, l.x, this.tension), Nd.initCatmullRom(s.y, a.y, c.y, l.y, this.tension), Bd.initCatmullRom(s.z, a.z, c.z, l.z, this.tension)); return n.set(Id.calc(u), Nd.calc(u), Bd.calc(u)), n }, Fd.prototype.copy = function (t) { Rd.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Fd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, Fd.prototype.fromJSON = function (t) { Rd.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new Xn).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Yd.prototype = Object.create(Rd.prototype), Yd.prototype.constructor = Yd, Yd.prototype.isCubicBezierCurve = !0, Yd.prototype.getPoint = function (t, e) { const n = e || new Nn, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(Xd(t, i.x, r.x, o.x, s.x), Xd(t, i.y, r.y, o.y, s.y)), n }, Yd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Yd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Yd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Zd.prototype = Object.create(Rd.prototype), Zd.prototype.constructor = Zd, Zd.prototype.isCubicBezierCurve3 = !0, Zd.prototype.getPoint = function (t, e) { const n = e || new Xn, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(Xd(t, i.x, r.x, o.x, s.x), Xd(t, i.y, r.y, o.y, s.y), Xd(t, i.z, r.z, o.z, s.z)), n }, Zd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Zd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Zd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Jd.prototype = Object.create(Rd.prototype), Jd.prototype.constructor = Jd, Jd.prototype.isLineCurve = !0, Jd.prototype.getPoint = function (t, e) { const n = e || new Nn; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, Jd.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Jd.prototype.getTangent = function (t, e) { const n = e || new Nn; return n.copy(this.v2).sub(this.v1).normalize(), n }, Jd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Jd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Jd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Qd.prototype = Object.create(Rd.prototype), Qd.prototype.constructor = Qd, Qd.prototype.isLineCurve3 = !0, Qd.prototype.getPoint = function (t, e) { const n = e || new Xn; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, Qd.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Qd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Qd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Qd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Kd.prototype = Object.create(Rd.prototype), Kd.prototype.constructor = Kd, Kd.prototype.isQuadraticBezierCurve = !0, Kd.prototype.getPoint = function (t, e) { const n = e || new Nn, i = this.v0, r = this.v1, o = this.v2; return n.set(kd(t, i.x, r.x, o.x), kd(t, i.y, r.y, o.y)), n }, Kd.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Kd.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Kd.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, $d.prototype = Object.create(Rd.prototype), $d.prototype.constructor = $d, $d.prototype.isQuadraticBezierCurve3 = !0, $d.prototype.getPoint = function (t, e) { const n = e || new Xn, i = this.v0, r = this.v1, o = this.v2; return n.set(kd(t, i.x, r.x, o.x), kd(t, i.y, r.y, o.y), kd(t, i.z, r.z, o.z)), n }, $d.prototype.copy = function (t) { return Rd.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, $d.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, $d.prototype.fromJSON = function (t) { return Rd.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, tf.prototype = Object.create(Rd.prototype), tf.prototype.constructor = tf, tf.prototype.isSplineCurve = !0, tf.prototype.getPoint = function (t, e) { const n = e || new Nn, i = this.points, r = (i.length - 1) * t, o = Math.floor(r), s = r - o, a = i[0 === o ? o : o - 1], c = i[o], l = i[o > i.length - 2 ? i.length - 1 : o + 1], h = i[o > i.length - 3 ? i.length - 1 : o + 2]; return n.set(Ud(s, a.x, c.x, l.x, h.x), Ud(s, a.y, c.y, l.y, h.y)), n }, tf.prototype.copy = function (t) { Rd.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this }, tf.prototype.toJSON = function () { const t = Rd.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t }, tf.prototype.fromJSON = function (t) { Rd.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new Nn).fromArray(n)) } return this }; var ef = Object.freeze({ __proto__: null, ArcCurve: Pd, CatmullRomCurve3: Fd, CubicBezierCurve: Yd, CubicBezierCurve3: Zd, EllipseCurve: Cd, LineCurve: Jd, LineCurve3: Qd, QuadraticBezierCurve: Kd, QuadraticBezierCurve3: $d, SplineCurve: tf }); function nf() { Rd.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function rf(t) { nf.call(this), this.type = "Path", this.currentPoint = new Nn, t && this.setFromPoints(t) } function of(t) { rf.call(this, t), this.uuid = In.generateUUID(), this.type = "Shape", this.holes = [] } function sf(t, e) { xi.call(this), this.type = "Light", this.color = new hr(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function af(t, e, n) { sf.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(xi.DefaultUp), this.updateMatrix(), this.groundColor = new hr(e) } function cf(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Nn(512, 512), this.map = null, this.mapPass = null, this.matrix = new ei, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ro, this._frameExtents = new Nn(1, 1), this._viewportCount = 1, this._viewports = [new Hn(0, 0, 1, 1)] } function lf() { cf.call(this, new bo(50, 1, .5, 500)) } function hf(t, e, n, i, r, o) { sf.call(this, t, e), this.type = "SpotLight", this.position.copy(xi.DefaultUp), this.updateMatrix(), this.target = new xi, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new lf } function uf() { cf.call(this, new bo(90, 1, .5, 500)), this._frameExtents = new Nn(4, 2), this._viewportCount = 6, this._viewports = [new Hn(2, 1, 1, 1), new Hn(0, 1, 1, 1), new Hn(3, 1, 1, 1), new Hn(1, 1, 1, 1), new Hn(3, 0, 1, 1), new Hn(1, 0, 1, 1)], this._cubeDirections = [new Xn(1, 0, 0), new Xn(-1, 0, 0), new Xn(0, 0, 1), new Xn(0, 0, -1), new Xn(0, 1, 0), new Xn(0, -1, 0)], this._cubeUps = [new Xn(0, 1, 0), new Xn(0, 1, 0), new Xn(0, 1, 0), new Xn(0, 1, 0), new Xn(0, 0, 1), new Xn(0, 0, -1)] } function pf(t, e, n, i) { sf.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new uf } function df(t, e, n, i, r, o) { _o.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() } function ff() { cf.call(this, new df(-5, 5, 5, -5, .5, 500)) } function mf(t, e) { sf.call(this, t, e), this.type = "DirectionalLight", this.position.copy(xi.DefaultUp), this.updateMatrix(), this.target = new xi, this.shadow = new ff } function gf(t, e) { sf.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function vf(t, e, n, i) { sf.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 } function yf() { this.coefficients = []; for (let t = 0; t < 9; t++)this.coefficients.push(new Xn) } function xf(t, e) { sf.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new yf } function _f(t) { _d.call(this, t), this.textures = {} } nf.prototype = Object.assign(Object.create(Rd.prototype), { constructor: nf, add: function (t) { this.curves.push(t) }, closePath: function () { const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Jd(e, t)) }, getPoint: function (t) { const e = t * this.getLength(), n = this.getCurveLengths(); let i = 0; for (; i < n.length;) { if (n[i] >= e) { const t = n[i] - e, r = this.curves[i], o = r.getLength(), s = 0 === o ? 0 : 1 - t / o; return r.getPointAt(s) } i++ } return null }, getLength: function () { const t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }, getSpacedPoints: function (t) { void 0 === t && (t = 40); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; const e = []; let n; for (let i = 0, r = this.curves; i < r.length; i++) { const o = r[i], s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, a = o.getPoints(s); for (let t = 0; t < a.length; t++) { const i = a[t]; n && n.equals(i) || (e.push(i), n = i) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e }, copy: function (t) { Rd.prototype.copy.call(this, t), this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push(n.clone()) } return this.autoClose = t.autoClose, this }, toJSON: function () { const t = Rd.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (let e = 0, n = this.curves.length; e < n; e++) { const n = this.curves[e]; t.curves.push(n.toJSON()) } return t }, fromJSON: function (t) { Rd.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push((new ef[n.type]).fromJSON(n)) } return this } }), rf.prototype = Object.assign(Object.create(nf.prototype), { constructor: rf, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y); return this }, moveTo: function (t, e) { return this.currentPoint.set(t, e), this }, lineTo: function (t, e) { const n = new Jd(this.currentPoint.clone(), new Nn(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }, quadraticCurveTo: function (t, e, n, i) { const r = new Kd(this.currentPoint.clone(), new Nn(t, e), new Nn(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { const s = new Yd(this.currentPoint.clone(), new Nn(t, e), new Nn(n, i), new Nn(r, o)); return this.curves.push(s), this.currentPoint.set(r, o), this }, splineThru: function (t) { const e = new tf([this.currentPoint.clone()].concat(t)); return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this }, arc: function (t, e, n, i, r, o) { const s = this.currentPoint.x, a = this.currentPoint.y; return this.absarc(t + s, e + a, n, i, r, o), this }, absarc: function (t, e, n, i, r, o) { return this.absellipse(t, e, n, n, i, r, o), this }, ellipse: function (t, e, n, i, r, o, s, a) { const c = this.currentPoint.x, l = this.currentPoint.y; return this.absellipse(t + c, e + l, n, i, r, o, s, a), this }, absellipse: function (t, e, n, i, r, o, s, a) { const c = new Cd(t, e, n, i, r, o, s, a); if (this.curves.length > 0) { const t = c.getPoint(0); t.equals(this.currentPoint) || this.lineTo(t.x, t.y) } this.curves.push(c); const l = c.getPoint(1); return this.currentPoint.copy(l), this }, copy: function (t) { return nf.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { const t = nf.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return nf.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), of.prototype = Object.assign(Object.create(rf.prototype), { constructor: of, getPointsHoles: function (t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { rf.prototype.copy.call(this, t), this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push(n.clone()) } return this }, toJSON: function () { const t = rf.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (let e = 0, n = this.holes.length; e < n; e++) { const n = this.holes[e]; t.holes.push(n.toJSON()) } return t }, fromJSON: function (t) { rf.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push((new rf).fromJSON(n)) } return this } }), sf.prototype = Object.assign(Object.create(xi.prototype), { constructor: sf, isLight: !0, copy: function (t) { return xi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { const e = xi.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), af.prototype = Object.assign(Object.create(sf.prototype), { constructor: af, isHemisphereLight: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(cf.prototype, { _projScreenMatrix: new ei, _lightPositionWorld: new Xn, _lookTarget: new Xn, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (t) { const e = this.camera, n = this.matrix, i = this._projScreenMatrix, r = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse) }, getViewport: function (t) { return this._viewports[t] }, getFrameExtents: function () { return this._frameExtents }, copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), lf.prototype = Object.assign(Object.create(cf.prototype), { constructor: lf, isSpotLightShadow: !0, updateMatrices: function (t) { const e = this.camera, n = 2 * In.RAD2DEG * t.angle, i = this.mapSize.width / this.mapSize.height, r = t.distance || e.far; n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), cf.prototype.updateMatrices.call(this, t) } }), hf.prototype = Object.assign(Object.create(sf.prototype), { constructor: hf, isSpotLight: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), uf.prototype = Object.assign(Object.create(cf.prototype), { constructor: uf, isPointLightShadow: !0, updateMatrices: function (t, e) { void 0 === e && (e = 0); const n = this.camera, i = this.matrix, r = this._lightPositionWorld, o = this._lookTarget, s = this._projScreenMatrix; r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s) } }), pf.prototype = Object.assign(Object.create(sf.prototype), { constructor: pf, isPointLight: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), df.prototype = Object.assign(Object.create(_o.prototype), { constructor: df, isOrthographicCamera: !0, copy: function (t, e) { return _o.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, n, i, r, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - t, o = n + t, s = i + e, a = i - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; o = (r += t * this.view.offsetX) + t * this.view.width, a = (s -= e * this.view.offsetY) - e * this.view.height } this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = xi.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), ff.prototype = Object.assign(Object.create(cf.prototype), { constructor: ff, isDirectionalLightShadow: !0, updateMatrices: function (t) { cf.prototype.updateMatrices.call(this, t) } }), mf.prototype = Object.assign(Object.create(sf.prototype), { constructor: mf, isDirectionalLight: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), gf.prototype = Object.assign(Object.create(sf.prototype), { constructor: gf, isAmbientLight: !0 }), vf.prototype = Object.assign(Object.create(sf.prototype), { constructor: vf, isRectAreaLight: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { const e = sf.prototype.toJSON.call(this, t); return e.object.width = this.width, e.object.height = this.height, e } }), Object.assign(yf.prototype, { isSphericalHarmonics3: !0, set: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this }, zero: function () { for (let t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0); return this }, getAt: function (t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e }, getIrradianceAt: function (t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e }, add: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this }, addScaledSH: function (t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }, scale: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this }, lerp: function (t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(t.coefficients[n], e); return this }, equals: function (t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 }, copy: function (t) { return this.set(t.coefficients) }, clone: function () { return (new this.constructor).copy(this) }, fromArray: function (t, e) { void 0 === e && (e = 0); const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].fromArray(t, e + 3 * i); return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].toArray(t, e + 3 * i); return t } }), Object.assign(yf, { getBasisAt: function (t, e) { const n = t.x, i = t.y, r = t.z; e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i) } }), xf.prototype = Object.assign(Object.create(sf.prototype), { constructor: xf, isLightProbe: !0, copy: function (t) { return sf.prototype.copy.call(this, t), this.sh.copy(t.sh), this }, fromJSON: function (t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }, toJSON: function (t) { const e = sf.prototype.toJSON.call(this, t); return e.object.sh = this.sh.toArray(), e } }), _f.prototype = Object.assign(Object.create(_d.prototype), { constructor: _f, load: function (t, e, n, i) { const r = this, o = new wd(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (o) { i ? i(o) : console.error(o), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = this.textures; function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } const i = new td[t.type]; if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new hr).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const r in t.uniforms) { const e = t.uniforms[r]; switch (i.uniforms[r] = {}, e.type) { case "t": i.uniforms[r].value = n(e.value); break; case "c": i.uniforms[r].value = (new hr).setHex(e.value); break; case "v2": i.uniforms[r].value = (new Nn).fromArray(e.value); break; case "v3": i.uniforms[r].value = (new Xn).fromArray(e.value); break; case "v4": i.uniforms[r].value = (new Hn).fromArray(e.value); break; case "m3": i.uniforms[r].value = (new Bn).fromArray(e.value); case "m4": i.uniforms[r].value = (new ei).fromArray(e.value); break; default: i.uniforms[r].value = e.value } } if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const r in t.extensions) i.extensions[r] = t.extensions[r]; if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale; !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Nn).fromArray(e) } return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Nn).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i }, setTextures: function (t) { return this.textures = t, this } }); const bf = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let i = 0, r = t.length; i < r; i++)e += String.fromCharCode(t[i]); try { return decodeURIComponent(escape(e)) } catch (n) { return e } }, extractUrlBase: function (t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; function wf() { Gr.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } function Mf(t, e, n, i) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), _r.call(this, t, e, n), this.meshPerAttribute = i || 1 } function Sf(t) { _d.call(this, t) } exports.LoaderUtils = bf, wf.prototype = Object.assign(Object.create(Gr.prototype), { constructor: wf, isInstancedBufferGeometry: !0, copy: function (t) { return Gr.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = Gr.prototype.toJSON.call(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }), Mf.prototype = Object.assign(Object.create(_r.prototype), { constructor: Mf, isInstancedBufferAttribute: !0, copy: function (t) { return _r.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function () { const t = _r.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), Sf.prototype = Object.assign(Object.create(_d.prototype), { constructor: Sf, load: function (t, e, n, i) { const r = this, o = new wd(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (o) { i ? i(o) : console.error(o), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = {}, n = {}; function i(t, i) { if (void 0 !== e[i]) return e[i]; const r = t.interleavedBuffers[i], o = function (t, e) { if (void 0 !== n[e]) return n[e]; const i = t.arrayBuffers[e], r = new Uint32Array(i).buffer; return n[e] = r, r }(t, r.buffer), s = new bh(new Tf[r.type](o), r.stride); return s.uuid = r.uuid, e[i] = s, s } const r = t.isInstancedBufferGeometry ? new wf : new Gr, o = t.data.index; if (void 0 !== o) { const t = new Tf[o.type](o.array); r.setIndex(new _r(t, 1)) } const s = t.data.attributes; for (const h in s) { const e = s[h]; let n; if (e.isInterleavedBufferAttribute) { n = new Mh(i(t.data, e.data), e.itemSize, e.offset, e.normalized) } else { const t = new Tf[e.type](e.array); n = new (e.isInstancedBufferAttribute ? Mf : _r)(t, e.itemSize, e.normalized) } void 0 !== e.name && (n.name = e.name), r.setAttribute(h, n) } const a = t.data.morphAttributes; if (a) for (const h in a) { const e = a[h], n = []; for (let r = 0, o = e.length; r < o; r++) { const o = e[r]; let s; if (o.isInterleavedBufferAttribute) { s = new Mh(i(t.data, o.data), o.itemSize, o.offset, o.normalized) } else { s = new _r(new Tf[o.type](o.array), o.itemSize, o.normalized) } void 0 !== o.name && (s.name = o.name), n.push(s) } r.morphAttributes[h] = n } t.data.morphTargetsRelative && (r.morphTargetsRelative = !0); const c = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== c) for (let h = 0, u = c.length; h !== u; ++h) { const t = c[h]; r.addGroup(t.start, t.count, t.materialIndex) } const l = t.data.boundingSphere; if (void 0 !== l) { const t = new Xn; void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new Fi(t, l.radius) } return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r } }); const Tf = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Ef(t) { _d.call(this, t) } Ef.prototype = Object.assign(Object.create(_d.prototype), { constructor: Ef, load: function (t, e, n, i) { const r = this, o = "" === this.path ? bf.extractUrlBase(t) : this.path; this.resourcePath = this.resourcePath || o; const s = new wd(r.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.load(t, function (n) { let o = null; try { o = JSON.parse(n) } catch (a) { return void 0 !== i && i(a), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", a.message) } const s = o.metadata; void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t) }, n, i) }, parse: function (t, e) { const n = this.parseShape(t.shapes), i = this.parseGeometries(t.geometries, n), r = this.parseImages(t.images, function () { void 0 !== e && e(a) }), o = this.parseTextures(t.textures, r), s = this.parseMaterials(t.materials, o), a = this.parseObject(t.object, i, s); return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a }, parseShape: function (t) { const e = {}; if (void 0 !== t) for (let n = 0, i = t.length; n < i; n++) { const i = (new of).fromJSON(t[n]); e[i.uuid] = i } return e }, parseGeometries: function (t, e) { const n = {}; let i; if (void 0 !== t) { const r = new Sf; for (let o = 0, s = t.length; o < s; o++) { let s; const a = t[o]; switch (a.type) { case "PlaneGeometry": case "PlaneBufferGeometry": s = new Vp[a.type](a.width, a.height, a.widthSegments, a.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": s = new Vp[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": s = new Vp[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": s = new Vp[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": s = new Vp[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": s = new Vp[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": s = new Vp[a.type](a.radius, a.detail); break; case "RingGeometry": case "RingBufferGeometry": s = new Vp[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": s = new Vp[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": s = new Vp[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q); break; case "TubeGeometry": case "TubeBufferGeometry": s = new Vp[a.type]((new ef[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed); break; case "LatheGeometry": case "LatheBufferGeometry": s = new Vp[a.type](a.points, a.segments, a.phiStart, a.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": s = new Vp[a.type](a.vertices, a.indices, a.radius, a.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": i = []; for (let n = 0, r = a.shapes.length; n < r; n++) { const t = e[a.shapes[n]]; i.push(t) } s = new Vp[a.type](i, a.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": i = []; for (let n = 0, r = a.shapes.length; n < r; n++) { const t = e[a.shapes[n]]; i.push(t) } const t = a.options.extrudePath; void 0 !== t && (a.options.extrudePath = (new ef[t.type]).fromJSON(t)), s = new Vp[a.type](i, a.options); break; case "BufferGeometry": case "InstancedBufferGeometry": s = r.parse(a); break; case "Geometry": console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"'); continue }s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s } } return n }, parseMaterials: function (t, e) { const n = {}, i = {}; if (void 0 !== t) { const r = new _f; r.setTextures(e); for (let e = 0, o = t.length; e < o; e++) { const o = t[e]; if ("MultiMaterial" === o.type) { const t = []; for (let e = 0; e < o.materials.length; e++) { const i = o.materials[e]; void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid]) } i[o.uuid] = t } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid] } } return i }, parseAnimations: function (t) { const e = []; for (let n = 0; n < t.length; n++) { const i = t[n], r = fd.parse(i); void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r) } return e }, parseImages: function (t, e) { const n = this, i = {}; let r; function o(t) { return n.manager.itemStart(t), r.load(t, function () { n.manager.itemEnd(t) }, void 0, function () { n.manager.itemError(t), n.manager.itemEnd(t) }) } if (void 0 !== t && t.length > 0) { const s = new yd(e); (r = new Ed(s)).setCrossOrigin(this.crossOrigin); for (let e = 0, r = t.length; e < r; e++) { const r = t[e], s = r.url; if (Array.isArray(s)) { i[r.uuid] = []; for (let t = 0, e = s.length; t < e; t++) { const e = s[t], a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e; i[r.uuid].push(o(a)) } } else { const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url) ? r.url : n.resourcePath + r.url; i[r.uuid] = o(t) } } } return i }, parseTextures: function (t, e) { function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) } const i = {}; if (void 0 !== t) for (let r = 0, o = t.length; r < o; r++) { const o = t[r]; let s; void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), (s = Array.isArray(e[o.image]) ? new vc(e[o.image]) : new zn(e[o.image])).needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, Af)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], Lf), s.wrapT = n(o.wrap[1], Lf)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Rf)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Rf)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), i[o.uuid] = s } return i }, parseObject: function (t, e, n) { let i, r, o; function s(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] } function a(t) { if (void 0 !== t) { if (Array.isArray(t)) { const e = []; for (let i = 0, r = t.length; i < r; i++) { const r = t[i]; void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r]) } return e } return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t] } } switch (t.type) { case "Scene": i = new _i, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new hr(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new _h(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new xh(t.fog.color, t.fog.density))); break; case "PerspectiveCamera": i = new bo(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view)); break; case "OrthographicCamera": i = new df(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view)); break; case "AmbientLight": i = new gf(t.color, t.intensity); break; case "DirectionalLight": i = new mf(t.color, t.intensity); break; case "PointLight": i = new pf(t.color, t.intensity, t.distance, t.decay); break; case "RectAreaLight": i = new vf(t.color, t.intensity, t.width, t.height); break; case "SpotLight": i = new hf(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay); break; case "HemisphereLight": i = new af(t.color, t.groundColor, t.intensity); break; case "LightProbe": i = (new xf).fromJSON(t); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": i = new io(r = s(t.geometry), o = a(t.material)); break; case "InstancedMesh": r = s(t.geometry), o = a(t.material); const e = t.count, n = t.instanceMatrix; (i = new Kh(r, o, e)).instanceMatrix = new _r(new Float32Array(n.array), 16); break; case "LOD": i = new kh; break; case "Line": i = new ou(s(t.geometry), a(t.material), t.mode); break; case "LineLoop": i = new lu(s(t.geometry), a(t.material)); break; case "LineSegments": i = new cu(s(t.geometry), a(t.material)); break; case "PointCloud": case "Points": i = new mu(s(t.geometry), a(t.material)); break; case "Sprite": i = new Uh(a(t.material)); break; case "Group": i = new dh; break; default: i = new xi }if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (i.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) { const r = t.children; for (let t = 0; t < r.length; t++)i.add(this.parseObject(r[t], e, n)) } if ("LOD" === t.type) { void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate); const e = t.levels; for (let t = 0; t < e.length; t++) { const n = e[t], r = i.getObjectByProperty("uuid", n.object); void 0 !== r && i.addLevel(r, n.distance) } } return i } }); const Af = { UVMapping: 300, CubeReflectionMapping: nt, CubeRefractionMapping: it, EquirectangularReflectionMapping: rt, EquirectangularRefractionMapping: ot, CubeUVReflectionMapping: st, CubeUVRefractionMapping: at }, Lf = { RepeatWrapping: ct, ClampToEdgeWrapping: lt, MirroredRepeatWrapping: ht }, Rf = { NearestFilter: ut, NearestMipmapNearestFilter: pt, NearestMipmapLinearFilter: ft, LinearFilter: gt, LinearMipmapNearestFilter: vt, LinearMipmapLinearFilter: xt }; function Cf(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), _d.call(this, t), this.options = { premultiplyAlpha: "none" } } function Pf() { this.type = "ShapePath", this.color = new hr, this.subPaths = [], this.currentPath = null } function Of(t) { this.type = "Font", this.data = t } function Df(t, e, n) { const i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, s = []; let a = 0, c = 0; for (let l = 0; l < i.length; l++) { const t = i[l]; if ("\n" === t) a = 0, c -= o; else { const e = If(t, r, a, c, n); a += e.offsetX, s.push(e.path) } } return s } function If(t, e, n, i, r) { const o = r.glyphs[t] || r.glyphs["?"]; if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + "."); const s = new Pf; let a, c, l, h, u, p, d, f; if (o.o) { const t = o._cachedOutline || (o._cachedOutline = o.o.split(" ")); for (let r = 0, o = t.length; r < o;) { switch (t[r++]) { case "m": a = t[r++] * e + n, c = t[r++] * e + i, s.moveTo(a, c); break; case "l": a = t[r++] * e + n, c = t[r++] * e + i, s.lineTo(a, c); break; case "q": l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, p = t[r++] * e + i, s.quadraticCurveTo(u, p, l, h); break; case "b": l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, p = t[r++] * e + i, d = t[r++] * e + n, f = t[r++] * e + i, s.bezierCurveTo(u, p, d, f, l, h) } } } return { offsetX: o.ha * e, path: s } } function Nf(t) { _d.call(this, t) } let Bf; Cf.prototype = Object.assign(Object.create(_d.prototype), { constructor: Cf, isImageBitmapLoader: !0, setOptions: function (t) { return this.options = t, this }, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = vd.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; fetch(t).then(function (t) { return t.blob() }).then(function (t) { return createImageBitmap(t, r.options) }).then(function (n) { vd.add(t, n), e && e(n), r.manager.itemEnd(t) }).catch(function (e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }), r.manager.itemStart(t) } }), Object.assign(Pf.prototype, { moveTo: function (t, e) { return this.currentPath = new rf, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }, lineTo: function (t, e) { return this.currentPath.lineTo(t, e), this }, quadraticCurveTo: function (t, e, n, i) { return this.currentPath.quadraticCurveTo(t, e, n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this }, splineThru: function (t) { return this.currentPath.splineThru(t), this }, toShapes: function (t, e) { function n(t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n], r = new of; r.curves = i.curves, e.push(r) } return e } function i(t, e) { const n = e.length; let i = !1; for (let r = n - 1, o = 0; o < n; r = o++) { let n = e[r], s = e[o], a = s.x - n.x, c = s.y - n.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (n = e[o], a = -a, s = e[r], c = -c), t.y < n.y || t.y > s.y) continue; if (t.y === n.y) { if (t.x === n.x) return !0 } else { const e = c * (t.x - n.x) - a * (t.y - n.y); if (0 === e) return !0; if (e < 0) continue; i = !i } } else { if (t.y !== n.y) continue; if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0 } } return i } const r = yp.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === e) return n(o); let s, a, c, l = []; if (1 === o.length) return a = o[0], (c = new of).curves = a.curves, l.push(c), l; let h = !r(o[0].getPoints()); h = t ? !h : h; const u = [], p = []; let d, f, m = [], g = 0; p[g] = void 0, m[g] = []; for (let v = 0, y = o.length; v < y; v++)s = r(d = (a = o[v]).getPoints()), (s = t ? !s : s) ? (!h && p[g] && g++, p[g] = { s: new of, p: d }, p[g].s.curves = a.curves, h && g++, m[g] = []) : m[g].push({ h: a, p: d[0] }); if (!p[0]) return n(o); if (p.length > 1) { let t = !1; const e = []; for (let n = 0, i = p.length; n < i; n++)u[n] = []; for (let n = 0, r = p.length; n < r; n++) { const r = m[n]; for (let o = 0; o < r.length; o++) { const s = r[o]; let a = !0; for (let r = 0; r < p.length; r++)i(s.p, p[r].p) && (n !== r && e.push({ froms: n, tos: r, hole: o }), a ? (a = !1, u[r].push(s)) : t = !0); a && u[n].push(s) } } e.length > 0 && (t || (m = u)) } for (let v = 0, y = p.length; v < y; v++) { c = p[v].s, l.push(c); for (let t = 0, e = (f = m[v]).length; t < e; t++)c.holes.push(f[t].h) } return l } }), Object.assign(Of.prototype, { isFont: !0, generateShapes: function (t, e) { void 0 === e && (e = 100); const n = [], i = Df(t, e, this.data); for (let r = 0, o = i.length; r < o; r++)Array.prototype.push.apply(n, i[r].toShapes()); return n } }), Nf.prototype = Object.assign(Object.create(_d.prototype), { constructor: Nf, load: function (t, e, n, i) { const r = this, o = new wd(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.load(t, function (t) { let n; try { n = JSON.parse(t) } catch (o) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2)) } const i = r.parse(n); e && e(i) }, n, i) }, parse: function (t) { return new Of(t) } }); const Ff = { getContext: function () { return void 0 === Bf && (Bf = new (window.AudioContext || window.webkitAudioContext)), Bf }, setContext: function (t) { Bf = t } }; function Uf(t) { _d.call(this, t) } function Gf(t, e, n) { xf.call(this, void 0, n); const i = (new hr).set(t), r = (new hr).set(e), o = new Xn(i.r, i.g, i.b), s = new Xn(r.r, r.g, r.b), a = Math.sqrt(Math.PI), c = a * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c) } function zf(t, e) { xf.call(this, void 0, e); const n = (new hr).set(t); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } exports.AudioContext = Ff, Uf.prototype = Object.assign(Object.create(_d.prototype), { constructor: Uf, load: function (t, e, n, i) { const r = this, o = new wd(r.manager); o.setResponseType("arraybuffer"), o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, function (n) { try { const s = n.slice(0); Ff.getContext().decodeAudioData(s, function (t) { e(t) }) } catch (o) { i ? i(o) : console.error(o), r.manager.itemError(t) } }, n, i) } }), Gf.prototype = Object.assign(Object.create(xf.prototype), { constructor: Gf, isHemisphereLightProbe: !0, copy: function (t) { return xf.prototype.copy.call(this, t), this }, toJSON: function (t) { return xf.prototype.toJSON.call(this, t) } }), zf.prototype = Object.assign(Object.create(xf.prototype), { constructor: zf, isAmbientLightProbe: !0, copy: function (t) { return xf.prototype.copy.call(this, t), this }, toJSON: function (t) { return xf.prototype.toJSON.call(this, t) } }); const Hf = new ei, kf = new ei; function Vf() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new bo, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new bo, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } function jf(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } Object.assign(Vf.prototype, { update: function (t) { const e = this._cache; if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) { e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep; const n = t.projectionMatrix.clone(), i = e.eyeSep / 2, r = i * e.near / e.focus, o = e.near * Math.tan(In.DEG2RAD * e.fov * .5) / e.zoom; let s, a; kf.elements[12] = -i, Hf.elements[12] = i, s = -o * e.aspect + r, a = o * e.aspect + r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(n), s = -o * e.aspect - r, a = o * e.aspect - r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(kf), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Hf) } }), Object.assign(jf.prototype, { start: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { let t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }); const Wf = new Xn, qf = new jn, Xf = new Xn, Yf = new Xn; function Zf() { xi.call(this), this.type = "AudioListener", this.context = Ff.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new jf } function Jf(t) { xi.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = [] } Zf.prototype = Object.assign(Object.create(xi.prototype), { constructor: Zf, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, updateMatrixWorld: function (t) { xi.prototype.updateMatrixWorld.call(this, t); const e = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Wf, qf, Xf), Yf.set(0, 0, -1).applyQuaternion(qf), e.positionX) { const t = this.context.currentTime + this.timeDelta; e.positionX.linearRampToValueAtTime(Wf.x, t), e.positionY.linearRampToValueAtTime(Wf.y, t), e.positionZ.linearRampToValueAtTime(Wf.z, t), e.forwardX.linearRampToValueAtTime(Yf.x, t), e.forwardY.linearRampToValueAtTime(Yf.y, t), e.forwardZ.linearRampToValueAtTime(Yf.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t) } else e.setPosition(Wf.x, Wf.y, Wf.z), e.setOrientation(Yf.x, Yf.y, Yf.z, n.x, n.y, n.z) } }), Jf.prototype = Object.assign(Object.create(xi.prototype), { constructor: Jf, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setMediaElementSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, setMediaStreamSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function (t) { if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + t; const e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, setDetune: function (t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, setLoopStart: function (t) { return this.loopStart = t, this }, setLoopEnd: function (t) { return this.loopEnd = t, this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }); const Qf = new Xn, Kf = new jn, $f = new Xn, tm = new Xn; function em(t) { Jf.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } function nm(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function im(t, e, n) { let i, r, o; switch (this.binding = t, this.valueSize = n, e) { case "quaternion": i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } em.prototype = Object.assign(Object.create(Jf.prototype), { constructor: em, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { return this.panner.refDistance = t, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { return this.panner.rolloffFactor = t, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { return this.panner.distanceModel = t, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { return this.panner.maxDistance = t, this }, setDirectionalCone: function (t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }, updateMatrixWorld: function (t) { if (xi.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(Qf, Kf, $f), tm.set(0, 0, 1).applyQuaternion(Kf); const e = this.panner; if (e.positionX) { const t = this.context.currentTime + this.listener.timeDelta; e.positionX.linearRampToValueAtTime(Qf.x, t), e.positionY.linearRampToValueAtTime(Qf.y, t), e.positionZ.linearRampToValueAtTime(Qf.z, t), e.orientationX.linearRampToValueAtTime(tm.x, t), e.orientationY.linearRampToValueAtTime(tm.y, t), e.orientationZ.linearRampToValueAtTime(tm.z, t) } else e.setPosition(Qf.x, Qf.y, Qf.z), e.setOrientation(tm.x, tm.y, tm.z) } }), Object.assign(nm.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { let t = 0; const e = this.getFrequencyData(); for (let n = 0; n < e.length; n++)t += e[n]; return t / e.length } }), Object.assign(im.prototype, { accumulate: function (t, e) { const n = this.buffer, i = this.valueSize, r = t * i + i; let o = this.cumulativeWeight; if (0 === o) { for (let t = 0; t !== i; ++t)n[r + t] = n[t]; o = e } else { const t = e / (o += e); this._mixBufferRegion(n, r, 0, t, i) } this.cumulativeWeight = o }, accumulateAdditive: function (t) { const e = this.buffer, n = this.valueSize, i = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t }, apply: function (t) { const e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const t = e * this._origIndex; this._mixBufferRegion(n, i, t, 1 - r, e) } o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e); for (let a = e, c = e + e; a !== c; ++a)if (n[a] !== n[a + e]) { s.setValue(n, i); break } }, saveOriginalState: function () { const t = this.binding, e = this.buffer, n = this.valueSize, i = n * this._origIndex; t.getValue(e, i); for (let r = n, o = i; r !== o; ++r)e[r] = e[i + r % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 }, restoreOriginalState: function () { const t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _setAdditiveIdentityNumeric: function () { const t = this._addIndex * this.valueSize, e = t + this.valueSize; for (let n = t; n < e; n++)this.buffer[n] = 0 }, _setAdditiveIdentityQuaternion: function () { this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1 }, _setAdditiveIdentityOther: function () { const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n] }, _select: function (t, e, n, i, r) { if (i >= .5) for (let o = 0; o !== r; ++o)t[e + o] = t[n + o] }, _slerp: function (t, e, n, i) { jn.slerpFlat(t, e, t, e, t, n, i) }, _slerpAdditive: function (t, e, n, i, r) { const o = this._workIndex * r; jn.multiplyQuaternionsFlat(t, o, t, e, t, n), jn.slerpFlat(t, e, t, e, t, o, i) }, _lerp: function (t, e, n, i, r) { const o = 1 - i; for (let s = 0; s !== r; ++s) { const r = e + s; t[r] = t[r] * o + t[n + s] * i } }, _lerpAdditive: function (t, e, n, i, r) { for (let o = 0; o !== r; ++o) { const r = e + o; t[r] = t[r] + t[n + o] * i } } }); const rm = "\\[\\]\\.:\\/", om = new RegExp("[\\[\\]\\.:\\/]", "g"), sm = "[^\\[\\]\\.:\\/]", am = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", cm = /((?:WC+[\/:])*)/.source.replace("WC", sm), lm = /(WCOD+)?/.source.replace("WCOD", am), hm = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", sm), um = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", sm), pm = new RegExp("^" + cm + lm + hm + um + "$"), dm = ["material", "materials", "bones"]; function fm(t, e, n) { const i = n || mm.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, i) } function mm(t, e, n) { this.path = e, this.parsedPath = n || mm.parseTrackName(e), this.node = mm.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function gm() { this.uuid = In.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const t = {}; this._indicesByUUID = t; for (let n = 0, i = arguments.length; n !== i; ++n)t[arguments[n].uuid] = n; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const e = this; this.stats = { objects: { get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } } } function vm(t, e, n, i) { this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode; const r = e.tracks, o = r.length, s = new Array(o), a = { endingStart: Ge, endingEnd: Ge }; for (let c = 0; c !== o; ++c) { const t = r[c].createInterpolant(null); s[c] = t, t.settings = a } this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Ie, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function ym(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function xm(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } function _m(t, e, n) { bh.call(this, t, e), this.meshPerAttribute = n || 1 } function bm(t, e, n, i) { this.ray = new Wi(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new oi, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function wm(t, e) { return t.distance - e.distance } function Mm(t, e, n, i) { if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) { const i = t.children; for (let t = 0, r = i.length; t < r; t++)Mm(i[t], e, n, !0) } } Object.assign(fm.prototype, { getValue: function (t, e) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(t, e) }, setValue: function (t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) }, bind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() }, unbind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }), Object.assign(mm, { Composite: fm, create: function (t, e, n) { return t && t.isAnimationObjectGroup ? new mm.Composite(t, e, n) : new mm(t, e, n) }, sanitizeNodeName: function (t) { return t.replace(/\s/g, "_").replace(om, "") }, parseTrackName: function (t) { const e = pm.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); -1 !== dm.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n }, findNode: function (t, e) { if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const o = n(r.children); if (o) return o } return null }, i = n(t.children); if (i) return i } return null } }), Object.assign(mm.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { let t = this.node, e = this.parsedPath, n = e.objectName, i = e.propertyName, r = e.propertyIndex; if (t || (t = mm.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === i) { i = e; break } break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== i) { if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[i] } } const o = t[i]; if (void 0 === o) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) } let s = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]) } a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s] }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(mm.prototype, { _getValue_unbound: mm.prototype.getValue, _setValue_unbound: mm.prototype.setValue }), Object.assign(gm.prototype, { isAnimationObjectGroup: !0, add: function () { const t = this._objects, e = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length; let s = void 0, a = t.length, c = this.nCachedObjects_; for (let l = 0, h = arguments.length; l !== h; ++l) { const h = arguments[l], u = h.uuid; let p = e[u]; if (void 0 === p) { p = a++, e[u] = p, t.push(h); for (let t = 0, e = o; t !== e; ++t)r[t].push(new mm(h, n[t], i[t])) } else if (p < c) { s = t[p]; const a = --c, l = t[a]; e[l.uuid] = p, t[p] = l, e[u] = a, t[a] = h; for (let t = 0, e = o; t !== e; ++t) { const e = r[t], o = e[a]; let s = e[p]; e[p] = o, void 0 === s && (s = new mm(h, n[t], i[t])), e[a] = s } } else t[p] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c }, remove: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_; for (let o = 0, s = arguments.length; o !== s; ++o) { const s = arguments[o], a = s.uuid, c = e[a]; if (void 0 !== c && c >= r) { const o = r++, l = t[o]; e[l.uuid] = c, t[c] = l, e[a] = o, t[o] = s; for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[o], r = e[c]; e[c] = i, e[o] = r } } } this.nCachedObjects_ = r }, uncache: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_, o = t.length; for (let s = 0, a = arguments.length; s !== a; ++s) { const a = arguments[s].uuid, c = e[a]; if (void 0 !== c) if (delete e[a], c < r) { const s = --r, a = t[s], l = --o, h = t[l]; e[a.uuid] = c, t[c] = a, e[h.uuid] = s, t[s] = h, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[s], r = e[l]; e[c] = i, e[s] = r, e.pop() } } else { const r = --o, s = t[r]; e[s.uuid] = c, t[c] = s, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t]; e[c] = e[r], e.pop() } } } this.nCachedObjects_ = r }, subscribe_: function (t, e) { let n = this._bindingsIndicesByPath, i = n[t], r = this._bindings; if (void 0 !== i) return r[i]; const o = this._paths, s = this._parsedPaths, a = this._objects, c = a.length, l = this.nCachedObjects_, h = new Array(c); i = r.length, n[t] = i, o.push(t), s.push(e), r.push(h); for (let u = l, p = a.length; u !== p; ++u) { const n = a[u]; h[u] = new mm(n, t, e) } return h }, unsubscribe_: function (t) { const e = this._bindingsIndicesByPath, n = e[t]; if (void 0 !== n) { const i = this._paths, r = this._parsedPaths, o = this._bindings, s = o.length - 1, a = o[s]; e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop() } } }), Object.assign(vm.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { const n = this._clip.duration, i = t._clip.duration, r = i / n, o = n / i; t.warp(1, r, e), this.warp(o, 1, e) } return this }, crossFadeTo: function (t, e, n) { return t.crossFadeFrom(this, e, n) }, stopFading: function () { let t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, n) { const i = this._mixer, r = i.time, o = this.timeScale; let s = this._timeScaleInterpolant; null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s); const a = s.parameterPositions, c = s.sampleValues; return a[0] = r, a[1] = r + n, c[0] = t / o, c[1] = e / o, this }, stopWarping: function () { let t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, n, i) { if (!this.enabled) return void this._updateWeight(t); const r = this._startTime; if (null !== r) { const i = (t - r) * n; if (i < 0 || 0 === n) return; this._startTime = null, e = n * i } e *= this._updateTimeScale(t); const o = this._updateTime(e), s = this._updateWeight(t); if (s > 0) { const t = this._interpolants, e = this._propertyBindings; switch (this.blendMode) { case 2501: for (let n = 0, i = t.length; n !== i; ++n)t[n].evaluate(o), e[n].accumulateAdditive(s); break; case ke: default: for (let n = 0, r = t.length; n !== r; ++n)t[n].evaluate(o), e[n].accumulate(i, s) } } }, _updateWeight: function (t) { let e = 0; if (this.enabled) { e = this.weight; const n = this._weightInterpolant; if (null !== n) { const i = n.evaluate(t)[0]; e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = e, e }, _updateTimeScale: function (t) { let e = 0; if (!this.paused) { e = this.timeScale; const n = this._timeScaleInterpolant; if (null !== n) { e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } } return this._effectiveTimeScale = e, e }, _updateTime: function (t) { const e = this._clip.duration, n = this.loop; let i = this.time + t, r = this._loopCount; const o = 2202 === n; if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i; if (2200 === n) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (i >= e) i = e; else { if (!(i < 0)) { this.time = i; break t } i = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) { const n = Math.floor(i / e); i -= e * n, r += Math.abs(n); const s = this.repetitions - r; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (1 === s) { const e = t < 0; this._setEndings(e, !e, o) } else this._setEndings(!1, !1, o); this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = i; if (o && 1 == (1 & r)) return e - i } return i }, _setEndings: function (t, e, n) { const i = this._interpolantSettings; n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : Ge : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : Ge : 2402) }, _scheduleFading: function (t, e, n) { const i = this._mixer, r = i.time; let o = this._weightInterpolant; null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o); const s = o.parameterPositions, a = o.sampleValues; return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this } }), ym.prototype = Object.assign(Object.create(Pn.prototype), { constructor: ym, _bindAction: function (t, e) { const n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, o = t._propertyBindings, s = t._interpolants, a = n.uuid, c = this._bindingsByRootAndName; let l = c[a]; void 0 === l && (l = {}, c[a] = l); for (let h = 0; h !== r; ++h) { const t = i[h], r = t.name; let c = l[r]; if (void 0 !== c) o[h] = c; else { if (void 0 !== (c = o[h])) { null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, a, r)); continue } const i = e && e._propertyBindings[h].binding.parsedPath; ++(c = new im(mm.create(n, r, i), t.ValueTypeName, t.getValueSize())).referenceCount, this._addInactiveBinding(c, a, r), o[h] = c } s[h].resultBuffer = c.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n]; this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e) } const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }, _addInactiveAction: function (t, e, n) { const i = this._actions, r = this._actionsByClip; let o = r[e]; if (void 0 === o) o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = o; else { const e = o.knownActions; t._byClipCacheIndex = e.length, e.push(t) } t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t }, _removeInactiveAction: function (t) { const e = this._actions, n = e[e.length - 1], i = t._cacheIndex; n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null; const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, c = a[a.length - 1], l = t._byClipCacheIndex; c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { const e = t._propertyBindings; for (let n = 0, i = e.length; n !== i; ++n) { const t = e[n]; 0 == --t.referenceCount && this._removeInactiveBinding(t) } }, _lendAction: function (t) { const e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackAction: function (t) { const e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _addInactiveBinding: function (t, e, n) { const i = this._bindingsByRootAndName, r = this._bindings; let o = i[e]; void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t) }, _removeInactiveBinding: function (t) { const e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, s = o[i], a = e[e.length - 1], c = t._cacheIndex; a._cacheIndex = c, e[c] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i] }, _lendBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _lendControlInterpolant: function () { const t = this._controlInterpolants, e = this._nActiveControlInterpolants++; let n = t[e]; return void 0 === n && ((n = new rd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n }, _takeBackControlInterpolant: function (t) { const e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants, r = e[i]; t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e, n) { const i = e || this._root, r = i.uuid; let o = "string" == typeof t ? fd.findByName(i, t) : t; const s = null !== o ? o.uuid : t; let a = this._actionsByClip[s], c = null; if (void 0 === n && (n = null !== o ? o.blendMode : ke), void 0 !== a) { const t = a.actionByRoot[r]; if (void 0 !== t && t.blendMode === n) return t; c = a.knownActions[0], null === o && (o = c._clip) } if (null === o) return null; const l = new vm(this, o, e, n); return this._bindAction(l, c), this._addInactiveAction(l, s, r), l }, existingAction: function (t, e) { const n = e || this._root, i = n.uuid, r = "string" == typeof t ? fd.findByName(n, t) : t, o = r ? r.uuid : t, s = this._actionsByClip[o]; return void 0 !== s && s.actionByRoot[i] || null }, stopAllAction: function () { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e)t[e].stop(); return this }, update: function (t) { t *= this.timeScale; const e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1; for (let c = 0; c !== n; ++c) { e[c]._update(i, t, r, o) } const s = this._bindings, a = this._nActiveBindings; for (let c = 0; c !== a; ++c)s[c].apply(o); return this }, setTime: function (t) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(t) }, getRoot: function () { return this._root }, uncacheClip: function (t) { const e = this._actions, n = t.uuid, i = this._actionsByClip, r = i[n]; if (void 0 !== r) { const t = r.knownActions; for (let n = 0, i = t.length; n !== i; ++n) { const i = t[n]; this._deactivateAction(i); const r = i._cacheIndex, o = e[e.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i) } delete i[n] } }, uncacheRoot: function (t) { const e = t.uuid, n = this._actionsByClip; for (const r in n) { const t = n[r].actionByRoot[e]; void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t)) } const i = this._bindingsByRootAndName[e]; if (void 0 !== i) for (const r in i) { const t = i[r]; t.restoreOriginalState(), this._removeInactiveBinding(t) } }, uncacheAction: function (t, e) { const n = this.existingAction(t, e); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } }), xm.prototype.clone = function () { return new xm(void 0 === this.value.clone ? this.value : this.value.clone()) }, _m.prototype = Object.assign(Object.create(bh.prototype), { constructor: _m, isInstancedInterleavedBuffer: !0, copy: function (t) { return bh.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, clone: function (t) { const e = bh.prototype.clone.call(this, t); return e.meshPerAttribute = this.meshPerAttribute, e }, toJSON: function (t) { const e = bh.prototype.toJSON.call(this, t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e } }), Object.assign(bm.prototype, { set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e, n) { const i = n || []; return Mm(t, this, i, e), i.sort(wm), i }, intersectObjects: function (t, e, n) { const i = n || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (let r = 0, o = t.length; r < o; r++)Mm(t[r], this, i, e); return i.sort(wm), i } }); class Sm { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(In.clamp(e / this.radius, -1, 1))), this } } function Tm(t, e, n) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this } exports.Spherical = Sm, Object.assign(Tm.prototype, { set: function (t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this } }); const Em = new Nn; function Am(t, e) { this.min = void 0 !== t ? t : new Nn(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Nn(-1 / 0, -1 / 0) } Object.assign(Am.prototype, { set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { const n = Em.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Nn), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Nn), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Nn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Nn), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return Em.copy(t).clamp(this.min, this.max).sub(t).length() }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); const Lm = new Xn, Rm = new Xn; function Cm(t, e) { this.start = void 0 !== t ? t : new Xn, this.end = void 0 !== e ? e : new Xn } function Pm(t) { xi.call(this), this.material = t, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } Object.assign(Cm.prototype, { set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Xn), t.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Xn), t.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Xn), this.delta(e).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: function (t, e) { Lm.subVectors(t, this.start), Rm.subVectors(this.end, this.start); const n = Rm.dot(Rm); let i = Rm.dot(Lm) / n; return e && (i = In.clamp(i, 0, 1)), i }, closestPointToPoint: function (t, e, n) { const i = this.closestPointToPointParameter(t, e); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Xn), this.delta(n).multiplyScalar(i).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }), Pm.prototype = Object.create(xi.prototype), Pm.prototype.constructor = Pm, Pm.prototype.isImmediateRenderObject = !0; const Om = new Xn; function Dm(t, e) { xi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e; const n = new Gr, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, s = 1, a = 32; o < a; o++, s++) { const t = o / a * Math.PI * 2, e = s / a * Math.PI * 2; i.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1) } n.setAttribute("position", new Lr(i, 3)); const r = new $h({ fog: !1, toneMapped: !1 }); this.cone = new cu(n, r), this.add(this.cone), this.update() } Dm.prototype = Object.create(xi.prototype), Dm.prototype.constructor = Dm, Dm.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, Dm.prototype.update = function () { this.light.updateMatrixWorld(); const t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle); this.cone.scale.set(e, e, t), Om.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Om), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }; const Im = new Xn, Nm = new ei, Bm = new ei; function Fm(t) { const e = []; t && t.isBone && e.push(t); for (let n = 0; n < t.children.length; n++)e.push.apply(e, Fm(t.children[n])); return e } function Um(t) { const e = Fm(t), n = new Gr, i = [], r = [], o = new hr(0, 0, 1), s = new hr(0, 1, 0); for (let c = 0; c < e.length; c++) { const t = e[c]; t.parent && t.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b)) } n.setAttribute("position", new Lr(i, 3)), n.setAttribute("color", new Lr(r, 3)); const a = new $h({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); cu.call(this, n, a), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Gm(t, e, n) { this.light = t, this.light.updateMatrixWorld(), this.color = n; const i = new Lp(e, 4, 2), r = new vr({ wireframe: !0, fog: !1, toneMapped: !1 }); io.call(this, i, r), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } Um.prototype = Object.create(cu.prototype), Um.prototype.constructor = Um, Um.prototype.isSkeletonHelper = !0, Um.prototype.updateMatrixWorld = function (t) { const e = this.bones, n = this.geometry, i = n.getAttribute("position"); Bm.getInverse(this.root.matrixWorld); for (let r = 0, o = 0; r < e.length; r++) { const t = e[r]; t.parent && t.parent.isBone && (Nm.multiplyMatrices(Bm, t.matrixWorld), Im.setFromMatrixPosition(Nm), i.setXYZ(o, Im.x, Im.y, Im.z), Nm.multiplyMatrices(Bm, t.parent.matrixWorld), Im.setFromMatrixPosition(Nm), i.setXYZ(o + 1, Im.x, Im.y, Im.z), o += 2) } n.getAttribute("position").needsUpdate = !0, xi.prototype.updateMatrixWorld.call(this, t) }, Gm.prototype = Object.create(io.prototype), Gm.prototype.constructor = Gm, Gm.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Gm.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }; const zm = new Xn, Hm = new hr, km = new hr; function Vm(t, e, n) { xi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n; const i = new Ru(e); i.rotateY(.5 * Math.PI), this.material = new vr({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); const r = i.getAttribute("position"), o = new Float32Array(3 * r.count); i.setAttribute("color", new _r(o, 3)), this.add(new io(i, this.material)), this.update() } function jm(t, e, n, i) { t = t || 10, e = e || 10, n = new hr(void 0 !== n ? n : 4473924), i = new hr(void 0 !== i ? i : 8947848); const r = e / 2, o = t / e, s = t / 2, a = [], c = []; for (let u = 0, p = 0, d = -s; u <= e; u++, d += o) { a.push(-s, 0, d, s, 0, d), a.push(d, 0, -s, d, 0, s); const t = u === r ? n : i; t.toArray(c, p), p += 3, t.toArray(c, p), p += 3, t.toArray(c, p), p += 3, t.toArray(c, p), p += 3 } const l = new Gr; l.setAttribute("position", new Lr(a, 3)), l.setAttribute("color", new Lr(c, 3)); const h = new $h({ vertexColors: !0, toneMapped: !1 }); cu.call(this, l, h), this.type = "GridHelper" } function Wm(t, e, n, i, r, o) { t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new hr(void 0 !== r ? r : 4473924), o = new hr(void 0 !== o ? o : 8947848); const s = [], a = []; for (let h = 0; h <= e; h++) { const n = h / e * (2 * Math.PI), i = Math.sin(n) * t, c = Math.cos(n) * t; s.push(0, 0, 0), s.push(i, 0, c); const l = 1 & h ? r : o; a.push(l.r, l.g, l.b), a.push(l.r, l.g, l.b) } for (let h = 0; h <= n; h++) { const e = 1 & h ? r : o, c = t - t / n * h; for (let t = 0; t < i; t++) { let n = t / i * (2 * Math.PI), r = Math.sin(n) * c, o = Math.cos(n) * c; s.push(r, 0, o), a.push(e.r, e.g, e.b), n = (t + 1) / i * (2 * Math.PI), r = Math.sin(n) * c, o = Math.cos(n) * c, s.push(r, 0, o), a.push(e.r, e.g, e.b) } } const c = new Gr; c.setAttribute("position", new Lr(s, 3)), c.setAttribute("color", new Lr(a, 3)); const l = new $h({ vertexColors: !0, toneMapped: !1 }); cu.call(this, c, l), this.type = "PolarGridHelper" } Vm.prototype = Object.create(xi.prototype), Vm.prototype.constructor = Vm, Vm.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Vm.prototype.update = function () { const t = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const e = t.geometry.getAttribute("color"); Hm.copy(this.light.color), km.copy(this.light.groundColor); for (let t = 0, n = e.count; t < n; t++) { const i = t < n / 2 ? Hm : km; e.setXYZ(t, i.r, i.g, i.b) } e.needsUpdate = !0 } t.lookAt(zm.setFromMatrixPosition(this.light.matrixWorld).negate()) }, jm.prototype = Object.create(cu.prototype), jm.prototype.constructor = jm, Wm.prototype = Object.create(cu.prototype), Wm.prototype.constructor = Wm; const qm = new Xn, Xm = new Xn, Ym = new Xn; function Zm(t, e, n) { xi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1); let i = new Gr; i.setAttribute("position", new Lr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); const r = new $h({ fog: !1, toneMapped: !1 }); this.lightPlane = new ou(i, r), this.add(this.lightPlane), (i = new Gr).setAttribute("position", new Lr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ou(i, r), this.add(this.targetLine), this.update() } Zm.prototype = Object.create(xi.prototype), Zm.prototype.constructor = Zm, Zm.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, Zm.prototype.update = function () { qm.setFromMatrixPosition(this.light.matrixWorld), Xm.setFromMatrixPosition(this.light.target.matrixWorld), Ym.subVectors(Xm, qm), this.lightPlane.lookAt(Xm), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Xm), this.targetLine.scale.z = Ym.length() }; const Jm = new Xn, Qm = new _o; function Km(t) { const e = new Gr, n = new $h({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], o = {}, s = new hr(16755200), a = new hr(16711680), c = new hr(43775), l = new hr(16777215), h = new hr(3355443); function u(t, e, n) { p(t, n), p(e, n) } function p(t, e) { i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1) } u("n1", "n2", s), u("n2", "n4", s), u("n4", "n3", s), u("n3", "n1", s), u("f1", "f2", s), u("f2", "f4", s), u("f4", "f3", s), u("f3", "f1", s), u("n1", "f1", s), u("n2", "f2", s), u("n3", "f3", s), u("n4", "f4", s), u("p", "n1", a), u("p", "n2", a), u("p", "n3", a), u("p", "n4", a), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", l), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new Lr(i, 3)), e.setAttribute("color", new Lr(r, 3)), cu.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update() } function $m(t, e, n, i, r, o, s) { Jm.set(r, o, s).unproject(i); const a = e[t]; if (void 0 !== a) { const t = n.getAttribute("position"); for (let e = 0, n = a.length; e < n; e++)t.setXYZ(a[e], Jm.x, Jm.y, Jm.z) } } Km.prototype = Object.create(cu.prototype), Km.prototype.constructor = Km, Km.prototype.update = function () { const t = this.geometry, e = this.pointMap; Qm.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), $m("c", e, t, Qm, 0, 0, -1), $m("t", e, t, Qm, 0, 0, 1), $m("n1", e, t, Qm, -1, -1, -1), $m("n2", e, t, Qm, 1, -1, -1), $m("n3", e, t, Qm, -1, 1, -1), $m("n4", e, t, Qm, 1, 1, -1), $m("f1", e, t, Qm, -1, -1, 1), $m("f2", e, t, Qm, 1, -1, 1), $m("f3", e, t, Qm, -1, 1, 1), $m("f4", e, t, Qm, 1, 1, 1), $m("u1", e, t, Qm, .7, 1.1, -1), $m("u2", e, t, Qm, -.7, 1.1, -1), $m("u3", e, t, Qm, 0, 2, -1), $m("cf1", e, t, Qm, -1, 0, 1), $m("cf2", e, t, Qm, 1, 0, 1), $m("cf3", e, t, Qm, 0, -1, 1), $m("cf4", e, t, Qm, 0, 1, 1), $m("cn1", e, t, Qm, -1, 0, -1), $m("cn2", e, t, Qm, 1, 0, -1), $m("cn3", e, t, Qm, 0, -1, -1), $m("cn4", e, t, Qm, 0, 1, -1), t.getAttribute("position").needsUpdate = !0 }; const tg = new Ii; function eg(t, e) { this.object = t, void 0 === e && (e = 16776960); const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new Gr; r.setIndex(new _r(n, 1)), r.setAttribute("position", new _r(i, 3)), cu.call(this, r, new $h({ color: e, toneMapped: !1 })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } function ng(t, e) { this.type = "Box3Helper", this.box = t, void 0 === e && (e = 16776960); const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Gr; i.setIndex(new _r(n, 1)), i.setAttribute("position", new Lr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), cu.call(this, i, new $h({ color: e, toneMapped: !1 })), this.type = "Box3Helper", this.geometry.computeBoundingSphere() } function ig(t, e, n) { this.plane = t, this.size = void 0 === e ? 1 : e; const i = void 0 !== n ? n : 16776960, r = new Gr; r.setAttribute("position", new Lr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), ou.call(this, r, new $h({ color: i, toneMapped: !1 })), this.type = "PlaneHelper"; const o = new Gr; o.setAttribute("position", new Lr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new io(o, new vr({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } eg.prototype = Object.create(cu.prototype), eg.prototype.constructor = eg, eg.prototype.update = function (t) { if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && tg.setFromObject(this.object), tg.isEmpty()) return; const e = tg.min, n = tg.max, i = this.geometry.attributes.position, r = i.array; r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() }, eg.prototype.setFromObject = function (t) { return this.object = t, this.update(), this }, eg.prototype.copy = function (t) { return cu.prototype.copy.call(this, t), this.object = t.object, this }, ng.prototype = Object.create(cu.prototype), ng.prototype.constructor = ng, ng.prototype.updateMatrixWorld = function (t) { const e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), xi.prototype.updateMatrixWorld.call(this, t)) }, ig.prototype = Object.create(ou.prototype), ig.prototype.constructor = ig, ig.prototype.updateMatrixWorld = function (t) { let e = -this.plane.constant; Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? p : u, this.lookAt(this.plane.normal), xi.prototype.updateMatrixWorld.call(this, t) }; const rg = new Xn; let og, sg; function ag(t, e, n, i, r, o) { xi.call(this), this.type = "ArrowHelper", void 0 === t && (t = new Xn(0, 0, 1)), void 0 === e && (e = new Xn(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === og && ((og = new Gr).setAttribute("position", new Lr([0, 0, 0, 0, 1, 0], 3)), (sg = new Up(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new ou(og, new $h({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new io(sg, new vr({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o) } function cg(t) { const e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n = new Gr; n.setAttribute("position", new Lr(e, 3)), n.setAttribute("color", new Lr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); const i = new $h({ vertexColors: !0, toneMapped: !1 }); cu.call(this, n, i), this.type = "AxesHelper" } ag.prototype = Object.create(xi.prototype), ag.prototype.constructor = ag, ag.prototype.setDirection = function (t) { if (t.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { rg.set(t.z, 0, -t.x).normalize(); const e = Math.acos(t.y); this.quaternion.setFromAxisAngle(rg, e) } }, ag.prototype.setLength = function (t, e, n) { void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }, ag.prototype.setColor = function (t) { this.line.material.color.set(t), this.cone.material.color.set(t) }, ag.prototype.copy = function (t) { return xi.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, cg.prototype = Object.create(cu.prototype), cg.prototype.constructor = cg; const lg = 4, hg = 8, ug = Math.pow(2, hg), pg = [.125, .215, .35, .446, .526, .582], dg = hg - lg + 1 + pg.length, fg = 20, mg = { [Xe]: 0, [Ye]: 1, [Je]: 2, [Ke]: 3, [$e]: 4, [tn]: 5, [Ze]: 6 }, gg = new df, { _lodPlanes: vg, _sizeLods: yg, _sigmas: xg } = Eg(); let _g = null; const bg = (1 + Math.sqrt(5)) / 2, wg = 1 / bg, Mg = [new Xn(1, 1, 1), new Xn(-1, 1, 1), new Xn(1, 1, -1), new Xn(-1, 1, -1), new Xn(0, bg, wg), new Xn(0, bg, -wg), new Xn(wg, 0, bg), new Xn(-wg, 0, bg), new Xn(bg, wg, 0), new Xn(-bg, wg, 0)]; function Sg(t) { this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = Rg(fg), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial) } function Tg(t) { return void 0 !== t && t.type === bt && (t.encoding === Xe || t.encoding === Ye || t.encoding === Ze) } function Eg() { const t = [], e = [], n = []; let i = hg; for (let r = 0; r < dg; r++) { const o = Math.pow(2, i); e.push(o); let s = 1 / o; r > hg - lg ? s = pg[r - hg + lg - 1] : 0 == r && (s = 0), n.push(s); const a = 1 / (o - 1), c = -a / 2, l = 1 + a / 2, h = [c, c, l, c, l, l, c, c, l, l, c, l], u = 6, p = 6, d = 3, f = 2, m = 1, g = new Float32Array(d * p * u), v = new Float32Array(f * p * u), y = new Float32Array(m * p * u); for (let t = 0; t < u; t++) { const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1, i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]; g.set(i, d * p * t), v.set(h, f * p * t); const r = [t, t, t, t, t, t]; y.set(r, m * p * t) } const x = new Gr; x.setAttribute("position", new _r(g, d)), x.setAttribute("uv", new _r(v, f)), x.setAttribute("faceIndex", new _r(y, m)), t.push(x), i > lg && i-- } return { _lodPlanes: t, _sizeLods: e, _sigmas: n } } function Ag(t) { const e = new kn(3 * ug, 3 * ug, t); return e.texture.mapping = st, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e } function Lg(t, e, n, i, r) { t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r) } function Rg(t) { return new Wp({ name: "SphericalGaussianBlur", defines: { n: t }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: new Float32Array(t) }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: new Xn(0, 1, 0) }, inputEncoding: { value: mg[Xe] }, outputEncoding: { value: mg[Xe] } }, vertexShader: Og(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Dg()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: g, depthTest: !1, depthWrite: !1 }) } function Cg() { return new Wp({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new Nn(1, 1) }, inputEncoding: { value: mg[Xe] }, outputEncoding: { value: mg[Xe] } }, vertexShader: Og(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Dg()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: g, depthTest: !1, depthWrite: !1 }) } function Pg() { return new Wp({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: mg[Xe] }, outputEncoding: { value: mg[Xe] } }, vertexShader: Og(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Dg()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: g, depthTest: !1, depthWrite: !1 }) } function Og() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function Dg() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } function Ig(t, e, n, i, r, o, s) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new fr(t, e, n, r, o, s) } Sg.prototype = { constructor: Sg, fromScene: function (t, e = 0, n = .1, i = 100) { _g = this._renderer.getRenderTarget(); const r = this._allocateTargets(); return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r }, fromEquirectangular: function (t) { return this._fromTexture(t) }, fromCubemap: function (t) { return this._fromTexture(t) }, compileCubemapShader: function () { null === this._cubemapShader && (this._cubemapShader = Pg(), this._compileMaterial(this._cubemapShader)) }, compileEquirectangularShader: function () { null === this._equirectShader && (this._equirectShader = Cg(), this._compileMaterial(this._equirectShader)) }, dispose: function () { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let t = 0; t < vg.length; t++)vg[t].dispose() }, _cleanup: function (t) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_g), t.scissorTest = !1, Lg(t, 0, 0, t.width, t.height) }, _fromTexture: function (t) { _g = this._renderer.getRenderTarget(); const e = this._allocateTargets(t); return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e }, _allocateTargets: function (t) { const e = { magFilter: ut, minFilter: ut, generateMipmaps: !1, type: bt, format: Ut, encoding: Tg(t) ? t.encoding : Je, depthBuffer: !1, stencilBuffer: !1 }, n = Ag(e); return n.depthBuffer = !t, this._pingPongRenderTarget = Ag(e), n }, _compileMaterial: function (t) { const e = new io(vg[0], t); this._renderer.compile(e, gg) }, _sceneToCubeUV: function (t, e, n, i) { const r = new bo(90, 1, e, n), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer, c = a.outputEncoding, l = a.toneMapping, h = a.getClearColor(), u = a.getClearAlpha(); a.toneMapping = Z, a.outputEncoding = Xe; let p = t.background; if (p && p.isColor) { p.convertSRGBToLinear(); const e = Math.max(p.r, p.g, p.b), n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127); p = p.multiplyScalar(Math.pow(2, -n)); const i = (n + 128) / 255; a.setClearColor(p, i), t.background = null } for (let d = 0; d < 6; d++) { const e = d % 3; 0 == e ? (r.up.set(0, o[d], 0), r.lookAt(s[d], 0, 0)) : 1 == e ? (r.up.set(0, 0, o[d]), r.lookAt(0, s[d], 0)) : (r.up.set(0, o[d], 0), r.lookAt(0, 0, s[d])), Lg(i, e * ug, d > 2 ? ug : 0, ug, ug), a.setRenderTarget(i), a.render(t, r) } a.toneMapping = l, a.outputEncoding = c, a.setClearColor(h, u) }, _textureToCubeUV: function (t, e) { const n = this._renderer; t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Pg()) : null == this._equirectShader && (this._equirectShader = Cg()); const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new io(vg[0], i), o = i.uniforms; o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = mg[t.encoding], o.outputEncoding.value = mg[e.texture.encoding], Lg(e, 0, 0, 3 * ug, 2 * ug), n.setRenderTarget(e), n.render(r, gg) }, _applyPMREM: function (t) { const e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let i = 1; i < dg; i++) { const e = Math.sqrt(xg[i] * xg[i] - xg[i - 1] * xg[i - 1]), n = Mg[(i - 1) % Mg.length]; this._blur(t, i - 1, i, e, n) } e.autoClear = n }, _blur: function (t, e, n, i, r) { const o = this._pingPongRenderTarget; this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r) }, _halfBlur: function (t, e, n, i, r, o, s) { const a = this._renderer, c = this._blurMaterial; "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!"); const l = new io(vg[i], c), h = c.uniforms, u = yg[n] - 1, p = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * fg - 1), d = r / p, f = isFinite(r) ? 1 + Math.floor(3 * d) : fg; f > fg && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${fg}`); const m = []; let g = 0; for (let y = 0; y < fg; ++y) { const t = y / d, e = Math.exp(-t * t / 2); m.push(e), 0 == y ? g += e : y < f && (g += 2 * e) } for (let y = 0; y < m.length; y++)m[y] = m[y] / g; h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === o, s && (h.poleAxis.value = s), h.dTheta.value = p, h.mipInt.value = hg - n, h.inputEncoding.value = mg[t.texture.encoding], h.outputEncoding.value = mg[t.texture.encoding]; const v = yg[i]; Lg(e, 3 * Math.max(0, ug - 2 * v), (0 === i ? 0 : 2 * ug) + 2 * v * (i > hg - lg ? i - hg + lg : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(l, gg) } }; const Ng = 0; exports.LineStrip = 0; const Bg = 1; exports.LinePieces = 1; const Fg = 0; exports.NoColors = 0; const Ug = 1; exports.FaceColors = 1; const Gg = 2; function zg(t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t } function Hg(t) { return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function () { return t.slice() }, t } function kg(t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new mu(t, e) } function Vg(t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Uh(t) } function jg(t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new mu(t, e) } function Wg(t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new hu(t) } function qg(t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new hu(t) } function Xg(t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new hu(t) } function Yg(t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Xn(t, e, n) } function Zg(t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new _r(t, e).setUsage(Mn) } function Jg(t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new br(t, e) } function Qg(t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new wr(t, e) } function Kg(t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Mr(t, e) } function $g(t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Sr(t, e) } function tv(t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Tr(t, e) } function ev(t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Er(t, e) } function nv(t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ar(t, e) } function iv(t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Lr(t, e) } function rv(t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Rr(t, e) } function ov(t) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Fd.call(this, t), this.type = "catmullrom", this.closed = !0 } function sv(t) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Fd.call(this, t), this.type = "catmullrom" } function av(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Fd.call(this, t), this.type = "catmullrom" } function cv(t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new cg(t) } function lv(t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new eg(t, e) } function hv(t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new cu(new Bp(t.geometry), new $h({ color: void 0 !== e ? e : 16777215 })) } function uv(t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new cu(new bu(t.geometry), new $h({ color: void 0 !== e ? e : 16777215 })) } function pv(t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new wd(t) } function dv(t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Td(t) } function fv(t, e, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new To(t, n) } exports.VertexColors = 2, Rd.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Rd.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Object.assign(nf.prototype, { createPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = this.getPoints(t); return this.createGeometry(e) }, createSpacedPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = this.getSpacedPoints(t); return this.createGeometry(e) }, createGeometry: function (t) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = new ho; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.vertices.push(new Xn(i.x, i.y, i.z || 0)) } return e } }), Object.assign(rf.prototype, { fromPoints: function (t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), ov.prototype = Object.create(Fd.prototype), sv.prototype = Object.create(Fd.prototype), av.prototype = Object.create(Fd.prototype), Object.assign(av.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), jm.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Um.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(_d.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), bf.extractUrlBase(t) } }), _d.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(Ef.prototype, { setTexturePath: function (t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(Am.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Ii.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Fi.prototype, { empty: function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), Ro.prototype.setFromMatrix = function (t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, Cm.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(In, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), In.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), In.ceilPowerOfTwo(t) } }), Object.assign(Bn.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(ei.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Xn).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, n, i, r, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o) } }), Zi.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, jn.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign(Wi.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(sr.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(sr, { barycoordFromPoint: function (t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), sr.getBarycoord(t, e, n, i, r) }, normal: function (t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), sr.getNormal(t, e, n, i) } }), Object.assign(of.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new bp(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Dp(this, t) } }), Object.assign(Nn.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Xn.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Hn.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ho.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }, applyMatrix: function (t) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.assign(xi.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function (t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(xi.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign(io.prototype, { setDrawMode: function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties(io.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(kh.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(qh.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Vh.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Rd.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), bo.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(sf.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(_r.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Mn }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Mn) } } }), Object.assign(_r.prototype, { setDynamic: function (t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Mn : wn), this }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Gr.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addAttribute: function (t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new _r(arguments[1], arguments[2]))) }, addDrawCall: function (t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function (t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, applyMatrix: function (t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(Gr.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(wf.prototype, { maxInstancedCount: { get: function () { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function (t) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t } } }), Object.defineProperties(bm.prototype, { linePrecision: { get: function () { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function (t) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t } } }), Object.defineProperties(bh.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Mn }, set: function (t) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t) } } }), Object.assign(bh.prototype, { setDynamic: function (t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Mn : wn), this }, setArray: function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(wp.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(xm.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(gr.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new hr } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(Yp.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(Xp.prototype, { transparency: { get: function () { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function (t) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t } } }), Object.defineProperties(xo.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(vh.prototype, { clearTarget: function (t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(vh.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Ye : Xe } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(ch.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(kn.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(Jf.prototype, { load: { value: function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new Uf).load(t, function (t) { e.setBuffer(t) }), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), nm.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, So.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }; const mv = { merge: function (t, e, n) { let i; console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n) }, center: function (t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }; function gv() { console.error("THREE.CanvasRenderer has been removed") } function vv() { console.error("THREE.JSONLoader has been removed.") } exports.GeometryUtils = mv, Un.crossOrigin = void 0, Un.loadTexture = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const r = new Ld; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, Un.loadTextureCube = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const r = new Ad; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, Un.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Un.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; const yv = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; function xv() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") } exports.SceneUtils = yv, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "119" } }));
    }, {}], "dnrf": [function (require, module, exports) {
        var define;
        var e; !function (t, n) { "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof e && e.amd ? e(n) : t.Stats = n() }(this, function () { var e = function () { function t(e) { return i.appendChild(e.dom), e } function n(e) { for (var t = 0; t < i.children.length; t++)i.children[t].style.display = t === e ? "block" : "none"; l = e } var l = 0, i = document.createElement("div"); i.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", i.addEventListener("click", function (e) { e.preventDefault(), n(++l % i.children.length) }, !1); var a = (performance || Date).now(), o = a, r = 0, f = t(new e.Panel("FPS", "#0ff", "#002")), c = t(new e.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var d = t(new e.Panel("MB", "#f08", "#201")); return n(0), { REVISION: 16, dom: i, addPanel: t, showPanel: n, begin: function () { a = (performance || Date).now() }, end: function () { r++; var e = (performance || Date).now(); if (c.update(e - a, 200), e > o + 1e3 && (f.update(1e3 * r / (e - o), 100), o = e, r = 0, d)) { var t = performance.memory; d.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576) } return e }, update: function () { a = this.end() }, domElement: i, setMode: n } }; return e.Panel = function (e, t, n) { var l = 1 / 0, i = 0, a = Math.round, o = a(window.devicePixelRatio || 1), r = 80 * o, f = 48 * o, c = 3 * o, d = 2 * o, p = 3 * o, u = 15 * o, s = 74 * o, m = 30 * o, h = document.createElement("canvas"); h.width = r, h.height = f, h.style.cssText = "width:80px;height:48px"; var v = h.getContext("2d"); return v.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", v.textBaseline = "top", v.fillStyle = n, v.fillRect(0, 0, r, f), v.fillStyle = t, v.fillText(e, c, d), v.fillRect(p, u, s, m), v.fillStyle = n, v.globalAlpha = .9, v.fillRect(p, u, s, m), { dom: h, update: function (f, y) { l = Math.min(l, f), i = Math.max(i, f), v.fillStyle = n, v.globalAlpha = 1, v.fillRect(0, 0, r, u), v.fillStyle = t, v.fillText(a(f) + " " + e + " (" + a(l) + "-" + a(i) + ")", c, d), v.drawImage(h, p + o, u, s - o, m, p, u, s - o, m), v.fillRect(p + s - o, u, o, m), v.fillStyle = n, v.globalAlpha = .9, v.fillRect(p + s - o, u, o, a((1 - f / y) * m)) } } }, e });
    }, {}], "HUaJ": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.randomNoRepeat = r, exports.bindMethods = o, exports.getBubbleTypeFromClass = c, exports.getRatio = s, exports.preloadImages = exports.width = exports.height = exports.siblingsOfEl = exports.css = void 0; var t = n(require("three")); function e() { if ("function" != typeof WeakMap) return null; var t = new WeakMap; return e = function () { return t }, t } function n(t) { if (t && t.__esModule) return t; if (null === t || "object" != typeof t && "function" != typeof t) return { default: t }; var n = e(); if (n && n.has(t)) return n.get(t); var r = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var i in t) if (Object.prototype.hasOwnProperty.call(t, i)) { var a = o ? Object.getOwnPropertyDescriptor(t, i) : null; a && (a.get || a.set) ? Object.defineProperty(r, i, a) : r[i] = t[i] } return r.default = t, n && n.set(t, r), r } function r(t) { var e = t.slice(0); return function () { e.length < 1 && (e = t.slice(0)); var n = Math.floor(Math.random() * e.length), r = e[n]; return e.splice(n, 1), r } } function o() { var t = this; Object.getOwnPropertyNames(Object.getPrototypeOf(this)).map(function (e) { t[e] instanceof Function && "constructor" !== e && (t[e] = t[e].bind(t)) }) } function i(t, e) { var n = t[0], r = t[1], o = t[2], i = t[3], a = e[0], c = e[1]; return [Math.abs(a * n + c * o), Math.abs(a * r + c * i)] } var a = function (t) { return [Math.cos(t), -Math.sin(t), Math.sin(t), Math.cos(t)] }; function c(t) { return t ? t.contains("ui_ux") ? "ui_ux" : t.contains("promo_videos") ? "promo_videos" : t.contains("graphic_design") ? "graphic_design" : t.contains("other") || t.contains("architecture") ? "other" : void 0 : null } function s(e, n) { var r = e.x, o = e.y, c = n.width, s = n.height, u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, p = i(a(t.Math.degToRad(u)), [r, o]), l = { w: p[0] / c, h: p[1] / s }, d = 1 / Math.max(l.w, l.h); return new t.Vector2(l.w * d, l.h * d) } var u = function (t, e, n) { return n ? t.style[e] = n : getComputedStyle(t).getPropertyValue(e) }; exports.css = u; var p = function (t) { return Array.prototype.filter.call(t.parentNode.children, function (e) { return e !== t }) }; exports.siblingsOfEl = p; var l = function (t, e) { return e ? t.style.height = "".concat(e, "px") : t instanceof Window ? window.innerHeight || document.documentElement.clientHeight : getComputedStyle(t).height.replace("px", "") }; exports.height = l; var d = function (t, e) { return e ? t.style.width = "".concat(e, "px") : t instanceof Window ? window.innerWidth || document.documentElement.clientWidth : getComputedStyle(t).width.replace("px", "") }; exports.width = d; var h = function (t, e) { var n = 0; t.forEach(function (r) { var o = document.createElement("img"); o.src = r, o.style.display = "none", o.classList.add("preload"), o.onload = function () { ++n == t.length ? e(100) : e(100 * n / t.length) }, document.body.appendChild(o) }) }; exports.preloadImages = h;
    }, { "three": "dKqR" }], "CK79": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = a(require("three")), t = n(require("stats.js")), i = require("./utils/utils"); function n(e) { return e && e.__esModule ? e : { default: e } } function r() { if ("function" != typeof WeakMap) return null; var e = new WeakMap; return r = function () { return e }, e } function a(e) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = r(); if (t && t.has(e)) return t.get(e); var i = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var a in e) if (Object.prototype.hasOwnProperty.call(e, a)) { var s = n ? Object.getOwnPropertyDescriptor(e, a) : null; s && (s.get || s.set) ? Object.defineProperty(i, a, s) : i[a] = e[a] } return i.default = e, t && t.set(e, i), i } function s(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function o(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function h(e, t, i) { return t && o(e.prototype, t), i && o(e, i), e } var c = function () { function t(n) { s(this, t), i.bindMethods.call(this), this.canvas = n, this.perspective = 800, this.renderer = new e.WebGLRenderer({ canvas: this.canvas, context: this.canvas.getContext("webgl2"), alpha: !0, antialias: !0, powerPreference: "high-performance" }), this.renderer.setSize((0, i.width)(this.canvas), (0, i.height)(this.canvas)), this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.fov = 2 * Math.atan((0, i.height)(this.canvas) / 2 / this.perspective) * 180 / Math.PI, this.scene = new e.Scene, this.camera = new e.PerspectiveCamera(this.fov, (0, i.width)(this.canvas) / (0, i.height)(this.canvas), 1, 1e3), this.camera.position.set(0, 0, this.perspective), this.geometry = new e.CircleBufferGeometry(10, 128, 6, 6.3), this.addLight(), window.addEventListener("resize", this.onResize), this.animate() } return h(t, [{ key: "addLight", value: function () { var t = new e.AmbientLight(16777215, 2); this.scene.add(t) } }, { key: "onResize", value: function () { this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight), this.bubbles && (this.bubbles.forEach(function (e) { return e.update() }), this.projects && Array.from(this.projects).map(function (e) { (0, i.height)(e, (0, i.width)(e)) })) } }, { key: "update", value: function () { this.bubbles && this.bubbles.forEach(function (e) { return e.update() }) } }, { key: "animate", value: function () { this.update(), this.scene.children && this.renderer.render(this.scene, this.camera), requestAnimationFrame(this.animate) } }]), t }(); exports.default = c;
    }, { "three": "dKqR", "stats.js": "dnrf", "./utils/utils": "HUaJ" }], "ygg0": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var t = e(require("gsap")), i = require("./utils/utils"); function e(t) { return t && t.__esModule ? t : { default: t } } function n(t, i) { if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function") } function o(t, i) { for (var e = 0; e < i.length; e++) { var n = i[e]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function l(t, i, e) { return i && o(t.prototype, i), e && o(t, e), t } var s = function () { function e() { n(this, e), i.bindMethods.call(this), this.flyingBird = document.querySelector(".flying-bird"), this.flyingBirdSvg = this.flyingBird.querySelector("svg"), this.body = this.flyingBird.querySelector("#body"), this.bodyWave = this.flyingBird.querySelector("#body_wave"), this.upFrontWing = this.flyingBird.querySelector("#front_up_wing"), this.upBackWing = this.flyingBird.querySelector("#back_up_wing"), this.downFrontWing = this.flyingBird.querySelector("#front_down_wing"), this.downBackWing = this.flyingBird.querySelector("#back_down_wing"), this.tail = this.flyingBird.querySelector("#tail"), this.tip = this.flyingBird.querySelector("#tip"), this.flyTl, this.floatTl, this.mousePos = { x: 0, y: 0 } } return l(e, [{ key: "flying", value: function () { this.flyTl && (this.flyTl.kill(), this.floatTl.kill()), this.flyTl = t.default.timeline({ repeat: -1, paused: !1 }), this.flyTl.set(this.upFrontWing, { opacity: .5 }), this.flyTl.set(this.upBackWing, { opacity: .5 }, 0), this.flyTl.set(this.upFrontWing, { opacity: 0 }, "+=0.025"), this.flyTl.set(this.upBackWing, { opacity: 0 }), this.flyTl.set(this.downFrontWing, { opacity: .5 }, "+=0.05"), this.flyTl.set(this.downBackWing, { opacity: .5 }), this.flyTl.set(this.downFrontWing, { opacity: 1 }, "+=0.075"), this.flyTl.set(this.downBackWing, { opacity: 1 }), this.floatTl = t.default.timeline({ repeat: -1 }), this.floatTl.to([this.flyingBirdSvg], { y: 7, duration: .3 }), this.floatTl.to([this.flyingBirdSvg], { y: 0, duration: .3 }, "-=0.05") } }, { key: "colorizeAndResizeBird", value: function (i) { var e = document.querySelector(".header .signature img"); t.default.timeline({ onComplete: i }).to(this.flyingBird, { width: e.offsetWidth }).to(this.bodyWave, { fill: "#72EDCF" }, 0).to(this.body, { fill: "#35E5BB" }, 0).to(this.tip, { fill: "#FD6619" }, 0).to(this.tail, { fill: "#F81664" }, 0).to([this.upBackWing, this.downBackWing], { fill: "#8E1388" }, 0).to([this.upFrontWing, this.downFrontWing], { fill: "#D32FCB" }, 0) } }, { key: "positionBird", value: function (i, e) { t.default.to(this.flyingBird, { x: i, y: e, duration: 1, ease: "power4.easeOut" }) } }, { key: "getLeftPosDeffer", value: function (t, i) { var e = t.getBoundingClientRect(); return i.getBoundingClientRect().left - e.left - e.width } }, { key: "getTopPosDeffer", value: function (t, i) { var e = t.getBoundingClientRect(), n = i.getBoundingClientRect(); return n.top - e.top - (e.height - n.height) / 2 } }, { key: "getDiffersForScaledPos", value: function (t, i) { var e = t.getBoundingClientRect(), n = i.getBoundingClientRect(); return { x: e.left + e.width / 2 - (n.left + n.width / 2), y: e.top + e.height / 2 - (n.top + n.height / 2) } } }, { key: "goToMousePosition", value: function () { var i = Math.min(Math.max(parseInt(this.mousePos.x), 100), window.innerWidth - 100), e = Math.min(Math.max(parseInt(this.mousePos.y), 100), window.innerHeight - 100); t.default.to(this.flyingBird, { x: i, y: e, duration: 1, ease: "power4.easeOut" }) } }, { key: "goToElementPosition", value: function (i) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = this.getLeftPosDeffer(this.flyingBird, i), o = this.getTopPosDeffer(this.flyingBird, i), l = e ? n + this.flyingBird.offsetWidth : n; t.default.to(this.flyingBird, { x: "+=".concat(l), y: "+=".concat(o), duration: 2, ease: "power4.easeOut" }) } }, { key: "dispose", value: function () { this.flyTl && this.flyTl.kill(), this.floatTl && this.floatTl.kill() } }]), e }(); exports.default = s;
    }, { "gsap": "TpQl", "./utils/utils": "HUaJ" }], "mDEI": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = r(require("gsap")), t = require("./utils/utils"); function r(e) { return e && e.__esModule ? e : { default: e } } function o(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function l(e, t) { for (var r = 0; r < t.length; r++) { var o = t[r]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } function i(e, t, r) { return t && l(e.prototype, t), r && l(e, r), e } var a = function () { function r(l) { o(this, r), t.bindMethods.call(this), this.onFinish = l, this.preloadEl = document.querySelector(".preloading"), this.preloadBullets = this.preloadEl.querySelector(".loading-bullets"), this.preloadBulletsChild = this.preloadBullets.querySelectorAll(".child"), this.preloadBulletsIcon = this.preloadBullets.querySelectorAll(".child i"), this.percentageEl = this.preloadEl.querySelector(".percentage"), this.preloadBirdPaths = this.preloadEl.querySelectorAll("svg path"), this.flyingBird = document.querySelector(".flying-bird"), e.default.to(this.preloadEl, { opacity: 1, duration: .2 }), this.init() } return i(r, [{ key: "init", value: function () { var r = this; e.default.ticker.add(a); var o = e.default.to({}, { duration: .1, paused: !0 }), l = e.default.timeline({ paused: !0, onComplete: function () { e.default.ticker.remove(a), l.kill() } }).to(this.preloadBulletsChild, { opacity: 1, stagger: .2 }).to(this.preloadBulletsIcon, { scale: 1, stagger: .2 }, 0), i = e.default.to(this.preloadBirdPaths, { strokeDashoffset: 0, paused: !1 }); function a() { var e = l.progress(); e += .05 * (o.progress() - e), l.progress(e), i.progress(e) } var n = document.querySelectorAll(".projects .project-row"); if (n) { var s = Array.from(n).map(function (e) { return e.querySelector(".project-item").getAttribute("data-image") }); s && (0, t.preloadImages)(s, function (e) { if (r.setPercentageContent(e), o.progress(e).pause(), 100 === e) var t = setTimeout(function () { r.onPreloadFinish(), clearTimeout(t) }, 700) }) } } }, { key: "setPercentageContent", value: function (t) { this.percentageEl.innerHTML = "".concat(Number(t).toFixed(0), "%"), t <= 25 ? e.default.to(this.percentageEl, { color: "#fd6619" }) : t <= 50 ? e.default.to(this.percentageEl, { color: "#f81664" }) : t <= 75 ? e.default.to(this.percentageEl, { color: "#d32fcb" }) : t <= 100 && e.default.to(this.percentageEl, { color: "#35e5bb" }) } }, { key: "onPreloadFinish", value: function () { var r = this, o = e.default.timeline({ onComplete: function () { o.kill(), r.onFinish() } }); o.to(this.flyingBird, { opacity: 1, duration: .5 }, 0), o.to(this.preloadBirdPaths, { opacity: 0, duration: .5 }, 0), o.to(this.preloadEl, { opacity: 0, display: "none" }, 0); var l = (0, t.css)(document.documentElement, "--bird-loaded-top").trim(), i = (0, t.css)(document.documentElement, "--bird-loaded-width"); o.to(this.flyingBird, { width: i.substring(0, i.length - 2), top: l, duration: 1 }, .5) } }]), r }(); exports.default = a;
    }, { "gsap": "TpQl", "./utils/utils": "HUaJ" }], "jhqH": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.ScrollToPlugin = void 0; var t, e, i, o, s, r, l, n = function () { return "undefined" != typeof window }, u = function () { return t || n() && (t = window.gsap) && t.registerPlugin && t }, p = function (t) { return "string" == typeof t }, a = function (t, e) { var r = "x" === e ? "Width" : "Height", l = "scroll" + r, n = "client" + r; return t === i || t === o || t === s ? Math.max(o[l], s[l]) - (i["inner" + r] || o[n] || s[n]) : t[l] - t["offset" + r] }, c = function (t, e) { var r = "scroll" + ("x" === e ? "Left" : "Top"); return t === i && (null != t.pageXOffset ? r = "page" + e.toUpperCase() + "Offset" : t = null != o[r] ? o : s), function () { return t[r] } }, f = function (t, e) { var l = r(t)[0].getBoundingClientRect(), n = !e || e === i || e === s, u = n ? { top: o.clientTop - (i.pageYOffset || o.scrollTop || s.scrollTop || 0), left: o.clientLeft - (i.pageXOffset || o.scrollLeft || s.scrollLeft || 0) } : e.getBoundingClientRect(), p = { x: l.left - u.left, y: l.top - u.top }; return !n && e && (p.x += c(e, "x")(), p.y += c(e, "y")()), p }, h = function (t, e, i, o, s) { return isNaN(t) || "object" == typeof t ? p(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + o - s : "max" === t ? a(e, i) - s : Math.min(a(e, i), f(t, e)[i] - s) : parseFloat(t) - s }, y = function () { t = u(), n() && t && document.body && (i = window, s = document.body, o = document.documentElement, r = t.utils.toArray, t.config({ autoKillThreshold: 7 }), l = t.config(), e = 1) }, x = { version: "3.5.1", name: "scrollTo", rawVars: 1, register: function (e) { t = e, y() }, init: function (t, o, s, r, l) { e || y(); this.isWin = t === i, this.target = t, this.tween = s, "object" != typeof o ? p((o = { y: o }).y) && "max" !== o.y && "=" !== o.y.charAt(1) && (o.x = o.y) : o.nodeType && (o = { y: o, x: o }), this.vars = o, this.autoKill = !!o.autoKill, this.getX = c(t, "x"), this.getY = c(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != o.x ? (this.add(this, "x", this.x, h(o.x, t, "x", this.x, o.offsetX || 0), r, l, Math.round), this._props.push("scrollTo_x")) : this.skipX = 1, null != o.y ? (this.add(this, "y", this.y, h(o.y, t, "y", this.y, o.offsetY || 0), r, l, Math.round), this._props.push("scrollTo_y")) : this.skipY = 1 }, render: function (t, e) { for (var o, s, r, n, u, p = e._pt, c = e.target, f = e.tween, h = e.autoKill, y = e.xPrev, x = e.yPrev, d = e.isWin; p;)p.r(t, p.d), p = p._next; o = d || !e.skipX ? e.getX() : y, r = (s = d || !e.skipY ? e.getY() : x) - x, n = o - y, u = l.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), h && (!e.skipX && (n > u || n < -u) && o < a(c, "x") && (e.skipX = 1), !e.skipY && (r > u || r < -u) && s < a(c, "y") && (e.skipY = 1), e.skipX && e.skipY && (f.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(f, e.vars.onAutoKillParams || []))), d ? i.scrollTo(e.skipX ? o : e.x, e.skipY ? s : e.y) : (e.skipY || (c.scrollTop = e.y), e.skipX || (c.scrollLeft = e.x)), e.xPrev = e.x, e.yPrev = e.y }, kill: function (t) { var e = "scrollTo" === t; (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1) } }; exports.default = exports.ScrollToPlugin = x, x.max = a, x.getOffset = f, x.buildGetter = c, u() && t.registerPlugin(x);
    }, {}], "TgBN": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.ScrollTrigger = void 0; var e, t, r, n, o, i, s, a, l, c, u, f, p, d, h, g, v, m, x, y, b, w, k, T, C, O = 1, M = [], S = [], P = Date.now, E = P(), _ = 0, A = 1, z = function (e) { return e }, L = function () { return "undefined" != typeof window }, R = function () { return e || L() && (e = window.gsap) && e.registerPlugin && e }, N = function (e) { return !!~s.indexOf(e) }, B = function (e, t) { return ~M.indexOf(e) && M[M.indexOf(e) + 1][t] }, I = function (e, t) { var r = t.s, n = t.sc, o = S.indexOf(e), i = n === he.sc ? 1 : 2; return !~o && (o = S.push(e) - 1), S[o + i] || (S[o + i] = B(e, r) || (N(e) ? n : function (t) { return arguments.length ? e[r] = t : e[r] })) }, F = function (e) { return B(e, "getBoundingClientRect") || (N(e) ? function () { return rt.width = r.innerWidth, rt.height = r.innerHeight, rt } : function () { return xe(e) }) }, W = function (e, t, n) { var o = n.d, i = n.d2, s = n.a; return (s = B(e, "getBoundingClientRect")) ? function () { return s()[o] } : function () { return (t ? r["inner" + i] : e["client" + i]) || 0 } }, D = function (e, t) { return !t || ~M.indexOf(e) ? F(e) : function () { return rt } }, q = function (e, t) { var n = t.s, s = t.d2, a = t.d, l = t.a; return (n = "scroll" + s) && (l = B(e, n)) ? l() - F(e)()[a] : N(e) ? Math.max(o[n], i[n]) - (r["inner" + s] || o["client" + s] || i["client" + s]) : e[n] - e["offset" + s] }, H = function (e, t) { for (var r = 0; r < b.length; r += 3)(!t || ~t.indexOf(b[r + 1])) && e(b[r], b[r + 1], b[r + 2]) }, X = function (e) { return "string" == typeof e }, Y = function (e) { return "function" == typeof e }, j = function (e) { return "number" == typeof e }, V = function (e) { return "object" == typeof e }, U = function (e) { return Y(e) && e() }, Z = function (e, t) { return function () { var r = U(e), n = U(t); return function () { U(r), U(n) } } }, $ = Math.abs, G = "scrollLeft", J = "scrollTop", K = "left", Q = "top", ee = "right", te = "bottom", re = "width", ne = "height", oe = "Right", ie = "Left", se = "Top", ae = "Bottom", le = "padding", ce = "margin", ue = "Width", fe = "Height", pe = "px", de = { s: G, p: K, p2: ie, os: ee, os2: oe, d: re, d2: ue, a: "x", sc: function (e) { return arguments.length ? r.scrollTo(e, he.sc()) : r.pageXOffset || n[G] || o[G] || i[G] || 0 } }, he = { s: J, p: Q, p2: se, os: te, os2: ae, d: ne, d2: fe, a: "y", op: de, sc: function (e) { return arguments.length ? r.scrollTo(de.sc(), e) : r.pageYOffset || n[J] || o[J] || i[J] || 0 } }, ge = function (e) { return r.getComputedStyle(e) }, ve = function (e) { return e.style.position = "absolute" === ge(e).position ? "absolute" : "relative" }, me = function (e, t) { for (var r in t) r in e || (e[r] = t[r]); return e }, xe = function (t, r) { var n = r && "matrix(1, 0, 0, 1, 0, 0)" !== ge(t)[v] && e.to(t, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), o = t.getBoundingClientRect(); return n && n.progress(0).kill(), o }, ye = function (e, t) { var r = t.d2; return e["offset" + r] || e["client" + r] || 0 }, be = function (t) { return function (r) { var n, o = [], i = t.labels, s = t.duration(); for (n in i) o.push(i[n] / s); return e.utils.snap(o, r) } }, we = function (e, t, r, n) { return r.split(",").forEach(function (r) { return e(t, r, n) }) }, ke = function (e, t, r) { return e.addEventListener(t, r, { passive: !0 }) }, Te = function (e, t, r) { return e.removeEventListener(t, r) }, Ce = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Oe = { toggleActions: "play", anticipatePin: 0 }, Me = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Se = function (e, t) { if (X(e)) { var r = e.indexOf("="), n = ~r ? +(e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0; n && (e.indexOf("%") > r && (n *= t / 100), e = e.substr(0, r - 1)), e = n + (e in Me ? Me[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, Pe = function (e, t, r, o, s, a, l) { var c = s.startColor, u = s.endColor, f = s.fontSize, p = s.indent, d = s.fontWeight, h = n.createElement("div"), g = N(r) || "fixed" === B(r, "pinType"), v = -1 !== e.indexOf("scroller"), m = g ? i : r, x = -1 !== e.indexOf("start"), y = x ? c : u, b = "border-color:" + y + ";font-size:" + f + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return b += "position:" + (v && g ? "fixed;" : "absolute;"), (v || !g) && (b += (o === he ? ee : te) + ":" + (a + parseFloat(p)) + "px;"), l && (b += "box-sizing:border-box;text-align:left;width:" + l.offsetWidth + "px;"), h._isStart = x, h.setAttribute("class", "gsap-marker-" + e), h.style.cssText = b, h.innerText = t || 0 === t ? e + "-" + t : e, m.insertBefore(h, m.children[0]), h._offset = h["offset" + o.op.d2], Ee(h, 0, o, x), h }, Ee = function (t, r, n, o) { var i = { display: "block" }, s = n[o ? "os2" : "p2"], a = n[o ? "p2" : "os2"]; t._isFlipped = o, i[n.a + "Percent"] = o ? -100 : 0, i[n.a] = o ? 1 : 0, i["border" + s + ue] = 1, i["border" + a + ue] = 0, i[n.p] = r, e.set(t, i) }, _e = [], Ae = {}, ze = function () { return c || (c = l(Ue)) }, Le = function () { c || (c = l(Ue), _ || De("scrollStart"), _ = P()) }, Re = function () { return !h && a.restart(!0) }, Ne = {}, Be = [], Ie = [], Fe = function (t) { var n, o = e.ticker.frame, i = [], s = 0; if (C !== o || O) { for (Xe(); s < Ie.length; s += 4)(n = r.matchMedia(Ie[s]).matches) !== Ie[s + 3] && (Ie[s + 3] = n, n ? i.push(s) : Xe(1, Ie[s]) || Y(Ie[s + 2]) && Ie[s + 2]()); for (He(), s = 0; s < i.length; s++)n = i[s], T = Ie[n], Ie[n + 2] = Ie[n + 1](t); T = 0, Ye(0, 1), C = o, De("matchMedia") } }, We = function e() { return Te(at, "scrollEnd", e) || Ye(!0) }, De = function (e) { return Ne[e] && Ne[e].map(function (e) { return e() }) || Be }, qe = [], He = function (e) { for (var t = 0; t < qe.length; t += 4)e && qe[t + 3] !== e || (qe[t].style.cssText = qe[t + 1], qe[t + 2].uncache = 1) }, Xe = function (e, t) { var r; for (m = 0; m < _e.length; m++)r = _e[m], t && r.media !== t || (e ? r.kill(1) : (r.scroll.rec || (r.scroll.rec = r.scroll()), r.revert())); He(t), t || De("revert") }, Ye = function (e, t) { if (!_ || e) { var r = De("refreshInit"); for (w && at.sort(), t || Xe(), m = 0; m < _e.length; m++)_e[m].refresh(); for (r.forEach(function (e) { return e && e.render && e.render(-1) }), m = _e.length; m--;)_e[m].scroll.rec = 0; a.pause(), De("refresh") } else ke(at, "scrollEnd", We) }, je = 0, Ve = 1, Ue = function () { var e = _e.length, t = P(), r = t - E >= 50, n = e && _e[0].scroll(); if (Ve = je > n ? -1 : 1, je = n, r && (_ && !g && t - _ > 200 && (_ = 0, De("scrollEnd")), p = E, E = t), Ve < 0) { for (m = e; m--;)_e[m] && _e[m].update(0, r); Ve = 1 } else for (m = 0; m < e; m++)_e[m] && _e[m].update(0, r); c = 0 }, Ze = [K, Q, te, ee, ce + ae, ce + oe, ce + se, ce + ie, "display", "flexShrink", "float"], $e = Ze.concat([re, ne, "boxSizing", "max" + ue, "max" + fe, "position", ce, le, le + se, le + oe, le + ae, le + ie]), Ge = function (e, t, r) { if (Qe(r), e.parentNode === t) { var n = t.parentNode; n && (n.insertBefore(e, t), n.removeChild(t)) } }, Je = function (e, t, r, n) { if (e.parentNode !== t) { for (var o, i = Ze.length, s = t.style, a = e.style; i--;)s[o = Ze[i]] = r[o]; s.position = "absolute" === r.position ? "absolute" : "relative", "inline" === r.display && (s.display = "inline-block"), a[te] = a[ee] = "auto", s.overflow = "visible", s.boxSizing = "border-box", s[re] = ye(e, de) + pe, s[ne] = ye(e, he) + pe, s[le] = a[ce] = a[Q] = a[K] = "0", Qe(n), a[re] = a["max" + ue] = r[re], a[ne] = a["max" + fe] = r[ne], a[le] = r[le], e.parentNode.insertBefore(t, e), t.appendChild(e) } }, Ke = /([A-Z])/g, Qe = function (e) { if (e) for (var t, r, n = e.t.style, o = e.length, i = 0; i < o; i += 2)r = e[i + 1], t = e[i], r ? n[t] = r : n[t] && n.removeProperty(t.replace(Ke, "-$1").toLowerCase()) }, et = function (e) { for (var t = $e.length, r = e.style, n = [], o = 0; o < t; o++)n.push($e[o], r[$e[o]]); return n.t = e, n }, tt = function (e, t, r) { for (var n, o = [], i = e.length, s = r ? 8 : 0; s < i; s += 2)n = e[s], o.push(n, n in t ? t[n] : e[s + 1]); return o.t = e.t, o }, rt = { left: 0, top: 0 }, nt = function (e, t, r, n, s, a, l, c, f, p, d, h) { if (Y(e) && (e = e(c)), X(e) && "max" === e.substr(0, 3) && (e = h + ("=" === e.charAt(4) ? Se("0" + e.substr(3), r) : 0)), j(e)) l && Ee(l, r, n, !0); else { Y(t) && (t = t(c)); var g, v, m, x = u(t)[0] || i, y = xe(x) || {}, b = e.split(" "); y && (y.left || y.top) || "none" !== ge(x).display || (m = x.style.display, x.style.display = "block", y = xe(x), m ? x.style.display = m : x.style.removeProperty("display")), g = Se(b[0], y[n.d]), v = Se(b[1] || "0", r), e = y[n.p] - f[n.p] - p + g + s - v, l && Ee(l, v, n, r - v < 20 || l._isStart && v > 20), r -= r - v } if (a) { var w = e + r, k = a._isStart; h = "scroll" + n.d2, Ee(a, w, n, k && w > 20 || !k && (d ? Math.max(i[h], o[h]) : a.parentNode[h]) <= w + 1), d && (f = xe(l), d && (a.style[n.op.p] = f[n.op.p] - n.op.m - a._offset + pe)) } return Math.round(e) }, ot = /(?:webkit|moz|length|cssText)/i, it = function (t, r, n, o) { if (t.parentNode !== r) { var s, a, l = t.style; if (r === i) { for (s in t._stOrig = l.cssText, a = ge(t)) +s || ot.test(s) || !a[s] || "string" != typeof l[s] || "0" === s || (l[s] = a[s]); l.top = n, l.left = o } else l.cssText = t._stOrig; e.core.getCache(t).uncache = 1, r.appendChild(t) } }, st = function (t, r) { var n, o, i = I(t, r), s = "_scroll" + r.p2; return t[s] = i, function r(a, l, c, u, f) { var p = r.tween, d = l.onComplete, h = {}; return p && p.kill(), n = Math.round(c), l[s] = a, l.modifiers = h, h[s] = function (e) { return (e = Math.round(i())) !== n && e !== o ? (p.kill(), r.tween = 0) : e = c + u * p.ratio + f * p.ratio * p.ratio, o = n, n = Math.round(e) }, l.onComplete = function () { r.tween = 0, d && d.call(p) }, p = r.tween = e.to(t, l) } }; de.op = he; var at = function () { function c(r, n) { t || c.register(e) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(r, n) } return c.prototype.init = function (t, s) { if (this.progress = 0, this.vars && this.kill(1), A) { var a, l, d, v, x, y, b, C, M, S, E, L, R, F, H, U, Z, G, J, K, Q, ee, te, we, Me, Ee, ze, Ne, Be, Ie, Fe, De, qe, He, Xe, Ye, je, Ue = (t = me(X(t) || j(t) || t.nodeType ? { trigger: t } : t, Oe)).horizontal ? de : he, Ze = t, $e = Ze.onUpdate, Ke = Ze.toggleClass, rt = Ze.id, ot = Ze.onToggle, at = Ze.onRefresh, lt = Ze.scrub, ct = Ze.trigger, ut = Ze.pin, ft = Ze.pinSpacing, pt = Ze.invalidateOnRefresh, dt = Ze.anticipatePin, ht = Ze.onScrubComplete, gt = Ze.onSnapComplete, vt = Ze.once, mt = Ze.snap, xt = Ze.pinReparent, yt = !lt && 0 !== lt, bt = u(t.scroller || r)[0], wt = e.core.getCache(bt), kt = N(bt), Tt = "pinType" in t ? "fixed" === t.pinType : kt || "fixed" === B(bt, "pinType"), Ct = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], Ot = yt && t.toggleActions.split(" "), Mt = "markers" in t ? t.markers : Oe.markers, St = kt ? 0 : parseFloat(ge(bt)["border" + Ue.p2 + ue]) || 0, Pt = this, Et = t.onRefreshInit && function () { return t.onRefreshInit(Pt) }, _t = W(bt, kt, Ue), At = D(bt, kt); Pt.media = T, dt *= 45, _e.push(Pt), Pt.scroller = bt, Pt.scroll = I(bt, Ue), x = Pt.scroll(), Pt.vars = t, s = s || t.animation, "refreshPriority" in t && (w = 1), wt.tweenScroll = wt.tweenScroll || { top: st(bt, he), left: st(bt, de) }, Pt.tweenTo = a = wt.tweenScroll[Ue.p], s && (s.vars.lazy = !1, s._initted || !1 !== s.vars.immediateRender && !1 !== t.immediateRender && s.render(0, !0, !0), Pt.animation = s.pause(), s.scrollTrigger = Pt, (De = j(lt) && lt) && (Fe = e.to(s, { ease: "power3", duration: De, onComplete: function () { return ht && ht(Pt) } })), Be = 0, rt || (rt = s.vars.id)), mt && (V(mt) || (mt = { snapTo: mt }), e.set(kt ? [i, o] : bt, { scrollBehavior: "auto" }), d = Y(mt.snapTo) ? mt.snapTo : "labels" === mt.snapTo ? be(s) : e.utils.snap(mt.snapTo), qe = mt.duration || { min: .1, max: 2 }, qe = V(qe) ? f(qe.min, qe.max) : f(qe, qe), He = e.delayedCall(mt.delay || De / 2 || .1, function () { if (Math.abs(Pt.getVelocity()) < 10 && !g) { var e = s && !yt ? s.totalProgress() : Pt.progress, t = (e - Ie) / (P() - p) * 1e3 || 0, r = $(t / 2) * t / .185, n = e + r, o = f(0, 1, d(n, Pt)), i = Pt.scroll(), l = Math.round(b + o * F), c = a.tween; if (i <= C && i >= b && l !== i) { if (c && !c._initted && c.data <= Math.abs(l - i)) return; a(l, { duration: qe($(.185 * Math.max($(n - e), $(o - e)) / t / .05 || 0)), ease: mt.ease || "power3", data: Math.abs(l - i), onComplete: function () { Be = Ie = s && !yt ? s.totalProgress() : Pt.progress, gt && gt(Pt) } }, i, r * F, l - i - r * F) } } else Pt.isActive && He.restart(!0) }).pause()), rt && (Ae[rt] = Pt), ct = Pt.trigger = u(ct || ut)[0], ut = !0 === ut ? ct : u(ut)[0], X(Ke) && (Ke = { targets: ct, className: Ke }), ut && (!1 === ft || ft === ce || (ft = !(!ft && "flex" === ge(ut.parentNode).display) && le), Pt.pin = ut, !1 !== t.force3D && e.set(ut, { force3D: !0 }), (l = e.core.getCache(ut)).spacer ? H = l.pinState : (l.spacer = G = n.createElement("div"), G.setAttribute("class", "pin-spacer" + (rt ? " pin-spacer-" + rt : "")), l.pinState = H = et(ut)), Pt.spacer = G = l.spacer, Ne = ge(ut), we = Ne[ft + Ue.os2], K = e.getProperty(ut), Q = e.quickSetter(ut, Ue.a, pe), Je(ut, G, Ne), Z = et(ut)), Mt && (R = V(Mt) ? me(Mt, Ce) : Ce, E = Pe("scroller-start", rt, bt, Ue, R, 0), L = Pe("scroller-end", rt, bt, Ue, R, 0, E), J = E["offset" + Ue.op.d2], M = Pe("start", rt, bt, Ue, R, J), S = Pe("end", rt, bt, Ue, R, J), Tt || (ve(bt), e.set([E, L], { force3D: !0 }), Ee = e.quickSetter(E, Ue.a, pe), ze = e.quickSetter(L, Ue.a, pe))), Pt.revert = function (e) { var t = !1 !== e || !Pt.enabled, r = h; t !== v && (t && (Ye = Math.max(Pt.scroll(), Pt.scroll.rec || 0), Xe = Pt.progress, je = s && s.progress()), M && [M, S, E, L].forEach(function (e) { return e.style.display = t ? "none" : "block" }), t && (h = 1), Pt.update(t), h = r, ut && (t ? Ge(ut, G, H) : (!xt || !Pt.isActive) && Je(ut, G, ge(ut), Me)), v = t) }, Pt.refresh = function (r) { if (!h && Pt.enabled) if (ut && r && _) ke(c, "scrollEnd", We); else { h = 1, Fe && Fe.kill(), pt && s && s.progress(0).invalidate(), v || Pt.revert(); for (var n, o, a, l, u, f, p, d, g = _t(), m = At(), w = q(bt, Ue), k = 0, T = 0, O = t.end, P = t.endTrigger || ct, A = t.start || (0 === t.start ? 0 : ut || !ct ? "0 0" : "0 100%"), z = ct && Math.max(0, _e.indexOf(Pt)) || 0, R = z; R--;)(p = _e[R].pin) && (p === ct || p === ut) && _e[R].revert(); for (b = nt(A, ct, g, Ue, Pt.scroll(), M, E, Pt, m, St, Tt, w) || (ut ? -.001 : 0), Y(O) && (O = O(Pt)), X(O) && !O.indexOf("+=") && (~O.indexOf(" ") ? O = (X(A) ? A.split(" ")[0] : "") + O : (k = Se(O.substr(2), g), O = X(A) ? A : b + k, P = ct)), C = Math.max(b, nt(O || (P ? "100% 0" : w), P, g, Ue, Pt.scroll() + k, S, L, Pt, m, St, Tt, w)) || -.001, F = C - b || (b -= .01) && .001, k = 0, R = z; R--;)(p = (f = _e[R]).pin) && f.start - f._pinPush < b && (n = f.end - f.start, p === ct && (k += n), p === ut && (T += n)); if (b += k, C += k, Pt._pinPush = T, M && k && ((n = {})[Ue.a] = "+=" + k, e.set([M, S], n)), ut) n = ge(ut), l = Ue === he, a = Pt.scroll(), ee = parseFloat(K(Ue.a)) + T, !w && C > 1 && ((kt ? i : bt).style["overflow-" + Ue.a] = "scroll"), Je(ut, G, n), Z = et(ut), o = xe(ut, !0), d = Tt && I(bt, l ? de : he)(), ft && ((Me = [ft + Ue.os2, F + T + pe]).t = G, (R = ft === le ? ye(ut, Ue) + F + T : 0) && Me.push(Ue.d, R + pe), Qe(Me), Tt && Pt.scroll(Ye)), Tt && ((u = { top: o.top + (l ? a - b : d) + pe, left: o.left + (l ? d : a - b) + pe, boxSizing: "border-box", position: "fixed" })[re] = u["max" + ue] = Math.ceil(o.width) + pe, u[ne] = u["max" + fe] = Math.ceil(o.height) + pe, u[ce] = u[ce + se] = u[ce + oe] = u[ce + ae] = u[ce + ie] = "0", u[le] = n[le], u[le + se] = n[le + se], u[le + oe] = n[le + oe], u[le + ae] = n[le + ae], u[le + ie] = n[le + ie], U = tt(H, u, xt)), s ? (s.progress(1, !0), te = K(Ue.a) - ee + F + T, F !== te && U.splice(U.length - 2, 2), s.progress(0, !0)) : te = F; else if (ct && Pt.scroll()) for (o = ct.parentNode; o && o !== i;)o._pinOffset && (b -= o._pinOffset, C -= o._pinOffset), o = o.parentNode; for (R = 0; R < z; R++)(f = _e[R].pin) && (f === ct || f === ut) && _e[R].revert(!1); Pt.start = b, Pt.end = C, (x = y = Pt.scroll()) < Ye && Pt.scroll(Ye), Pt.revert(!1), h = 0, je && yt && s.progress(je, !0), Xe !== Pt.progress && (Fe && s.totalProgress(Xe, !0), Pt.progress = Xe, Pt.update()), ut && ft && (G._pinOffset = Math.round(Pt.progress * te)), at && at(Pt) } }, Pt.getVelocity = function () { return (Pt.scroll() - y) / (P() - p) * 1e3 || 0 }, Pt.update = function (e, t) { var r, n, o, l, c, f = Pt.scroll(), d = e ? 0 : (f - b) / F, g = d < 0 ? 0 : d > 1 ? 1 : d || 0, v = Pt.progress; if (t && (y = x, x = f, mt && (Ie = Be, Be = s && !yt ? s.totalProgress() : g)), dt && !g && ut && !h && !O && _ && b < f + (f - y) / (P() - p) * dt && (g = 1e-4), g !== v && Pt.enabled) { if (l = (c = (r = Pt.isActive = !!g && g < 1) !== (!!v && v < 1)) || !!g != !!v, Pt.direction = g > v ? 1 : -1, Pt.progress = g, yt || (!Fe || h || O ? s && s.totalProgress(g, !!h) : (Fe.vars.totalProgress = g, Fe.invalidate().restart())), ut) if (e && ft && (G.style[ft + Ue.os2] = we), Tt) { if (l) { if (o = !e && g > v && C + 1 > f && f + 1 >= q(bt, Ue), xt) if (e || !r && !o) it(ut, G); else { var m = xe(ut, !0), w = f - b; it(ut, i, m.top + (Ue === he ? w : 0) + pe, m.left + (Ue === he ? 0 : w) + pe) } Qe(r || o ? U : Z), te !== F && g < 1 && r || Q(ee + (1 !== g || o ? 0 : te)) } } else Q(ee + te * g); mt && !a.tween && !h && !O && He.restart(!0), Ke && (c || vt && g && (g < 1 || !k)) && u(Ke.targets).forEach(function (e) { return e.classList[r || vt ? "add" : "remove"](Ke.className) }), $e && !yt && !e && $e(Pt), l && !h ? (n = g && !v ? 0 : 1 === g ? 1 : 1 === v ? 2 : 3, yt && (o = !c && "none" !== Ot[n + 1] && Ot[n + 1] || Ot[n], s && ("complete" === o || "reset" === o || o in s) && ("complete" === o ? s.pause().totalProgress(1) : "reset" === o ? s.restart(!0).pause() : s[o]()), $e && $e(Pt)), !c && k || (ot && c && ot(Pt), Ct[n] && Ct[n](Pt), vt && (1 === g ? Pt.kill(!1, 1) : Ct[n] = 0), c || Ct[n = 1 === g ? 1 : 3] && Ct[n](Pt))) : yt && $e && !h && $e(Pt) } ze && (Ee(f + (E._isFlipped ? 1 : 0)), ze(f)) }, Pt.enable = function () { Pt.enabled || (Pt.enabled = !0, ke(bt, "resize", Re), ke(bt, "scroll", Le), Et && ke(c, "refreshInit", Et), s && s.add ? e.delayedCall(.01, function () { return b || C || Pt.refresh() }) && (F = .01) && (b = C = 0) : Pt.refresh()) }, Pt.disable = function (e, t) { if (Pt.enabled && (!1 !== e && Pt.revert(), Pt.enabled = Pt.isActive = !1, t || Fe && Fe.pause(), Ye = 0, l && (l.uncache = 1), Et && Te(c, "refreshInit", Et), He && (He.pause(), a.tween && a.tween.kill() && (a.tween = 0)), !kt)) { for (var r = _e.length; r--;)if (_e[r].scroller === bt && _e[r] !== Pt) return; Te(bt, "resize", Re), Te(bt, "scroll", Le) } }, Pt.kill = function (e, t) { Pt.disable(e, t), rt && delete Ae[rt]; var r = _e.indexOf(Pt); _e.splice(r, 1), r === m && Ve > 0 && m--, s && (s.scrollTrigger = null, e && s.render(-1), t || s.kill()), M && [M, S, E, L].forEach(function (e) { return e.parentNode.removeChild(e) }), l && (l.uncache = 1) }, Pt.enable() } else this.update = this.refresh = this.kill = z }, c.register = function (p) { if (!t && (e = p || R(), L() && window.document && (r = window, n = document, o = n.documentElement, i = n.body), e && (u = e.utils.toArray, f = e.utils.clamp, e.core.globals("ScrollTrigger", c), i))) { l = r.requestAnimationFrame || function (e) { return setTimeout(e, 16) }, ke(r, "mousewheel", Le), s = [r, n, o, i], ke(n, "scroll", Le); var h, m = i.style, w = m.borderTop; m.borderTop = "1px solid #000", h = xe(i), he.m = Math.round(h.top + he.sc()) || 0, de.m = Math.round(h.left + de.sc()) || 0, w ? m.borderTop = w : m.removeProperty("border-top"), d = setInterval(ze, 200), e.delayedCall(.5, function () { return O = 0 }), ke(n, "touchcancel", z), ke(i, "touchstart", z), we(ke, n, "pointerdown,touchstart,mousedown", function () { return g = 1 }), we(ke, n, "pointerup,touchend,mouseup", function () { return g = 0 }), v = e.utils.checkPrefix("transform"), $e.push(v), t = P(), a = e.delayedCall(.2, Ye).pause(), b = [n, "visibilitychange", function () { var e = r.innerWidth, t = r.innerHeight; n.hidden ? (x = e, y = t) : x === e && y === t || Re() }, n, "DOMContentLoaded", Ye, r, "load", function () { return _ || Ye() }, r, "resize", Re], H(ke) } return t }, c.defaults = function (e) { for (var t in e) Oe[t] = e[t] }, c.kill = function () { A = 0, _e.slice(0).forEach(function (e) { return e.kill(1) }) }, c.config = function (e) { "limitCallbacks" in e && (k = !!e.limitCallbacks); var t = e.syncInterval; t && clearInterval(d) || (d = t) && setInterval(ze, t), "autoRefreshEvents" in e && (H(Te) || H(ke, e.autoRefreshEvents || "none")) }, c.scrollerProxy = function (e, t) { var n = u(e)[0]; N(n) ? M.unshift(r, t, i, t, o, t) : M.unshift(n, t) }, c.matchMedia = function (e) { var t, n, o, i, s; for (n in e) o = Ie.indexOf(n), i = e[n], T = n, "all" === n ? i() : (t = r.matchMedia(n)) && (t.matches && (s = i()), ~o ? (Ie[o + 1] = Z(Ie[o + 1], i), Ie[o + 2] = Z(Ie[o + 2], s)) : (o = Ie.length, Ie.push(n, i, s), t.addListener ? t.addListener(Fe) : t.addEventListener("change", Fe)), Ie[o + 3] = t.matches), T = 0; return Ie }, c.clearMatchMedia = function (e) { e || (Ie.length = 0), (e = Ie.indexOf(e)) >= 0 && Ie.splice(e, 4) }, c }(); exports.default = exports.ScrollTrigger = at, at.version = "3.5.1", at.saveStyles = function (t) { return t ? u(t).forEach(function (t) { var r = qe.indexOf(t); r >= 0 && qe.splice(r, 4), qe.push(t, t.style.cssText, e.core.getCache(t), T) }) : qe }, at.revert = function (e, t) { return Xe(!e, t) }, at.create = function (e, t) { return new at(e, t) }, at.refresh = function (e) { return e ? Re() : Ye(!0) }, at.update = Ue, at.maxScroll = function (e, t) { return q(e, t ? de : he) }, at.getScrollFunc = function (e, t) { return I(u(e)[0], t ? de : he) }, at.getById = function (e) { return Ae[e] }, at.getAll = function () { return _e.slice(0) }, at.isScrolling = function () { return !!_ }, at.addEventListener = function (e, t) { var r = Ne[e] || (Ne[e] = []); ~r.indexOf(t) || r.push(t) }, at.removeEventListener = function (e, t) { var r = Ne[e], n = r && r.indexOf(t); n >= 0 && r.splice(n, 1) }, at.batch = function (t, r) { var n, o = [], i = {}, s = r.interval || .016, a = r.batchMax || 1e9, l = function (t, r) { var n = [], o = [], i = e.delayedCall(s, function () { r(n, o), n = [], o = [] }).pause(); return function (e) { n.length || i.restart(!0), n.push(e.trigger), o.push(e), a <= n.length && i.progress(1) } }; for (n in r) i[n] = "on" === n.substr(0, 2) && Y(r[n]) && "onRefreshInit" !== n ? l(0, r[n]) : r[n]; return Y(a) && (a = a(), ke(at, "refresh", function () { return a = r.batchMax() })), u(t).forEach(function (e) { var t = {}; for (n in i) t[n] = i[n]; t.trigger = e, o.push(at.create(t)) }), o }, at.sort = function (e) { return _e.sort(e || function (e, t) { return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)) }) }, R() && e.registerPlugin(at);
    }, {}], "ED4Q": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getRawPath = b, exports.copyRawPath = S, exports.reverseSegment = R, exports.convertToPath = _, exports.getRotationAtProgress = I, exports.sliceRawPath = j, exports.cacheRawPathMeasurements = F, exports.subdivideSegment = O, exports.getPositionOnPath = q, exports.transformRawPath = B, exports.stringToRawPath = Z, exports.bezierToPoints = D, exports.flatPointsToSegment = G, exports.pointsToSegment = H, exports.simplifyPoints = J, exports.getClosestData = W, exports.subdivideSegmentNear = X, exports.rawPathToString = Y; var t, e = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, n = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, r = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, o = /(^[#\.][a-z]|[a-y][a-z])/i, a = Math.PI / 180, s = 180 / Math.PI, l = Math.sin, i = Math.cos, h = Math.abs, u = Math.sqrt, g = Math.atan2, f = 1e8, p = function (t) { return "string" == typeof t }, c = function (t) { return "number" == typeof t }, v = function (t) { return void 0 === t }, d = {}, x = {}, m = 1e5, M = function (t) { return Math.round((t + f) % 1 * m) / m || (t < 0 ? 0 : 1) }, L = function (t) { return Math.round(t * m) / m || 0 }, y = function (t, e, n, r) { var o = t[e], a = 1 === r ? 6 : O(o, n, r); if (a && a + n + 2 < o.length) return t.splice(e, 0, o.slice(0, n + a + 2)), o.splice(0, n + a), 1 }, P = function (t, e) { var n = t.length; for (e || t.reverse(); n--;)t[n].reversed || R(t[n]) }, w = function (t, e) { return e.totalLength = t.totalLength, t.samples ? (e.samples = t.samples.slice(0), e.lookup = t.lookup.slice(0), e.minLength = t.minLength, e.resolution = t.resolution) : e.totalPoints = t.totalPoints, e }, N = function (t, e) { var n = t.length, r = t[n - 1] || [], o = r.length; e[0] === r[o - 2] && e[1] === r[o - 1] && (e = r.concat(e.slice(2)), n--), t[n] = e }; function b(t) { var e, n = (t = p(t) && o.test(t) && document.querySelector(t) || t).getAttribute ? t : 0; return n && (t = t.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (e = n._gsPath[t]) && !e._dirty ? e : n._gsPath[t] = Z(t)) : t ? p(t) ? Z(t) : c(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string") } function S(t) { for (var e = [], n = 0; n < t.length; n++)e[n] = w(t[n], t[n].slice(0)); return w(t, e) } function R(t) { var e, n = 0; for (t.reverse(); n < t.length; n += 2)e = t[n], t[n] = t[n + 1], t[n + 1] = e; t.reversed = !t.reversed } var A = function (t, e) { var n, r = document.createElementNS("http://www.w3.org/2000/svg", "path"), o = [].slice.call(t.attributes), a = o.length; for (e = "," + e + ","; --a > -1;)n = o[a].nodeName.toLowerCase(), e.indexOf("," + n + ",") < 0 && r.setAttributeNS(null, n, o[a].nodeValue); return r }, C = { rect: "rx,ry,x,y,width,height", circle: "r,cx,cy", ellipse: "rx,ry,cx,cy", line: "x1,x2,y1,y2" }, z = function (t, e) { for (var n = e ? e.split(",") : [], r = {}, o = n.length; --o > -1;)r[n[o]] = +t.getAttribute(n[o]) || 0; return r }; function _(t, e) { var r, o, a, s, l, i, h, u, g, f, p, c, v, d, x, m, M, L, y, P, w, N, b = t.tagName.toLowerCase(), S = .552284749831; return "path" !== b && t.getBBox ? (i = A(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), N = z(t, C[b]), "rect" === b ? (s = N.rx, l = N.ry || s, o = N.x, a = N.y, f = N.width - 2 * s, p = N.height - 2 * l, r = s || l ? "M" + (m = (d = (v = o + s) + f) + s) + "," + (L = a + l) + " V" + (y = L + p) + " C" + [m, P = y + l * S, x = d + s * S, w = y + l, d, w, d - (d - v) / 3, w, v + (d - v) / 3, w, v, w, c = o + s * (1 - S), w, o, P, o, y, o, y - (y - L) / 3, o, L + (y - L) / 3, o, L, o, M = a + l * (1 - S), c, a, v, a, v + (d - v) / 3, a, d - (d - v) / 3, a, d, a, x, a, m, M, m, L].join(",") + "z" : "M" + (o + f) + "," + a + " v" + p + " h" + -f + " v" + -p + " h" + f + "z") : "circle" === b || "ellipse" === b ? ("circle" === b ? u = (s = l = N.r) * S : (s = N.rx, u = (l = N.ry) * S), r = "M" + ((o = N.cx) + s) + "," + (a = N.cy) + " C" + [o + s, a + u, o + (h = s * S), a + l, o, a + l, o - h, a + l, o - s, a + u, o - s, a, o - s, a - u, o - h, a - l, o, a - l, o + h, a - l, o + s, a - u, o + s, a].join(",") + "z") : "line" === b ? r = "M" + N.x1 + "," + N.y1 + " L" + N.x2 + "," + N.y2 : "polyline" !== b && "polygon" !== b || (r = "M" + (o = (g = (t.getAttribute("points") + "").match(n) || []).shift()) + "," + (a = g.shift()) + " L" + g.join(","), "polygon" === b && (r += "," + o + "," + a + "z")), i.setAttribute("d", Y(i._gsRawPath = Z(r))), e && t.parentNode && (t.parentNode.insertBefore(i, t), t.parentNode.removeChild(t)), i) : t } function I(t, e) { var n = V(t, e >= 1 ? 1 - 1e-9 : e || 1e-9); return T(n.segment, n.i, n.t) } function T(t, e, n) { var r, o = t[e], a = t[e + 2], l = t[e + 4]; return o += (a - o) * n, o += ((a += (l - a) * n) - o) * n, r = a + (l + (t[e + 6] - l) * n - a) * n - o, o = t[e + 1], o += ((a = t[e + 3]) - o) * n, o += ((a += ((l = t[e + 5]) - a) * n) - o) * n, L(g(a + (l + (t[e + 7] - l) * n - a) * n - o, r) * s) } function j(t, e, n) { v(n) && (n = 1); var r = (e = e || 0) > n, o = Math.max(0, ~~(h(n - e) - 1e-8)); if (r && (r = n, n = e, e = r, r = 1, o -= o ? 1 : 0), e < 0 || n < 0) { var a = 1 + ~~Math.min(e, n); e += a, n += a } var s, l, i, u, g, f, p, c = S(t.totalLength ? t : F(t)), m = n > 1, M = V(c, e, d, !0), L = V(c, n, x), w = L.segment, b = M.segment, R = L.segIndex, A = M.segIndex, C = L.i, z = M.i, _ = A === R, I = C === z && _, j = _ && z > C || I && M.t > L.t; if (m || o) { if (y(c, A, z, M.t) && (s = 1, A++, I ? j ? L.t /= M.t : (L.t = (L.t - M.t) / (1 - M.t), R++, C = 0) : A <= R + 1 && !j && (R++, _ && (C -= z))), L.t ? y(c, R, C, L.t) && (j && s && A++, r && R++) : (R--, r && A--), u = [], f = 1 + (g = c.length) * o, p = A, r) for (f += (g - (R = (R || g) - 1) + A) % g, i = 0; i < f; i++)N(u, c[p]), p = (p || g) - 1; else for (f += (g - A + R) % g, i = 0; i < f; i++)N(u, c[p++ % g]); c = u } else if (l = 1 === L.t ? 6 : O(w, C, L.t), e !== n) for (s = O(b, z, I ? M.t / L.t : M.t), _ && (l += s), w.splice(C + l + 2), (s || z) && b.splice(0, z + s), i = c.length; i--;)(i < A || i > R) && c.splice(i, 1); else w.angle = T(w, C + l, 0), M = w[C += l], L = w[C + 1], w.length = w.totalLength = 0, w.totalPoints = c.totalPoints = 8, w.push(M, L, M, L, M, L, M, L); return r && P(c, m || o), c.totalLength = 0, c } function k(t, e, n) { e = e || 0, t.samples || (t.samples = [], t.lookup = []); var r, o, a, s, l, i, g, p, c, v, d, x, m, M, L, y, P, w = ~~t.resolution || 12, N = 1 / w, b = n ? e + 6 * n + 1 : t.length, S = t[e], R = t[e + 1], A = e ? e / 6 * w : 0, C = t.samples, z = t.lookup, _ = (e ? t.minLength : f) || f, I = C[A + n * w - 1], T = e ? C[A - 1] : 0; for (C.length = z.length = 0, o = e + 2; o < b; o += 6) { if (a = t[o + 4] - S, s = t[o + 2] - S, l = t[o] - S, p = t[o + 5] - R, c = t[o + 3] - R, v = t[o + 1] - R, i = g = d = x = 0, h(a) < 1e-5 && h(p) < 1e-5 && h(l) + h(v) < 1e-5) t.length > 8 && (t.splice(o, 6), o -= 6, b -= 6); else for (r = 1; r <= w; r++)i = g - (g = ((M = N * r) * M * a + 3 * (m = 1 - M) * (M * s + m * l)) * M), d = x - (x = (M * M * p + 3 * m * (M * c + m * v)) * M), (y = u(d * d + i * i)) < _ && (_ = y), T += y, C[A++] = T; S += a, R += p } if (I) for (I -= T; A < C.length; A++)C[A] += I; if (C.length && _) for (t.totalLength = P = C[C.length - 1] || 0, t.minLength = _, y = L = 0, r = 0; r < P; r += _)z[y++] = C[L] < r ? ++L : L; else t.totalLength = C[0] = 0; return e ? T - C[e / 2 - 1] : T } function F(t, e) { var n, r, o; for (o = n = r = 0; o < t.length; o++)t[o].resolution = ~~e || 12, r += t[o].length, n += k(t[o]); return t.totalPoints = r, t.totalLength = n, t } function O(t, e, n) { if (n <= 0 || n >= 1) return 0; var r = t[e], o = t[e + 1], a = t[e + 2], s = t[e + 3], l = t[e + 4], i = t[e + 5], h = r + (a - r) * n, u = a + (l - a) * n, g = o + (s - o) * n, f = s + (i - s) * n, p = h + (u - h) * n, c = g + (f - g) * n, v = l + (t[e + 6] - l) * n, d = i + (t[e + 7] - i) * n; return u += (v - u) * n, f += (d - f) * n, t.splice(e + 2, 4, L(h), L(g), L(p), L(c), L(p + (u - p) * n), L(c + (f - c) * n), L(u), L(f), L(v), L(d)), t.samples && t.samples.splice(e / 6 * t.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6 } function V(t, e, n, r) { n = n || {}, t.totalLength || F(t), (e < 0 || e > 1) && (e = M(e)); var o, a, s, l, i, h, u, g = 0, f = t[0]; if (t.length > 1) { for (s = t.totalLength * e, i = h = 0; (i += t[h++].totalLength) < s;)g = h; e = (s - (l = i - (f = t[g]).totalLength)) / (i - l) || 0 } return o = f.samples, a = f.resolution, s = f.totalLength * e, l = (h = f.lookup[~~(s / f.minLength)] || 0) ? o[h - 1] : 0, (i = o[h]) < s && (l = i, i = o[++h]), u = 1 / a * ((s - l) / (i - l) + h % a), h = 6 * ~~(h / a), r && 1 === u && (h + 6 < f.length ? (h += 6, u = 0) : g + 1 < t.length && (h = u = 0, f = t[++g])), n.t = u, n.i = h, n.path = t, n.segment = f, n.segIndex = g, n } function q(t, e, n, r) { var o, a, s, l, i, h, u, g, f, p = t[0], c = r || {}; if ((e < 0 || e > 1) && (e = M(e)), t.length > 1) { for (s = t.totalLength * e, i = h = 0; (i += t[h++].totalLength) < s;)p = t[h]; e = (s - (l = i - p.totalLength)) / (i - l) || 0 } return o = p.samples, a = p.resolution, s = p.totalLength * e, l = (h = p.lookup[~~(s / p.minLength)] || 0) ? o[h - 1] : 0, (i = o[h]) < s && (l = i, i = o[++h]), f = 1 - (u = 1 / a * ((s - l) / (i - l) + h % a) || 0), g = p[h = 6 * ~~(h / a)], c.x = L((u * u * (p[h + 6] - g) + 3 * f * (u * (p[h + 4] - g) + f * (p[h + 2] - g))) * u + g), c.y = L((u * u * (p[h + 7] - (g = p[h + 1])) + 3 * f * (u * (p[h + 5] - g) + f * (p[h + 3] - g))) * u + g), n && (c.angle = p.totalLength ? T(p, h, u >= 1 ? 1 - 1e-9 : u || 1e-9) : p.angle || 0), c } function B(t, e, n, r, o, a, s) { for (var l, i, h, u, g, f = t.length; --f > -1;)for (i = (l = t[f]).length, h = 0; h < i; h += 2)u = l[h], g = l[h + 1], l[h] = u * e + g * r + a, l[h + 1] = u * n + g * o + s; return t._dirty = 1, t } function E(t, e, n, r, o, s, g, f, p) { if (t !== f || e !== p) { n = h(n), r = h(r); var c = o % 360 * a, v = i(c), d = l(c), x = Math.PI, m = 2 * x, M = (t - f) / 2, L = (e - p) / 2, y = v * M + d * L, P = -d * M + v * L, w = y * y, N = P * P, b = w / (n * n) + N / (r * r); b > 1 && (n = u(b) * n, r = u(b) * r); var S = n * n, R = r * r, A = (S * R - S * N - R * w) / (S * N + R * w); A < 0 && (A = 0); var C = (s === g ? -1 : 1) * u(A), z = C * (n * P / r), _ = C * (-r * y / n), I = (t + f) / 2 + (v * z - d * _), T = (e + p) / 2 + (d * z + v * _), j = (y - z) / n, k = (P - _) / r, F = (-y - z) / n, O = (-P - _) / r, V = j * j + k * k, q = (k < 0 ? -1 : 1) * Math.acos(j / u(V)), B = (j * O - k * F < 0 ? -1 : 1) * Math.acos((j * F + k * O) / u(V * (F * F + O * O))); isNaN(B) && (B = x), !g && B > 0 ? B -= m : g && B < 0 && (B += m), q %= m, B %= m; var E, Z = Math.ceil(h(B) / (m / 4)), D = [], G = B / Z, H = 4 / 3 * l(G / 2) / (1 + i(G / 2)), Q = v * n, U = d * n, J = d * -r, K = v * r; for (E = 0; E < Z; E++)y = i(o = q + E * G), P = l(o), j = i(o += G), k = l(o), D.push(y - H * P, P + H * y, j + H * k, k - H * j, j, k); for (E = 0; E < D.length; E += 2)y = D[E], P = D[E + 1], D[E] = y * Q + P * J + I, D[E + 1] = y * U + P * K + T; return D[E - 2] = f, D[E - 1] = p, D } } function Z(t) { var n, o, a, s, l, i, u, g, f, p, c, v, d, x, m, M = (t + "").replace(r, function (t) { var e = +t; return e < 1e-4 && e > -1e-4 ? 0 : e }).match(e) || [], L = [], y = 0, P = 0, w = M.length, N = 0, b = "ERROR: malformed path: " + t, S = function (t, e, n, r) { p = (n - t) / 3, c = (r - e) / 3, u.push(t + p, e + c, n - p, r - c, n, r) }; if (!t || !isNaN(M[0]) || isNaN(M[1])) return console.log(b), L; for (n = 0; n < w; n++)if (d = l, isNaN(M[n]) ? i = (l = M[n].toUpperCase()) !== M[n] : n--, a = +M[n + 1], s = +M[n + 2], i && (a += y, s += P), n || (g = a, f = s), "M" === l) u && (u.length < 8 ? L.length -= 1 : N += u.length), y = g = a, P = f = s, u = [a, s], L.push(u), n += 2, l = "L"; else if ("C" === l) u || (u = [0, 0]), i || (y = P = 0), u.push(a, s, y + 1 * M[n + 3], P + 1 * M[n + 4], y += 1 * M[n + 5], P += 1 * M[n + 6]), n += 6; else if ("S" === l) p = y, c = P, "C" !== d && "S" !== d || (p += y - u[u.length - 4], c += P - u[u.length - 3]), i || (y = P = 0), u.push(p, c, a, s, y += 1 * M[n + 3], P += 1 * M[n + 4]), n += 4; else if ("Q" === l) p = y + 2 / 3 * (a - y), c = P + 2 / 3 * (s - P), i || (y = P = 0), y += 1 * M[n + 3], P += 1 * M[n + 4], u.push(p, c, y + 2 / 3 * (a - y), P + 2 / 3 * (s - P), y, P), n += 4; else if ("T" === l) p = y - u[u.length - 4], c = P - u[u.length - 3], u.push(y + p, P + c, a + 2 / 3 * (y + 1.5 * p - a), s + 2 / 3 * (P + 1.5 * c - s), y = a, P = s), n += 2; else if ("H" === l) S(y, P, y = a, P), n += 1; else if ("V" === l) S(y, P, y, P = a + (i ? P - y : 0)), n += 1; else if ("L" === l || "Z" === l) "Z" === l && (a = g, s = f, u.closed = !0), ("L" === l || h(y - a) > .5 || h(P - s) > .5) && (S(y, P, a, s), "L" === l && (n += 2)), y = a, P = s; else if ("A" === l) { if (x = M[n + 4], m = M[n + 5], p = M[n + 6], c = M[n + 7], o = 7, x.length > 1 && (x.length < 3 ? (c = p, p = m, o--) : (c = m, p = x.substr(2), o -= 2), m = x.charAt(1), x = x.charAt(0)), v = E(y, P, +M[n + 1], +M[n + 2], +M[n + 3], +x, +m, (i ? y : 0) + 1 * p, (i ? P : 0) + 1 * c), n += o, v) for (o = 0; o < v.length; o++)u.push(v[o]); y = u[u.length - 2], P = u[u.length - 1] } else console.log(b); return (n = u.length) < 6 ? (L.pop(), n = 0) : u[0] === u[n - 2] && u[1] === u[n - 1] && (u.closed = !0), L.totalPoints = N + n, L } function D(t, e, n, r, o, a, s, l, i, u, g) { var f, p = (t + n) / 2, c = (e + r) / 2, v = (n + o) / 2, d = (r + a) / 2, x = (o + s) / 2, m = (a + l) / 2, M = (p + v) / 2, L = (c + d) / 2, y = (v + x) / 2, P = (d + m) / 2, w = (M + y) / 2, N = (L + P) / 2, b = s - t, S = l - e, R = h((n - s) * S - (r - l) * b), A = h((o - s) * S - (a - l) * b); return u || (u = [t, e, s, l], g = 2), u.splice(g || u.length - 2, 0, w, N), (R + A) * (R + A) > i * (b * b + S * S) && (f = u.length, D(t, e, p, c, M, L, w, N, i, u, g), D(w, N, y, P, x, m, s, l, i, u, g + 2 + (u.length - f))), u } function G(t, e) { void 0 === e && (e = 1); for (var n = t[0], r = 0, o = [n, r], a = 2; a < t.length; a += 2)o.push(n, r, t[a], r = (t[a] - n) * e / 2, n = t[a], -r); return o } function H(t, e, n) { var r, o, a, s, h, f, p, c, v, d, x, m, M, y, P = t.length - 2, w = +t[0], N = +t[1], b = +t[2], S = +t[3], R = [w, N, w, N], A = b - w, C = S - N, z = Math.abs(t[P] - w) < .001 && Math.abs(t[P + 1] - N) < .001; for (isNaN(n) && (n = Math.PI / 10), z && (t.push(b, S), b = w, S = N, w = t[P - 2], N = t[P - 1], t.unshift(w, N), P += 4), e = e || 0 === e ? +e : 1, h = 2; h < P; h += 2)r = w, o = N, w = b, N = S, m = (f = A) * f + (c = C) * c, M = (A = (b = +t[h + 2]) - w) * A + (C = (S = +t[h + 3]) - N) * C, y = (p = b - r) * p + (v = S - o) * v, x = (a = Math.acos((m + M - y) / u(4 * m * M))) / Math.PI * e, d = u(m) * x, x *= u(M), w === r && N === o || (a > n ? (s = g(v, p), R.push(L(w - i(s) * d), L(N - l(s) * d), L(w), L(N), L(w + i(s) * x), L(N + l(s) * x))) : (s = g(c, f), R.push(L(w - i(s) * d), L(N - l(s) * d)), s = g(C, A), R.push(L(w), L(N), L(w + i(s) * x), L(N + l(s) * x)))); return R.push(L(b), L(S), L(b), L(S)), z && (R.splice(0, 6), R.length = R.length - 6), R } function Q(t, e, n, r, o, a) { var s, l = o - n, i = a - r; return (l || i) && ((s = ((t - n) * l + (e - r) * i) / (l * l + i * i)) > 1 ? (n = o, r = a) : s > 0 && (n += l * s, r += i * s)), Math.pow(t - n, 2) + Math.pow(e - r, 2) } function U(t, e, n, r, o) { var a, s, l, i = r, h = t[e], u = t[e + 1], g = t[n], f = t[n + 1]; for (s = e + 2; s < n; s += 2)(l = Q(t[s], t[s + 1], h, u, g, f)) > i && (a = s, i = l); i > r && (a - e > 2 && U(t, e, a, r, o), o.push(t[a], t[a + 1]), n - a > 2 && U(t, a, n, r, o)) } function J(t, e) { var n, r, o, a, s, l, i, h = parseFloat(t[0]), u = parseFloat(t[1]), g = [h, u], f = t.length - 2; for (e = Math.pow(e || 1, 2), n = 2; n < f; n += 2)(a = h - (r = parseFloat(t[n]))) * a + (s = u - (o = parseFloat(t[n + 1]))) * s > e && (g.push(r, o), h = r, u = o); return g.push(parseFloat(t[f]), parseFloat(t[f + 1])), U(g, 0, i = g.length - 2, e, l = [g[0], g[1]]), l.push(g[i], g[i + 1]), l } function K(e, n, r, o, a, s, l, i, h, u, g, p, c, v) { var d, x, m, M, L = (a - o) / s, y = 0, P = o; for (t = f; P <= a;)(d = (x = (M = 1 - P) * M * M * l + 3 * M * M * P * h + 3 * M * P * P * g + P * P * P * c - n) * x + (m = M * M * M * i + 3 * M * M * P * u + 3 * M * P * P * p + P * P * P * v - r) * m) < t && (t = d, y = P), P += L; return e > 1 ? K(e - 1, n, r, Math.max(y - L, 0), Math.min(y + L, 1), s, l, i, h, u, g, p, c, v) : y } function W(e, n, r, o) { var a, s, l, i, h = { j: 0, i: 0, t: 0 }, u = f; for (s = 0; s < e.length; s++)for (i = e[s], a = 0; a < i.length; a += 6)l = K(1, n, r, 0, 1, o || 20, i[a], i[a + 1], i[a + 2], i[a + 3], i[a + 4], i[a + 5], i[a + 6], i[a + 7]), u > t && (u = t, h.j = s, h.i = a, h.t = l); return h } function X(e, n, r, o, a) { var s, l, i = r.length, h = f, u = 0, g = 0; for (o = o || 20, a = a || 3, l = 0; l < i; l += 6)s = K(1, e, n, 0, 1, o, r[l], r[l + 1], r[l + 2], r[l + 3], r[l + 4], r[l + 5], r[l + 6], r[l + 7]), h > t && (h = t, u = s, g = l); return O(r, g, s = K(a, e, n, u - .05, u + .05, o, r[g], r[g + 1], r[g + 2], r[g + 3], r[g + 4], r[g + 5], r[g + 6], r[g + 7])), g + 6 } function Y(t) { c(t[0]) && (t = [t]); var e, n, r, o, a = "", s = t.length; for (n = 0; n < s; n++) { for (o = t[n], a += "M" + L(o[0]) + "," + L(o[1]) + " C", e = o.length, r = 2; r < e; r++)a += L(o[r++]) + "," + L(o[r++]) + " " + L(o[r++]) + "," + L(o[r++]) + " " + L(o[r++]) + "," + L(o[r]) + " "; o.closed && (a += "z") } return a }
    }, {}], "ZBXp": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getGlobalMatrix = T, exports.Matrix2D = void 0; var t, e, r, n, o, i, s, a, d = "transform", f = d + "Origin", l = function (o) { var i = o.ownerDocument || o; !(d in o.style) && "msTransform" in o.style && (f = (d = "msTransform") + "Origin"); for (; i.parentNode && (i = i.parentNode);); if (e = window, s = new N, i) { t = i, r = i.documentElement, n = i.body; var l = i.createElement("div"), p = i.createElement("div"); n.appendChild(l), l.appendChild(p), l.style.position = "static", l.style[d] = "translate3d(0,0,1px)", a = p.offsetParent !== l, n.removeChild(l) } return i }, p = function (t) { for (var e, r; t && t !== n;)(r = t._gsap) && !r.scaleX && !r.scaleY && r.renderTransform && (r.scaleX = r.scaleY = 1e-4, r.renderTransform(1, r), e ? e.push(r) : e = [r]), t = t.parentNode; return e }, u = [], h = [], c = function () { return e.pageYOffset || t.scrollTop || r.scrollTop || n.scrollTop || 0 }, m = function () { return e.pageXOffset || t.scrollLeft || r.scrollLeft || n.scrollLeft || 0 }, b = function (t) { return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null) }, v = function t(r) { return "fixed" === e.getComputedStyle(r).position || ((r = r.parentNode) && 1 === r.nodeType ? t(r) : void 0) }, g = function e(r, n) { if (r.parentNode && (t || l(r))) { var s = b(r), a = s ? s.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", d = s ? n ? "rect" : "g" : "div", f = 2 !== n ? 0 : 100, p = 3 === n ? 100 : 0, u = "position:absolute;display:block;pointer-events:none;", h = t.createElementNS ? t.createElementNS(a.replace(/^https/, "http"), d) : t.createElement(d); return n && (s ? (i || (i = e(r)), h.setAttribute("width", .01), h.setAttribute("height", .01), h.setAttribute("transform", "translate(" + f + "," + p + ")"), i.appendChild(h)) : (o || ((o = e(r)).style.cssText = u), h.style.cssText = u + "width:0.1px;height:0.1px;top:" + p + "px;left:" + f + "px", o.appendChild(h))), h } throw "Need document and parent." }, x = function (t) { for (var e = new N, r = 0; r < t.numberOfItems; r++)e.multiply(t.getItem(r).matrix); return e }, y = function (t, r) { var n, l, p, c, m, v = b(t), y = t === v, w = v ? u : h; if (t === e) return t; if (w.length || w.push(g(t, 1), g(t, 2), g(t, 3)), n = v ? i : o, v) p = y ? { x: 0, y: 0 } : t.getBBox(), (l = t.transform ? t.transform.baseVal : {}).numberOfItems ? (c = (l = l.numberOfItems > 1 ? x(l) : l.getItem(0).matrix).a * p.x + l.c * p.y, m = l.b * p.x + l.d * p.y) : (l = s, c = p.x, m = p.y), r && "g" === t.tagName.toLowerCase() && (c = m = 0), n.setAttribute("transform", "matrix(" + l.a + "," + l.b + "," + l.c + "," + l.d + "," + (l.e + c) + "," + (l.f + m) + ")"), (y ? v : t.parentNode).appendChild(n); else { if (c = m = 0, a) for (l = t.offsetParent, p = t; p && (p = p.parentNode) && p !== l && p.parentNode;)(e.getComputedStyle(p)[d] + "").length > 4 && (c = p.offsetLeft, m = p.offsetTop, p = 0); (p = n.style).top = t.offsetTop - m + "px", p.left = t.offsetLeft - c + "px", l = e.getComputedStyle(t), p[d] = l[d], p[f] = l[f], p.border = l.border, p.borderLeftStyle = l.borderLeftStyle, p.borderTopStyle = l.borderTopStyle, p.borderLeftWidth = l.borderLeftWidth, p.borderTopWidth = l.borderTopWidth, p.position = "fixed" === l.position ? "fixed" : "absolute", t.parentNode.appendChild(n) } return n }, w = function (t, e, r, n, o, i, s) { return t.a = e, t.b = r, t.c = n, t.d = o, t.e = i, t.f = s, t }, N = function () { function t(t, e, r, n, o, i) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === n && (n = 1), void 0 === o && (o = 0), void 0 === i && (i = 0), w(this, t, e, r, n, o, i) } var e = t.prototype; return e.inverse = function () { var t = this.a, e = this.b, r = this.c, n = this.d, o = this.e, i = this.f, s = t * n - e * r || 1e-10; return w(this, n / s, -e / s, -r / s, t / s, (r * i - n * o) / s, -(t * i - e * o) / s) }, e.multiply = function (t) { var e = this.a, r = this.b, n = this.c, o = this.d, i = this.e, s = this.f, a = t.a, d = t.c, f = t.b, l = t.d, p = t.e, u = t.f; return w(this, a * e + f * n, a * r + f * o, d * e + l * n, d * r + l * o, i + p * e + u * n, s + p * r + u * o) }, e.clone = function () { return new t(this.a, this.b, this.c, this.d, this.e, this.f) }, e.equals = function (t) { var e = this.a, r = this.b, n = this.c, o = this.d, i = this.e, s = this.f; return e === t.a && r === t.b && n === t.c && o === t.d && i === t.e && s === t.f }, e.apply = function (t, e) { void 0 === e && (e = {}); var r = t.x, n = t.y, o = this.a, i = this.b, s = this.c, a = this.d, d = this.e, f = this.f; return e.x = r * o + n * s + d || 0, e.y = r * i + n * a + f || 0, e }, t }(); function T(e, r, n) { if (!e || !e.parentNode || (t || l(e)).documentElement === e) return new N; var o = p(e.parentNode), i = b(e) ? u : h, s = y(e, n), a = i[0].getBoundingClientRect(), d = i[1].getBoundingClientRect(), f = i[2].getBoundingClientRect(), g = s.parentNode, x = v(e), w = new N((d.left - a.left) / 100, (d.top - a.top) / 100, (f.left - a.left) / 100, (f.top - a.top) / 100, a.left + (x ? 0 : m()), a.top + (x ? 0 : c())); if (g.removeChild(s), o) for (a = o.length; a--;)(d = o[a]).scaleX = d.scaleY = 0, d.renderTransform(1, d); return r ? w.inverse() : w } exports.Matrix2D = N;
    }, {}], "DOrM": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.MotionPathPlugin = void 0; var t, e, a, r, n = require("./utils/paths.js"), i = require("./utils/matrix.js"), o = ["x", "translateX", "left", "marginLeft"], s = ["y", "translateY", "top", "marginTop"], u = Math.PI / 180, h = function () { return t || "undefined" != typeof window && (t = window.gsap) && t.registerPlugin && t }, g = function (t, e, a, r) { for (var n = e.length, i = 2 === r ? 0 : r, o = 0; o < n; o++)t[i] = parseFloat(e[o][a]), 2 === r && (t[i + 1] = 0), i += 2; return t }, l = function (t, e, a) { return parseFloat(t._gsap.get(t, e, a || "px")) || 0 }, p = function (t) { var e, a = t[0], r = t[1]; for (e = 2; e < t.length; e += 2)a = t[e] += a, r = t[e + 1] += r }, f = function (t, e, a, r, i, o, s) { "cubic" === s.type ? e = [e] : (e.unshift(l(a, r, s.unitX), i ? l(a, i, s.unitY) : 0), s.relative && p(e), e = [(i ? n.pointsToSegment : n.flatPointsToSegment)(e, s.curviness)]); return e = o(y(e, a, s)), d(t, a, r, e, "x", s.unitX), i && d(t, a, i, e, "y", s.unitY), (0, n.cacheRawPathMeasurements)(e, s.resolution || (0 === s.curviness ? 20 : 12)) }, c = function (t) { return t }, P = /[-+\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/g, x = function (t, e, a) { var r, n, o, s = (0, i.getGlobalMatrix)(t); return "svg" === (t.tagName + "").toLowerCase() ? (n = (r = t.viewBox.baseVal).x, o = r.y, r.width || (r = { width: +t.getAttribute("width"), height: +t.getAttribute("height") })) : (r = e && t.getBBox && t.getBBox(), n = o = 0), e && "auto" !== e && (n += e.push ? e[0] * (r ? r.width : t.offsetWidth || 0) : e.x, o += e.push ? e[1] * (r ? r.height : t.offsetHeight || 0) : e.y), a.apply(n || o ? s.apply({ x: n, y: o }) : { x: s.e, y: s.f }) }, w = function (t, e, a, r) { var n, o = (0, i.getGlobalMatrix)(t.parentNode, !0, !0), s = o.clone().multiply((0, i.getGlobalMatrix)(e)), u = x(t, a, o), h = x(e, r, o), g = h.x, l = h.y; return s.e = s.f = 0, "auto" === r && e.getTotalLength && "path" === e.tagName.toLowerCase() && (n = e.getAttribute("d").match(P) || [], g += (n = s.apply({ x: +n[0], y: +n[1] })).x, l += n.y), (n || e.getBBox && t.getBBox && e.ownerSVGElement === t.ownerSVGElement) && (g -= (n = s.apply(e.getBBox())).x, l -= n.y), s.e = g - u.x, s.f = l - u.y, s }, y = function (e, a, i) { var o, s, u, h = i.align, g = i.matrix, p = i.offsetX, f = i.offsetY, c = i.alignOrigin, P = e[0][0], x = e[0][1], y = l(a, "x"), d = l(a, "y"); return e && e.length ? (h && ("self" === h || (o = r(h)[0] || a) === a ? (0, n.transformRawPath)(e, 1, 0, 0, 1, y - P, d - x) : (c && !1 !== c[2] ? t.set(a, { transformOrigin: 100 * c[0] + "% " + 100 * c[1] + "%" }) : c = [l(a, "xPercent") / -100, l(a, "yPercent") / -100], u = (s = w(a, o, c, "auto")).apply({ x: P, y: x }), (0, n.transformRawPath)(e, s.a, s.b, s.c, s.d, y + s.e - (u.x - s.e), d + s.f - (u.y - s.f)))), g ? (0, n.transformRawPath)(e, g.a, g.b, g.c, g.d, g.e, g.f) : (p || f) && (0, n.transformRawPath)(e, 1, 0, 0, 1, p || 0, f || 0), e) : (0, n.getRawPath)("M0,0L0,0") }, d = function (t, r, n, i, o, s) { var u = r._gsap, h = u.harness, g = h && h.aliases && h.aliases[n], l = g && g.indexOf(",") < 0 ? g : n, p = t._pt = new e(t._pt, r, l, 0, 0, c, 0, u.set(r, l, t)); p.u = a(u.get(r, l, s)) || 0, p.path = i, p.pp = o, t._props.push(l) }, m = function (t, e) { return function (a) { return t || 1 !== e ? (0, n.sliceRawPath)(a, t, e) : a } }, v = { version: "3.5.1", name: "motionPath", register: function (n, i, o) { a = (t = n).utils.getUnit, r = t.utils.toArray, e = o }, init: function (e, r) { if (!t) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1; "object" == typeof r && !r.style && r.path || (r = { path: r }); var i, u, h, l, p = [], c = r.path, P = c[0], x = r.autoRotate, w = m(r.start, "end" in r ? r.end : 1); if (this.rawPaths = p, this.target = e, (this.rotate = x || 0 === x) && (this.rOffset = parseFloat(x) || 0, this.radians = !!r.useRadians, this.rProp = r.rotation || "rotation", this.rSet = e._gsap.set(e, this.rProp, this), this.ru = a(e._gsap.get(e, this.rProp)) || 0), !Array.isArray(c) || "closed" in c || "number" == typeof P) i = w(y((0, n.getRawPath)(r.path), e, r)), (0, n.cacheRawPathMeasurements)(i, r.resolution), p.push(i), d(this, e, r.x || "x", i, "x", r.unitX || "px"), d(this, e, r.y || "y", i, "y", r.unitY || "px"); else { for (u in P) ~o.indexOf(u) ? h = u : ~s.indexOf(u) && (l = u); for (u in h && l ? p.push(f(this, g(g([], c, h, 0), c, l, 1), e, r.x || h, r.y || l, w, r)) : h = l = 0, P) u !== h && u !== l && p.push(f(this, g([], c, u, 2), e, u, 0, w, r)) } }, render: function (t, e) { var a = e.rawPaths, r = a.length, i = e._pt; for (t > 1 ? t = 1 : t < 0 && (t = 0); r--;)(0, n.getPositionOnPath)(a[r], t, !r && e.rotate, a[r]); for (; i;)i.set(i.t, i.p, i.path[i.pp] + i.u, i.d, t), i = i._next; e.rotate && e.rSet(e.target, e.rProp, a[0].angle * (e.radians ? u : 1) + e.rOffset + e.ru, e, t) }, getLength: function (t) { return (0, n.cacheRawPathMeasurements)((0, n.getRawPath)(t)).totalLength }, sliceRawPath: n.sliceRawPath, getRawPath: n.getRawPath, pointsToSegment: n.pointsToSegment, stringToRawPath: n.stringToRawPath, rawPathToString: n.rawPathToString, transformRawPath: n.transformRawPath, getGlobalMatrix: i.getGlobalMatrix, getPositionOnPath: n.getPositionOnPath, cacheRawPathMeasurements: n.cacheRawPathMeasurements, convertToPath: function (t, e) { return r(t).map(function (t) { return (0, n.convertToPath)(t, !1 !== e) }) }, convertCoordinates: function (t, e, a) { var r = (0, i.getGlobalMatrix)(e, !0, !0).multiply((0, i.getGlobalMatrix)(t)); return a ? r.apply(a) : r }, getAlignMatrix: w, getRelativePosition: function (t, e, a, r) { var n = w(t, e, a, r); return { x: n.e, y: n.f } }, arrayToRawPath: function (t, e) { var a = g(g([], t, (e = e || {}).x || "x", 0), t, e.y || "y", 1); return e.relative && p(a), ["cubic" === e.type ? a : (0, n.pointsToSegment)(a, e.curviness)] } }; exports.default = exports.MotionPathPlugin = v, h() && t.registerPlugin(v);
    }, { "./utils/paths.js": "ED4Q", "./utils/matrix.js": "ZBXp" }], "plBY": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.bindMethods = d, exports.getBackgroundPosition = exports.setBackgroundPosition = exports.motionType = exports.lowPassFilter = exports.gCDFApprox = exports.positionProperty = exports.vendorPrefix = exports.css = void 0; const t = (t, o, n) => n ? t.style[o] = n : getComputedStyle(t)[o]; exports.css = t; const o = () => { var t, o = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/, n = document.documentElement.style, e = ""; for (t in n) if (o.test(t)) { e = t.match(o)[0]; break } return "WebkitOpacity" in n && (e = "Webkit"), "KhtmlOpacity" in n && (e = "Khtml"), function (t) { return e + (e.length > 0 ? t.charAt(0).toUpperCase() + t.slice(1) : t) } }; exports.vendorPrefix = o; const n = o()("transform"), e = { position: { setLeft: function (o, n) { t(o, "left", `${n}px`) }, setTop: function (o, n) { t(o, "top", `${n}px`) } }, transform: { setPosition: function (o, e, s, r, i) { t(o, n, `translate3d(${e - s}px, ${r - i}px, 0)`) } } }; exports.positionProperty = e; const s = (t, o) => 1 / (1 + Math.exp(-.07056 * o * (3 ^ t) - 1.5976 * o * t)); exports.gCDFApprox = s; const r = (t, o, n) => null === o ? t : (void 0 === n && (n = .5), n * t + (1 - n) * o); exports.lowPassFilter = r; const i = [], p = { linear: function (t, o) { return t <= -o ? 1 : t >= o ? -1 : -t / o }, natural: function (t, o) { return t <= -o ? 1 : t >= o ? -1 : (void 0 === i["n" + o] && (i["n" + o] = Math.tan(.01745 * o)), -Math.tan(.01745 * t) / i["n" + o]) }, performance: function (t, o) { return t <= -o ? 1 : t >= o ? -1 : (void 0 === i["p" + o] && (i["p" + o] = o / 90 + 4.2 * Math.pow(o / 90, 7)), -(t / 90 + 4.2 * Math.pow(t / 90, 7)) / i["p" + o]) }, gaussian: function (t, o) { return 1 - 2 * s(t / 90, 135 / o) } }; exports.motionType = p; const c = void 0 !== t(document.documentElement, "backgroundPositionX"), a = (o, n, e) => { c ? (t(o, "backgroundPositionX", n), t(o, "backgroundPositionY", e)) : t(o, "backgroundPosition", `${n} ${e}`) }; exports.setBackgroundPosition = a; const u = o => c ? [t(o, "backgroundPositionX"), t(o, "backgroundPositionY")] : t(o, "backgroundPosition").split(" "); function d() { Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(t => { this[t] instanceof Function && "constructor" !== t && (this[t] = this[t].bind(this)) }) } exports.getBackgroundPosition = u;
    }, {}], "CgH9": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var t = require("./utils"); const i = 1e3, e = 30, a = { positionProperty: "position", horizontalParallax: !0, verticalParallax: !0, parallaxBackgrounds: !0, parallaxElements: !0, responsive: !1, useMouseMove: !0, useGyroscope: !0, alphaFilter: .9, motionType: "natural", mouseMotionType: "gaussian", inputPriority: "mouse", motionAngleX: 80, motionAngleY: 80, adjustBasePosition: !0, alphaPosition: .05 }, o = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { setTimeout(t, 1e3 / 30) }; class s { constructor(i, e) { t.bindMethods.call(this), this.elementQuery = e, this.options = Object.assign({}, a, i), this._defaults = a, this.init() } init() { this.tilt = { beta: 0, gamma: 0 }, this._defineElements(), this._defineGetters(), this._defineSetters(), this._detectMobile(), this._detectMotionType(), this._detectViewport(), this._handleWindowResize(), this.refresh({ firstLoad: !0 }), this._startAnimation() } _defineElements() { this.element = void 0 !== this.elementQuery ? document.querySelector(this.elementQuery) : document.body, this.viewportElement = window } _defineGetters() { const i = t.motionType[this.options.motionType], e = t.motionType[this.options.mouseMotionType]; this._getMoveHorizontal = (() => { if (this.useMouseMove && null !== this.clientX && this.clientX !== this.oldClientX) return e(this.options.motionAngleX * (1 - 2 * this.clientX / this.viewportWidth), this.options.motionAngleX); if (this.useSensor && null !== this.beta && null !== this.gamma) { var t = this.tilt; return this.viewportLandscape ? this.viewportFlipped ? i(-t.beta, this.options.motionAngleX) : i(t.beta, this.options.motionAngleX) : this.viewportFlipped ? i(-t.gamma, this.options.motionAngleX) : i(t.gamma, this.options.motionAngleX) } return this.useSensor = !1, e(this.options.motionAngleX * (1 - 2 * this.oldClientX / this.viewportWidth), this.options.motionAngleX) }), this._getMoveVertical = (() => { if (this.options.useMouseMove && null !== this.clientY && this.clientY !== this.oldClientY) return e(this.options.motionAngleY * (1 - 2 * this.clientY / this.viewportHeight), this.options.motionAngleY); if (this.useSensor && null !== this.beta && null !== this.gamma) { var t = this.tilt; return this.viewportLandscape ? this.viewportFlipped ? i(-t.gamma, this.options.motionAngleY) : i(t.gamma, this.options.motionAngleY) : this.viewportFlipped ? i(-t.beta, this.options.motionAngleY) : i(t.beta, this.options.motionAngleY) } return this.useSensor = !1, e(this.options.motionAngleY * (1 - 2 * this.oldClientY / this.viewportHeight), this.options.motionAngleY) }) } _defineSetters() { const i = t.positionProperty[this.options.positionProperty]; this._setPosition = i.setPosition || function (t, e, a, o, s) { this.options.horizontalParallax && i.setLeft(t, e, a), this.options.verticalParallax && i.setTop(t, o, s) } } refresh(t) { t && t.firstLoad || this._reset(), this._findElements(), this._findBackgrounds(), t && t.firstLoad && /WebKit/.test(navigator.userAgent) && window.addEventListener("DOMContentLoaded", () => { let t = document.body, i = t.scrollLeft, e = t.scrollTop; t.scrollLeft = i + 1, t.scrollTop = e + 1, t.scrollLeft = i, t.scrollTop = e }) } _detectViewport() { this.viewportWidth = this.viewportElement.innerWidth, this.viewportHeight = this.viewportElement.innerHeight, this.useSensor && (this.viewportFlipped = 180 === window.orientation, this.viewportLandscape = 90 === Math.abs(window.orientation)) } _detectMobile() { var t = navigator.userAgent || navigator.vendor || window.opera; this.isMobile = /(bb\d+|meego).+mobile|android|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|playbook|plucker|pocket|psp|series(4|6)0|silk|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4)) } _detectMotionType() { this.useSensor = !1, this.useSensorWebkit = !1, this.useSensorMoz = !1, this.useMouseMove = !1, this.options.useGyroscope && (this.isMobile || "gyroscope" === this.options.inputPriority) && (this.useSensorWebkit = void 0 !== window.DeviceOrientationEvent, this.useSensorMoz = void 0 !== window.OrientationEvent, this.useSensor = this.useSensorWebkit || this.useSensorMoz), this.options.useMouseMove && !this.isMobile && (this.useMouseMove = !0) } _findElements() { if (this.elements = [], this.options.parallaxElements) { var i = this.element.querySelectorAll("[data-parallaxify-range],[data-parallaxify-range-x],[data-parallaxify-range-y]"); Array.from(i).forEach(i => { if (!i.getAttribute("data-parallaxify-ElementIsActive")) { i.setAttribute("data-parallaxify-ElementIsActive", ""), i.getAttribute("data-parralaxify-originalLeft") ? ((0, t.css)(i, "left", i.getAttribute("data-parallaxify-originalLeft")), (0, t.css)(i, "top", i.getAttribute("data-parallaxify-originalTop"))) : (i.setAttribute("data-parallaxify-originalLeft", (0, t.css)(i, "left")), i.setAttribute("data-parallaxify-originalTop", (0, t.css)(i, "top"))); var e = i.getBoundingClientRect(); this.elements.push({ $element: i, originalPositionLeft: i.offsetLeft, originalPositionTop: i.offsetTop, parallaxDistanceX: i.getAttribute("data-parallaxify-range-x") ? i.getAttribute("data-parallaxify-range-x") : i.getAttribute("data-parallaxify-range") ? i.getAttribute("data-parallaxify-range") : 0, parallaxDistanceY: i.getAttribute("data-parallaxify-range-y") ? i.getAttribute("data-parallaxify-range-y") : i.getAttribute("data-parallaxify-range") ? i.getAttribute("data-parallaxify-range") : 0, width: e.width, height: e.height }) } }) } } _findBackgrounds() { var i; this.backgrounds = [], this.options.parallaxBackgrounds && (i = Array.from(this.element.querySelectorAll("[data-parallaxify-background-range],[data-parallaxify-background-range-x],[data-parallaxify-background-range-y]")), (this.element.getAttribute("data-parallaxify-background-range") || this.element.getAttribute("data-parallaxify-background-range-x") || this.element.getAttribute("data-parallaxify-background-range-y")) && i.push(this.element), i.forEach(i => { var e = (0, t.getBackgroundPosition)(i); if (i.getAttribute("data-parallaxify-backgroundIsActive")) { if (i.getAttribute("parallaxify-backgroundIsActive")) return } else i.setAttribute("data-parallaxify-backgroundIsActive", ""); i.getAttribute("data-parralaxify-backgroundOriginalLeft") ? (0, t.setBackgroundPosition)(i, i.getAttribute("data-parallaxify-backgroundOriginalLeft"), i.getAttribute("data-parallaxify-backgroundOriginalTop")) : (i.setAttribute("data-parallaxify-backgroundOriginalLeft", e[0]), i.setAttribute("data-parallaxify-backgroundOriginalTop", e[1])), this.backgrounds.push({ $element: i, originalValueLeft: e[0], originalValueTop: e[1], originalBackgroundPositionLeft: isNaN(parseInt(e[0], 10)) ? 0 : parseInt(e[0], 10), originalBackgroundPositionTop: isNaN(parseInt(e[1], 10)) ? 0 : parseInt(e[1], 10), originalPositionLeft: i.offsetLeft, originalPositionTop: i.offsetTop, parallaxDistanceX: i.getAttribute("data-parallaxify-background-range-x") ? i.getAttribute("data-parallaxify-background-range-x") : i.getAttribute("data-parallaxify-background-range") ? i.getAttribute("data-parallaxify-background-range") : 0, parallaxDistanceY: i.getAttribute("data-parallaxify-background-range-y") ? i.getAttribute("data-parallaxify-background-range-y") : i.getAttribute("data-parallaxify-background-range") ? i.getAttribute("data-parallaxify-background-range") : 0 }) })) } _reset() { let i, e; this.elements.forEach(t => { i = t.$element.getAttribute("data-parallaxify-originalLeft"), e = t.$element.getAttribute("data-parallaxify-originalTop"), this._setPosition(t.$element, i, i, e, e), t.$element.setAttribute("data-parallaxify-originalLeft", null), t.$element.setAttribute("data-parallaxify-originalLeft", null), t.$element.setAttribute("data-parallaxify-elementIsActive", null), t.$element.setAttribute("data-parallaxify-backgroundIsActive", null) }), this.backgrounds.forEach(i => { i.$element.setAttribute("data-parallaxify-backgroundOriginalLeft", null), i.$element.setAttribute("data-parallaxify-backgroundOriginalTop", null), i.$element.setAttribute("data-parallaxify-backgroundIsActive", null), (0, t.setBackgroundPosition)(i.$element, i.originalValueLeft, i.originalValueTop) }) } destroy() { this._reset(), this.useMouseMove && this.viewportElement.removeEventListener("mousemove", this._handleMouseMove), this.useSensorWebkit && window.removeEventListener("deviceorientation", this._handleSensorWebkit, !1), this.useSensorMoz && window.removeEventListener("MozOrientation", this._handleSensorMoz, !1), window.removeEventListener("DOMContentLoaded", this.refresh), window.removeEventListener("resize", this.refresh), window.removeEventListener("orientationchange", this.refresh) } _processSensorData() { if (this.useSensor) { var i = this.beta, e = this.gamma, a = 0, o = 0; i > 90 && (i -= 180), e > 180 && (e -= 360), void 0 === this.initialBeta && null !== i && (this.initialBeta = i, this.useSensor && "gyroscope" === this.options.inputPriority && (this.useMouseMove = !1, this.useMouseMove && this.viewportElement.removeEventListener("mousemove", this.name))), void 0 === this.initialGamma && null !== e && (this.initialGamma = e, this.useSensor && "gyroscope" === this.options.inputPriority && (this.useMouseMove = !1, this.useMouseMove && this.viewportElement.removeEventListener("mousemove", this.name))), this.options.adjustBasePosition && void 0 !== this.initialGamma && void 0 !== this.initialBeta && (e - this.initialGamma < -180 ? this.initialGamma = (0, t.lowPassFilter)(e + 360, this.initialGamma, this.options.alphaPosition) : e - this.initialGamma > 180 ? this.initialGamma = (0, t.lowPassFilter)(e - 360, this.initialGamma, this.options.alphaPosition) : this.initialGamma = (0, t.lowPassFilter)(e, this.initialGamma, this.options.alphaPosition), i - this.initialBeta < -90 ? this.initialBeta = (0, t.lowPassFilter)(i + 180, this.initialBeta, this.options.alphaPosition) : i - this.initialBeta > 90 ? this.initialBeta = (0, t.lowPassFilter)(i - 180, this.initialBeta, this.options.alphaPosition) : this.initialBeta = (0, t.lowPassFilter)(i, this.initialBeta, this.options.alphaPosition)), (a = void 0 !== this.initialBeta ? i - this.initialBeta : i) > 100 ? a -= 180 : a < -100 && (a += 180), (o = void 0 !== this.initialGamma ? e - this.initialGamma : e) > 200 ? o -= 360 : o < -200 && (o += 360), a = (0, t.lowPassFilter)(a, this.tilt.beta, this.options.alphaFilter), o = (0, t.lowPassFilter)(o, this.tilt.gamma, this.options.alphaFilter), this.tilt.beta = a, this.tilt.gamma = o } } _repositionElements() { let i, e, a, o, s = this._getMoveHorizontal(), n = this._getMoveVertical(); this.currentMoveHorizontal === s && this.currentMoveVertical === n && this.currentWidth === this.viewportWidth && this.currentHeight === this.viewportHeight || (this.currentMoveHorizontal = s, this.currentMoveVertical = n, this.currentWidth = this.viewportWidth, this.currentHeight = this.viewportHeight, this.elements.forEach(t => { a = this.options.horizontalParallax ? Math.floor(s * t.parallaxDistanceX / 2) + t.originalPositionLeft : t.originalPositionLeft, o = this.options.verticalParallax ? Math.floor(n * t.parallaxDistanceY / 2) + t.originalPositionTop : t.originalPositionTop, this._setPosition(t.$element, a, t.originalPositionLeft, o, t.originalPositionTop) }), this.backgrounds.forEach(a => { i = this.options.horizontalParallax ? Math.floor(s * a.parallaxDistanceX / 2) + a.originalBackgroundPositionLeft + "px" : a.originalValueLeft, e = this.options.verticalParallax ? Math.floor(n * a.parallaxDistanceY / 2) + a.originalBackgroundPositionTop + "px" : a.originalValueTop, (0, t.setBackgroundPosition)(a.$element, i, e) })) } _handleWindowResize() { window.addEventListener("resize", () => { this._detectViewport(), this.options.responsive && this.refresh() }), window.addEventListener("orientationchange", () => { this._detectViewport(), this.options.responsive && this.refresh() }) } _handleSensorWebkit(t) { this.gamma = t.gamma, this.beta = t.beta, this.requestTick() } _handleSensorMoz(t) { this.gamma = 180 * t.x, this.beta = -90 * t.y, this.requestTick() } _handleMouseMove(t) { this.oldClientX = this.clientX, this.oldClientY = this.clientY, void 0 !== t.clientX ? this.clientX = t.clientX : this.clientX = t.pageX, void 0 !== t.clientY ? this.clientY = t.clientY : this.clientY = t.pageY, this.requestTick() } _startAnimation() { this.ticking = !1, this.beta = 0, this.gamma = 0, this.clientX = this.oldClientX = Math.round(this.viewportWidth / 2), this.clientY = this.oldClientY = Math.round(this.viewportHeight / 2), this.useSensorWebkit ? window.addEventListener("deviceorientation", this._handleSensorWebkit, !1) : this.useSensorMoz && window.addEventListener("MozOrientation", this._handleSensorMoz, !1), this.useMouseMove && window.addEventListener("mousemove", this._handleMouseMove), this.requestTick() } update() { this._processSensorData(), this._repositionElements(), this.ticking = !1 } requestTick() { this.ticking || (o(this.update), this.ticking = !0) } } exports.default = s, window.Parallaxify = s;
    }, { "./utils": "plBY" }], "adZR": [function (require, module, exports) {
        module.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float noise;\nuniform float u_time;\nuniform float u_speed;\nuniform float u_spikes;\n\nvec3 mod289(vec3 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159-.85373472095314*r;\n}\n\nvec3 fade(vec3 t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P,vec3 rep){\n    vec3 Pi0=mod(floor(P),rep);// Integer part, modulo period\n    vec3 Pi1=mod(Pi0+vec3(1.),rep);// Integer part + 1, mod period\n    Pi0=mod289(Pi0);\n    Pi1=mod289(Pi1);\n    vec3 Pf0=fract(P);// Fractional part for interpolation\n    vec3 Pf1=Pf0-vec3(1.);// Fractional part - 1.0\n    vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\n    vec4 iy=vec4(Pi0.yy,Pi1.yy);\n    vec4 iz0=Pi0.zzzz;\n    vec4 iz1=Pi1.zzzz;\n    \n    vec4 ixy=permute(permute(ix)+iy);\n    vec4 ixy0=permute(ixy+iz0);\n    vec4 ixy1=permute(ixy+iz1);\n    \n    vec4 gx0=ixy0*(1./7.);\n    vec4 gy0=fract(floor(gx0)*(1./7.))-.5;\n    gx0=fract(gx0);\n    vec4 gz0=vec4(.5)-abs(gx0)-abs(gy0);\n    vec4 sz0=step(gz0,vec4(0.));\n    gx0-=sz0*(step(0.,gx0)-.5);\n    gy0-=sz0*(step(0.,gy0)-.5);\n    \n    vec4 gx1=ixy1*(1./7.);\n    vec4 gy1=fract(floor(gx1)*(1./7.))-.5;\n    gx1=fract(gx1);\n    vec4 gz1=vec4(.5)-abs(gx1)-abs(gy1);\n    vec4 sz1=step(gz1,vec4(0.));\n    gx1-=sz1*(step(0.,gx1)-.5);\n    gy1-=sz1*(step(0.,gy1)-.5);\n    \n    vec3 g000=vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100=vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010=vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110=vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001=vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101=vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011=vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111=vec3(gx1.w,gy1.w,gz1.w);\n    \n    vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n    g000*=norm0.x;\n    g010*=norm0.y;\n    g100*=norm0.z;\n    g110*=norm0.w;\n    vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n    g001*=norm1.x;\n    g011*=norm1.y;\n    g101*=norm1.z;\n    g111*=norm1.w;\n    \n    float n000=dot(g000,Pf0);\n    float n100=dot(g100,vec3(Pf1.x,Pf0.yz));\n    float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\n    float n110=dot(g110,vec3(Pf1.xy,Pf0.z));\n    float n001=dot(g001,vec3(Pf0.xy,Pf1.z));\n    float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\n    float n011=dot(g011,vec3(Pf0.x,Pf1.yz));\n    float n111=dot(g111,Pf1);\n    \n    vec3 fade_xyz=fade(Pf0);\n    vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n    vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\n    float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\n    return 2.2*n_xyz;\n}\n\nfloat turbulence(vec3 p){\n    float w=100.;\n    float t=-.5;\n    for(float f=1.;f<=10.;f++){\n        float power=pow(2.,f);\n        t+=abs(pnoise(vec3(power*p),vec3(10.,10.,10.))/power);\n    }\n    return t;\n}\n\nvoid main(){\n    vUv=uv;\n    \n    // use u_time to make animation realtime\n    float time=(u_time*.0001)*u_speed;\n    noise=20.*-.10*turbulence(.5*normal+time);\n    float b=u_spikes*pnoise(.04*position+vec3(2.*time),vec3(100.));\n    float displacement=-noise+b;\n    \n    vec3 newPosition=position+normal*displacement;\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(newPosition,1.);\n}";
    }, {}], "kt78": [function (require, module, exports) {
        module.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float noise;\nuniform float u_time;\nuniform float u_opacity;\nuniform float u_hoverProgress;\nuniform vec2 u_mouse;\nuniform sampler2D u_image;\nuniform vec2 u_res;\nuniform vec3 color1;\nuniform vec3 color2;\n\nfloat circle(in vec2 _st,in float _radius,in float blurriness){\n    vec2 dist=_st;\n    return 1.-smoothstep(_radius-(_radius*blurriness),_radius+(_radius*blurriness),dot(dist,dist)*4.);\n}\n\nvoid main(){\n    vec2 res=u_res*PR;\n    vec2 st=gl_FragCoord.xy/res.xy-vec2(.5);\n    st.y*=u_res.y/u_res.x;\n    \n    vec2 mouse=u_mouse*-.5;\n    vec2 circlePos=st+mouse;\n    \n    float c=circle(circlePos,u_hoverProgress,4.)*2.5;\n    \n    float finalMask=smoothstep(.4,.5,pow(c,2.));\n    vec4 color=vec4(mix(color1,color2,vUv.y),.2);\n    vec4 hover=texture2D(u_image,vUv);\n    \n    vec4 finalImage=mix(color,hover,u_hoverProgress);\n    \n    gl_FragColor=finalImage;\n    gl_FragColor.a=u_opacity;\n}";
    }, {}], "BHmR": [function (require, module, exports) {
        module.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float noise;\nuniform float u_time;\nuniform float u_opacity;\nuniform sampler2D u_image;\nuniform vec2 u_res;\n\nvoid main(){\n    vec2 res=u_res*PR;\n    vec2 st=gl_FragCoord.xy/res.xy-vec2(.5);\n    st.y*=u_res.y/u_res.x;\n    \n    gl_FragColor=texture2D(u_image,vUv);\n    gl_FragColor.a=u_opacity;\n}";
    }, {}], "U60R": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var o = { ui_ux: { color1: "#60BA62", color2: "#6EC6B6" }, graphic_design: { color1: "#FD1617", color2: "#E53375" }, architecture: { color1: "#FE390C", color2: "#FACE40" }, other: { color1: "#FE390C", color2: "#FACE40" }, promo_videos: { color1: "#371084", color2: "#791A89" }, featured_works: { color1: "#371084", color2: "#791A89" } }; exports.default = o;
    }, {}], "BAlE": [function (require, module, exports) {
        "use strict"; module.exports = i, module.exports.isMobile = i, module.exports.default = i; const e = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, o = /android|ipad|playbook|silk/i; function i(i) { i || (i = {}); let t = i.ua; if (t || "undefined" == typeof navigator || (t = navigator.userAgent), t && t.headers && "string" == typeof t.headers["user-agent"] && (t = t.headers["user-agent"]), "string" != typeof t) return !1; let a = e.test(t) || !!i.tablet && o.test(t); return !a && i.tablet && i.featureDetect && navigator && navigator.maxTouchPoints > 1 && -1 !== t.indexOf("Macintosh") && -1 !== t.indexOf("Safari") && (a = !0), a }
    }, {}], "Utju": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = l(require("is-mobile")); function l(e) { return e && e.__esModule ? e : { default: e } } var r = { parallaxify: null, cursor: null, isMobile: (0, e.default)({ tablet: !0 }) }; exports.default = r;
    }, { "is-mobile": "BAlE" }], "t3hd": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = c(require("three")), t = u(require("gsap")), i = u(require("@barba/core")), s = require("./utils/utils"), o = u(require("../glsl/bubble-vertex.glsl")), r = u(require("../glsl/bubble-fragment.glsl")), n = u(require("../glsl/bubble-fragment-mobile.glsl")), a = u(require("./constants/colors")), l = u(require("./constants/global")); function u(e) { return e && e.__esModule ? e : { default: e } } function h() { if ("function" != typeof WeakMap) return null; var e = new WeakMap; return h = function () { return e }, e } function c(e) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = h(); if (t && t.has(e)) return t.get(e); var i = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o)) { var r = s ? Object.getOwnPropertyDescriptor(e, o) : null; r && (r.get || r.set) ? Object.defineProperty(i, o, r) : i[o] = e[o] } return i.default = e, t && t.set(e, i), i } function d(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function v(e, t) { for (var i = 0; i < t.length; i++) { var s = t[i]; s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s) } } function m(e, t, i) { return t && v(e.prototype, t), i && v(e, i), e } var f = function () { function u(t, i, l, h, c, v, m) { var f = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], y = !(arguments.length > 8 && void 0 !== arguments[8]) || arguments[8]; d(this, u), s.bindMethods.call(this), this.isInteractive = m, this.isOnlyImageBubble = f, this.hasNavigationOnClick = y, this.scene = i, this.camera = l, this.geometry = h; var p = t.querySelector("[data-image]"), b = m ? p.getAttribute("data-image") || p.getAttribute("src") : null; this.$els = { el: t, title: t.querySelector(".title-holder"), description: t.querySelector(".short-description"), image: b }, this.color1 = a.default[c].color1, this.color2 = a.default[c].color2, this.raycaster = new e.Raycaster, this.scrollTimeout, this.isScrolling, this.isHide = !1, this.initialTime = Number(v).toFixed(1), this.start = Date.now(), this.speed = this.isInteractive ? 3 : 1, this.spikes = this.isInteractive ? 60 : 20, this.division = 16, this.bubbleName = "bubble_".concat(v), this.vertexShader = o.default, this.fragmentShader = r.default, this.mobileFragmentShader = n.default, this.sizes = new e.Vector2(0, 0), this.offset = new e.Vector2(0, 0), this.mouse = new e.Vector2(0, 0), this.raycastMouse = new e.Vector2(1, 1), this.hoverProgress = 0, this.hoverTl, this.unHoverTl, this.texture = null, this.loader = new e.TextureLoader, this.hasNavigationOnClick && (this.linkToGo = this.$els.el.querySelector("[data-link]").getAttribute("data-link")), this.isInteractive ? (this.preload(this.$els.image, this.initBubble), this.bindEvent()) : this.initBubble() } return m(u, [{ key: "bindEvent", value: function () { window.addEventListener("mousemove", this.onMouseMove, !1), window.addEventListener("mousedown", this.onMouseClick, !1), window.addEventListener("scroll", this.onScroll, !1) } }, { key: "removeEvents", value: function () { window.removeEventListener("mousemove", this.onMouseMove, !1), window.removeEventListener("mousedown", this.onMouseClick, !1), window.removeEventListener("scroll", this.onScroll, !1) } }, { key: "onPointerEnter", value: function () { if (this.mesh && !this.isScrolling && !l.default.isMobile && (this.isHovering || (this.isHovering = !0), !this.$els.el.classList.contains("hovered") && this.hasNavigationOnClick)) if (this.$els.el.classList.add("hovered"), this.isOnlyImageBubble) document.body.style.cursor = "pointer", t.default.to(this.$els.el, { scale: 1.1, ease: "expo.inOut" }); else { document.querySelector(".bubbles-cursor").classList.add("open"); var e = this.$els.el.parentElement.classList.contains("right"), i = this.$els.el.parentElement.querySelectorAll(".content p"); this.unHoverTl && this.unHoverTl.kill(), this.hoverTl = t.default.timeline().to(this.material.uniforms.u_hoverProgress, { value: 1, duration: .5 }, 0).to(this.$els.el, { scale: 1.1, ease: "expo.inOut" }, 0).to(this.$els.title, { xPercent: function () { return e ? window.innerWidth < 1300 ? 30 : 60 : window.innerWidth < 1300 ? -30 : -160 }, duration: 1 }, 0).fromTo(i, { y: 30 }, { opacity: 1, y: 0, stagger: .2, duration: .5 }, 0), document.body.style.cursor = "pointer" } } }, { key: "onPointerLeave", value: function () { if (this.mesh && !this.isScrolling && !l.default.isMobile && (this.isHovering && (this.isHovering = !1), this.$els.el.classList.contains("hovered") && this.hasNavigationOnClick)) if (this.$els.el.classList.remove("hovered"), this.isOnlyImageBubble) document.body.style.cursor = "default", t.default.to(this.$els.el, { scale: 1, ease: "expo.inOut" }); else { document.querySelector(".bubbles-cursor").classList.remove("open"); var e = this.$els.el.parentElement.querySelectorAll(".content p"); this.hoverTl && this.hoverTl.kill(), this.unHoverTl = t.default.timeline().to(this.material.uniforms.u_hoverProgress, { value: 0, duration: .2 }, 0).to(this.$els.el, { scale: 1, ease: "expo.inOut" }, 0).to(this.$els.title, { xPercent: function () { return window.innerWidth < 1300 ? 0 : -50 }, duration: 1 }, 0).to(e, { opacity: 0, y: -30, stagger: .2, duration: .5 }, 0).set(e, { y: 30 }), document.body.style.cursor = "default" } } }, { key: "onMouseMove", value: function (e) { if (this.material) { var i = e.clientX / window.innerWidth * 2 - 1, s = -e.clientY / window.innerHeight * 2 + 1; this.raycastMouse.set(i, s), l.default.isMobile || this.isOnlyImageBubble || t.default.to(this.material.uniforms.u_mouse.value, { x: i, y: s, duration: .3 }) } } }, { key: "onMouseClick", value: function (e) { if (this.raycastMouse && this.mesh && this.hasNavigationOnClick) { var t = e.target; this.raycaster.setFromCamera(this.raycastMouse, this.camera); var s = this.raycaster.intersectObject(this.mesh); (t.classList.contains("title") || t.classList.contains("project-item")) && 0 !== s.length && (document.querySelector(".bubbles-cursor").classList.remove("open"), document.body.style.cursor = "default", i.default.go(this.linkToGo)) } } }, { key: "onScroll", value: function () { clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout(this.onScrollStops, 300), this.material && (this.isScrolling = !0) } }, { key: "onScrollStops", value: function () { this.material && (this.isScrolling = !1) } }, { key: "initBubble", value: function () { this.getBounds(); var t = this.isInteractive && l.default.isMobile || this.isOnlyImageBubble, i = this.isInteractive ? this.texture : null; this.uniforms = t ? { u_time: { type: "f", value: this.initialTime }, u_opacity: { type: "f", value: 1 }, u_speed: { value: this.speed }, u_spikes: { value: this.spikes }, u_image: { type: "t", value: i }, u_res: { value: new e.Vector2(window.innerWidth, window.innerHeight) } } : { u_time: { type: "f", value: this.initialTime }, u_opacity: { type: "f", value: 1 }, u_speed: { value: this.speed }, u_spikes: { value: this.spikes }, u_image: { type: "t", value: i }, u_res: { value: new e.Vector2(window.innerWidth, window.innerHeight) }, u_mouse: { value: this.mouse }, u_hoverProgress: { type: "f", value: this.hoverProgress }, color1: { value: new e.Color(this.color1) }, color2: { value: new e.Color(this.color2) } }, this.material = new e.ShaderMaterial({ uniforms: this.uniforms, vertexShader: this.vertexShader, fragmentShader: t ? this.mobileFragmentShader : this.fragmentShader, defines: { PR: window.devicePixelRatio.toFixed(1) }, transparent: !0, opacity: .2, precision: l.default.isMobile ? "highp" : "lowp" }), this.geometry.getAttribute("position").setUsage(e.DynamicDrawUsage), this.mesh = new e.Mesh(this.geometry, this.material), this.mesh.position.set(this.offset.x, this.offset.y), this.mesh.scale.set(this.sizes.x, this.sizes.y, 1), this.mesh.name = this.bubbleName, this.mesh.receiveShadow = !1, this.mesh.castShadow = !1, this.scene.add(this.mesh) } }, { key: "getBounds", value: function () { var t = this.$els.el.getBoundingClientRect(), i = t.width, s = t.height, o = t.left, r = t.top, n = i / this.division, a = s / this.division; this.sizes.equals(new e.Vector2(n, a)) || this.sizes.set(n, a); var l = o - window.innerWidth / 2 + i / 2, u = -r + window.innerHeight / 2 - s / 2; this.offset.equals(new e.Vector2(l, u)) || this.offset.set(l, u) } }, { key: "move", value: function () { this.mesh && (this.getBounds(), t.default.to(this.mesh.position, { duration: .06, x: this.offset.x, y: this.offset.y }), t.default.to(this.mesh.scale, { duration: .06, x: this.sizes.x, y: this.sizes.y }), this.mobileMesh && (t.default.to(this.mobileMesh.position, { duration: .06, x: this.offset.x, y: this.offset.y }), t.default.to(this.mobileMesh.scale, { duration: .06, x: this.sizes.x, y: this.sizes.y }))) } }, { key: "hide", value: function () { var e = this; t.default.to(this.material.uniforms.u_opacity, { value: 0, duration: .5, onComplete: function () { return e.isHide = !0 } }) } }, { key: "show", value: function () { var e = this; t.default.to(this.material.uniforms.u_opacity, { value: 1, duration: .5, onStart: function () { return e.isHide = !1 } }) } }, { key: "preload", value: function (t, i) { var s = this; this.loader.load(t, function (t) { t.center.set(.5, .5), t.wrapS = e.RepeatWrapping, t.wrapT = e.RepeatWrapping, s.texture = t, i() }) } }, { key: "intersect", value: function () { this.raycaster.setFromCamera(this.raycastMouse, this.camera), 0 !== this.raycaster.intersectObject(this.mesh).length ? this.onPointerEnter() : this.onPointerLeave() } }, { key: "update", value: function () { this.mesh && !this.isHide && (this.move(), this.isInteractive && this.intersect(), this.material.uniforms.u_time.value = Date.now() - this.start) } }, { key: "dispose", value: function () { this.removeEvents(); var e = this.scene.getObjectByName(this.mesh.name); this.scene.remove(e), this.mesh = null, this.material.dispose(), this.material = null, this.texture && (this.texture.dispose(), this.texture = null) } }]), u }(); exports.default = f;
    }, { "three": "dKqR", "gsap": "TpQl", "@barba/core": "nGBO", "./utils/utils": "HUaJ", "../glsl/bubble-vertex.glsl": "adZR", "../glsl/bubble-fragment.glsl": "kt78", "../glsl/bubble-fragment-mobile.glsl": "BHmR", "./constants/colors": "U60R", "./constants/global": "Utju" }], "cc6K": [function (require, module, exports) {
        "use strict"; function t(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function e(t, e) { for (var a = 0; a < e.length; a++) { var s = e[a]; s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s) } } function a(t, a, s) { return a && e(t.prototype, a), s && e(t, s), t } Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var s = { lerp: function (t, e, a) { return (1 - a) * t + a * e } }, i = function () { function e() { var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ".bubbles-cursor"; t(this, e), this.el = document.querySelector(a), this.data = { mouse: { x: 0, y: 0 }, current: { x: 0, y: 0 }, last: { x: 0, y: 0 }, ease: .15, dist: 100, fx: { diff: 0, acc: 0, velo: 0, scale: 0 } }, this.rAF = null, this.run = this.run.bind(this), this.mousePos = this.mousePos.bind(this), this.init() } return a(e, [{ key: "mousePos", value: function (t) { this.data.mouse.x = t.pageX, this.data.mouse.y = t.pageY, this.data.current.x = t.pageX, this.data.current.y = t.pageY } }, { key: "run", value: function () { this.data.last.x = s.lerp(this.data.last.x, this.data.current.x, this.data.ease), this.data.last.y = s.lerp(this.data.last.y, this.data.current.y, this.data.ease), this.el.style.transform = "translate3d(".concat(this.data.last.x, "px, ").concat(this.data.last.y, "px, 0)"), this.raf() } }, { key: "raf", value: function () { this.rAF = requestAnimationFrame(this.run) } }, { key: "addListeners", value: function () { window.addEventListener("mousemove", this.mousePos, { passive: !0 }) } }, { key: "init", value: function () { this.addListeners(), this.raf() } }, { key: "destroy", value: function () { window.removeEventListener("mousemove", this.mousePos, { passive: !0 }), cancelAnimationFrame(this.rAF) } }]), e }(), n = i; exports.default = n;
    }, {}], "FcVb": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.magneticItemHover = o; var t = e(require("gsap")); function e(t) { return t && t.__esModule ? t : { default: t } } function o() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ".social", o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .8, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = document.querySelector(e).querySelectorAll(".hovered-visible"); return Array.from(i).forEach(function (e) { var i = !1, r = e.getAttribute("data-offset-hover-max") || .5, a = e.getAttribute("data-offset-hover-min") || .3, u = function (i, r) { t.default.to(e, { x: i * o, y: r * o, opacity: 1, duration: .4, rotation: .05 * i, ease: "power2.out" }), n && t.default.to(e.parentElement.firstElementChild, { opacity: .4, duration: .2 }) }, l = function () { t.default.to(e, { x: 0, y: 0, duration: .7, scale: 1, rotation: 0, ease: "elastic.out(1.2, 0.4)" }), t.default.to(e, { opacity: 0, duration: .2, delay: .7 }), n && t.default.to(e.parentElement.firstElementChild, { opacity: 1, duration: .2 }) }; window.addEventListener("mousemove", function (t) { var o = i ? r : a, n = t.clientX, d = t.clientY, f = e.offsetWidth, c = e.offsetHeight, s = e.getBoundingClientRect(), v = n - (s.left + f / 2), m = d - (s.top + c / 2), h = !1; Math.sqrt(v * v + m * m) < f * o && (h = !0, i || (i = !0), u(v, m)), !h && i && (l(), i = !1) }) }), function () { return window.removeEventListener("mousemove", function () { }) } }
    }, { "gsap": "TpQl" }], "XlP0": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Welcome = void 0; var e = u(require("gsap")), r = require("gsap/ScrollToPlugin"), t = require("gsap/ScrollTrigger"), o = require("gsap/MotionPathPlugin"), i = u(require("pure-parallaxify")), l = require("./utils/utils"), a = u(require("./Bird")), n = u(require("./Bubble")), s = u(require("./Cursor")), d = require("./magnetic"), g = u(require("./constants/global")); function u(e) { return e && e.__esModule ? e : { default: e } } function c(e, r) { if (!(e instanceof r)) throw new TypeError("Cannot call a class as a function") } function p(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } function f(e, r, t) { return r && p(e.prototype, r), t && p(e, t), e } e.default.registerPlugin(t.ScrollTrigger), e.default.registerPlugin(r.ScrollToPlugin), e.default.registerPlugin(o.MotionPathPlugin); var b = function () { function r(e, t, o) { c(this, r), l.bindMethods.call(this), this.stage = e, this.sound = t, this.onFinish = o, this.magneticSkipHover, this.bird = new a.default, this.loadingWrapper = document.querySelector(".loading-wrapper"), this.loadingContent = this.loadingWrapper.querySelector(".loading-content"), this.flyButton = this.loadingWrapper.querySelector(".lets-fly"), this.bubbleMessage = this.loadingWrapper.querySelector(".message-bubble"), this.skipButtonClicked = !1, this.isFirstTimeScrollStopped = !0 } return f(r, [{ key: "init", value: function () { var r = this; e.default.set(this.loadingWrapper, { display: "block" }), g.default.parallaxify || g.default.isMobile || (g.default.parallaxify = new i.default({ positionProperty: "transform" })), g.default.cursor || g.default.isMobile || (g.default.cursor = new s.default, e.default.set(".bubbles-cursor", { opacity: .7 })); var t = document.querySelector(".audio-modal"); e.default.to(t, { opacity: 1, pointerEvents: "all" }), g.default.isMobile || (this.magneticSkipHover = (0, d.magneticItemHover)(".skip-buttons")); var o = document.querySelector(".skip-buttons"); o && (o.addEventListener("mouseenter", function () { return e.default.to(".skip span", { opacity: 1 }) }), o.addEventListener("mouseleave", function () { return e.default.to(".skip span", { opacity: .5 }) }), o.addEventListener("click", function () { r.skipButtonClicked = !0, e.default.to(r.loadingWrapper, { duration: 1.5, scrollTo: r.loadingContent.clientHeight }) })), this.loadinBubblesDom = document.querySelectorAll(".loading-wrapper .loader"), this.stage.bubbles = Array.from(this.loadinBubblesDom).map(function (e, t) { var o = (0, l.getBubbleTypeFromClass)(e.classList); return new n.default(e, r.stage.scene, r.stage.camera, r.stage.geometry, o, t, !1, !1, !1) }), this.handleBubblesAnimation() } }, { key: "handleBubblesAnimation", value: function () { var r = this, o = g.default.isMobile && window.innerWidth < window.innerHeight, i = o ? ".bubbles_path_mobile .left-path" : ".bubbles_path_desktop .left-path", a = o ? ".bubbles_path_mobile .right-path" : ".bubbles_path_desktop .right-path", n = this.stage.bubbles[0], s = this.stage.bubbles[1], d = this.stage.bubbles[2], u = this.stage.bubbles[3]; e.default.fromTo(".loader.ui_ux", { scale: .2 }, { scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "top top", end: "25% top", scrub: 1, fastScrollEnd: !0 }, motionPath: { path: i, align: i, alignOrigin: [.5, .5] }, immediateRender: !0, ease: "power1.inOut" }), e.default.fromTo(".loading-wrapper .feature.welcome", { opacity: 0 }, { opacity: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "top top", end: "4% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loading-wrapper .feature.welcome", { opacity: 1 }, { opacity: 0, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "4% top", end: "7% top", scrub: 1, fastScrollEnd: !0 } }), e.default.set(".loading-wrapper .feature.welcome", { opacity: 0 }), e.default.fromTo(".feature.ui_ux", { opacity: 0 }, { opacity: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "8% top", end: "18% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.ui_ux", { scale: .2 }, { scale: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "top top", end: "18% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.ui_ux", { scale: 1 }, { scale: .1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "18% top", end: "25% top", scrub: 1, fastScrollEnd: !0 } }); var c = e.default.timeline(); t.ScrollTrigger.create({ animation: c, scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "23% top", end: "25% top", scrub: 1, fastScrollEnd: !0 }), c.to(n.material.uniforms.u_opacity, { value: 0 }, 0), c.to(".feature.ui_ux", { opacity: 0 }, 0), c.to(".flying-bird #body_wave", { fill: "#72EDCF" }, 0), c.to([".flying-bird #body", ".flying-bird #tail", ".flying-bird #front_up_wing", ".flying-bird #front_down_wing"], { fill: "#35E5BB" }, 0), c.to([".flying-bird #tip", ".flying-bird #back_up_wing", ".flying-bird #back_down_wing"], { fill: "#2AB796" }, 0), e.default.fromTo(".loader.promo_videos", { scale: .2 }, { scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "25% top", end: "50% top", scrub: 1, fastScrollEnd: !0 }, motionPath: { path: a, align: a, alignOrigin: [.5, .5], start: 1, end: 0 }, immediateRender: !0, ease: "power1.inOut" }), e.default.fromTo(".feature.promo_videos", { opacity: 0 }, { opacity: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "27% top", end: "43% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.promo_videos", { scale: .2 }, { scale: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "25% top", end: "43% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.promo_videos", { scale: 1 }, { scale: .1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "43% top", end: "50% top", scrub: 1, fastScrollEnd: !0 } }); var p = e.default.timeline(); t.ScrollTrigger.create({ animation: p, scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "48% top", end: "50% top", scrub: 1, fastScrollEnd: !0 }), p.to(s.material.uniforms.u_opacity, { value: 0 }, 0), p.to(".feature.promo_videos", { opacity: 0 }, 0), p.to([".flying-bird #back_up_wing", ".flying-bird #back_down_wing"], { fill: "#8E1388" }, 0), p.to([".flying-bird #front_up_wing", ".flying-bird #front_down_wing"], { fill: "#D32FCB" }, 0), e.default.fromTo(".loader.other", { scale: .2 }, { scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "50% top", end: "75% top", scrub: 1, fastScrollEnd: !0 }, motionPath: { path: i, align: i, alignOrigin: [.5, .5] }, immediateRender: !0, ease: "power1.inOut" }), e.default.fromTo(".feature.other", { opacity: 0 }, { opacity: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "52% top", end: "68% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.other", { scale: .2 }, { scale: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "50% top", end: "68% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.other", { scale: 1 }, { scale: .1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "68% top", end: "75% top", scrub: 1, fastScrollEnd: !0 } }); var f = e.default.timeline(); t.ScrollTrigger.create({ animation: f, scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "73% top", end: "75% top", scrub: 1, fastScrollEnd: !0 }), f.to(d.material.uniforms.u_opacity, { value: 0 }, 0), f.to(".feature.other", { opacity: 0 }, 0), f.to(".flying-bird #tip", { fill: "#FD6619" }, 0), e.default.fromTo(".loader.graphic_design", { scale: .2 }, { scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "75% top", end: "bottom bottom", scrub: 1, fastScrollEnd: !0 }, motionPath: { path: a, align: a, alignOrigin: [.5, .5], start: 1, end: 0 }, immediateRender: !0, ease: "power1.inOut" }), e.default.fromTo(".feature.graphic_design", { opacity: 0 }, { opacity: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "77% top", end: "85% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.graphic_design", { scale: .2 }, { scale: 1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "75% top", end: "85% top", scrub: 1, fastScrollEnd: !0 } }), e.default.fromTo(".loader.graphic_design", { scale: 1 }, { scale: .1, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "95% bottom", end: "bottom 100%", scrub: 1, fastScrollEnd: !0 } }); var b = e.default.timeline(); t.ScrollTrigger.create({ animation: b, scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "98% bottom", end: "bottom 100%", scrub: 1, fastScrollEnd: !0 }), b.to(u.material.uniforms.u_opacity, { value: 0 }, 0), b.to(".feature.graphic_design", { opacity: 0 }, 0), b.to(".flying-bird #tail", { fill: "#F81664" }, 0); var m, y = document.querySelector(".loading-wrapper .scroll-down"), h = !1; e.default.to(".loading-content", { opacity: 0, scrollTrigger: { scroller: ".loading-wrapper", trigger: ".loading-wrapper .loading-content", start: "top top", end: "bottom bottom", once: !0, onUpdate: function (e) { var r = 100 * e.progress; r < 100 && (y.classList.remove("not-scrolling"), clearTimeout(m), m = setTimeout(v, 500)), r >= 99 && !h && (clearTimeout(m), T(), h = !0) } } }); var w = y.querySelector("span"), v = function () { if (r.isFirstTimeScrollStopped) { w.textContent = "Keep scrolling", r.isFirstTimeScrollStopped = !1; var e = setTimeout(function () { y.classList.add("not-scrolling"), clearTimeout(e) }, 300) } else y.classList.add("not-scrolling") }, T = function () { r.loadingWrapper.querySelector(".scroll-down").remove(), (0, l.css)(r.loadingContent, "overflow", "hidden"), r.stage.bubbles.forEach(function (e) { return e.hide() }); var t = setTimeout(function () { r.stage.bubbles.forEach(function (e) { return e.dispose() }), clearTimeout(t) }, 550); if (r.sound.isBackgroundSoundPlaying && r.sound.allSoundsToggle(), r.skipButtonClicked) { var o = document.querySelector(".header .signature img"); return e.default.to(r.bird.flyingBird, { width: o.offsetWidth }), r.bird.flying(), e.default.set(r.loadingWrapper, { opacity: 0, pointerEvents: "none", zIndex: -99 }), c.kill(), p.kill(), f.kill(), b.kill(), void r.onFinish() } var i = r.loadingWrapper.querySelector(".feature.final"); e.default.to(i, { opacity: 1, duration: 1, delay: .5 }), e.default.to([r.flyButton, r.bubbleMessage], { opacity: 1, duration: .5, delay: .5, pointerEvents: "all" }), r.flyButton.addEventListener("mouseover", r.flyButtonMouseIn, !1), r.flyButton.addEventListener("mouseleave", r.flyButtonMouseOut, !1), r.flyButton.addEventListener("click", function () { r.flyButton.removeEventListener("mouseover", r.flyButtonMouseIn, !1), r.flyButton.removeEventListener("mouseleave", r.flyButtonMouseOut, !1), r.flyButton.classList.add("clicked"); var t = document.querySelector(".header .signature img"); e.default.to(r.bird.flyingBird, { width: t.offsetWidth }); var o = setTimeout(function () { e.default.to([i, r.flyButton], { opacity: 0, pointerEvents: "none" }), r.togglePageCover(), clearTimeout(o) }, 500) }); var a = r.loadingWrapper.querySelector(".skip"); e.default.to(a, { opacity: 0, onComplete: function () { r.bird.flying(); var e = setTimeout(function () { window.innerWidth < window.innerHeight ? r.bird.positionBird(-50, 50) : r.bird.positionBird(-2.6 * r.bird.flyingBird.offsetWidth, -r.bird.flyingBird.offsetHeight), clearTimeout(e) }, 400) } }), c.kill(), p.kill(), f.kill(), b.kill() } } }, { key: "flyButtonMouseIn", value: function () { this.bird.positionBird(-50, 1.5 * -this.bird.flyingBird.offsetHeight), e.default.to(this.bubbleMessage, { opacity: 0 }) } }, { key: "flyButtonMouseOut", value: function () { this.bird.positionBird(-2.6 * this.bird.flyingBird.offsetWidth, -this.bird.flyingBird.offsetHeight), e.default.to(this.bubbleMessage, { opacity: 1 }) } }, { key: "togglePageCover", value: function () { var r = this, t = document.querySelector(".loading-wrapper .lets-fly-wrapper"), o = t.querySelectorAll(".lets-fly-wrapper .loading-cover"); Array.from(o).forEach(function (e) { return e.classList.add("expanded") }), e.default.to(t, { opacity: 0, pointerEvents: "none", duration: .5, delay: 3, onComplete: function () { e.default.set(r.loadingWrapper, { opacity: 0, pointerEvents: "none", zIndex: -99 }), r.onFinish() } }) } }]), r }(); exports.Welcome = b;
    }, { "gsap": "TpQl", "gsap/ScrollToPlugin": "jhqH", "gsap/ScrollTrigger": "TgBN", "gsap/MotionPathPlugin": "DOrM", "pure-parallaxify": "CgH9", "./utils/utils": "HUaJ", "./Bird": "ygg0", "./Bubble": "t3hd", "./Cursor": "cc6K", "./magnetic": "FcVb", "./constants/global": "Utju" }], "pBGv": [function (require, module, exports) {

        var t, e, n = module.exports = {}; function r() { throw new Error("setTimeout has not been defined") } function o() { throw new Error("clearTimeout has not been defined") } function i(e) { if (t === setTimeout) return setTimeout(e, 0); if ((t === r || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0); try { return t(e, 0) } catch (n) { try { return t.call(null, e, 0) } catch (n) { return t.call(this, e, 0) } } } function u(t) { if (e === clearTimeout) return clearTimeout(t); if ((e === o || !e) && clearTimeout) return e = clearTimeout, clearTimeout(t); try { return e(t) } catch (n) { try { return e.call(null, t) } catch (n) { return e.call(this, t) } } } !function () { try { t = "function" == typeof setTimeout ? setTimeout : r } catch (n) { t = r } try { e = "function" == typeof clearTimeout ? clearTimeout : o } catch (n) { e = o } }(); var c, s = [], l = !1, a = -1; function f() { l && c && (l = !1, c.length ? s = c.concat(s) : a = -1, s.length && h()) } function h() { if (!l) { var t = i(f); l = !0; for (var e = s.length; e;) { for (c = s, s = []; ++a < e;)c && c[a].run(); a = -1, e = s.length } c = null, l = !1, u(t) } } function m(t, e) { this.fun = t, this.array = e } function p() { } n.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; s.push(new m(t, e)), 1 !== s.length || l || i(h) }, m.prototype.run = function () { this.fun.apply(null, this.array) }, n.title = "browser", n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function (t) { return [] }, n.binding = function (t) { throw new Error("process.binding is not supported") }, n.cwd = function () { return "/" }, n.chdir = function (t) { throw new Error("process.chdir is not supported") }, n.umask = function () { return 0 };
    }, {}], "HFPo": [function (require, module, exports) {
        var process = require("process");
        var n = require("process"); !function (n, r, t) { "undefined" != typeof module && module.exports ? module.exports = t() : n.eol = t() }(this, 0, function () { var r = {}, t = void 0 !== n && "win32" === n.platform ? "\r\n" : "\n", e = /\r\n|\r|\n/g; function o(n) { function r(r) { return r.replace(e, n) } return r.toString = function () { return n }, r } return r.lf = o("\n"), r.cr = o("\r"), r.crlf = o("\r\n"), r.auto = o(t), r.before = function (n) { return t + n }, r.after = function (n) { return n + t }, r.split = function (n) { return n.split(e) }, r });
    }, { "process": "pBGv" }], "ez7q": [function (require, module, exports) {
        var global = arguments[3];
        var t = arguments[3]; function e(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function i(t, e) { for (var i = 0; i < e.length; i++) { var s = e[i]; s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s) } } function s(t, e, s) { return e && i(t.prototype, e), s && i(t, s), t } function n(t, e, i) { return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t } function o(t, e) { var i = Object.keys(t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); e && (s = s.filter(function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable })), i.push.apply(i, s) } return i } function l(t) { for (var e = 1; e < arguments.length; e++) { var i = null != arguments[e] ? arguments[e] : {}; e % 2 ? o(Object(i), !0).forEach(function (e) { n(t, e, i[e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : o(Object(i)).forEach(function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)) }) } return t } function r(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && c(t, e) } function a(t) { return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function c(t, e) { return (c = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function h() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (t) { return !1 } } function d(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function u(t, e) { return !e || "object" != typeof e && "function" != typeof e ? d(t) : e } function f(t) { var e = h(); return function () { var i, s = a(t); if (e) { var n = a(this).constructor; i = Reflect.construct(s, arguments, n) } else i = s.apply(this, arguments); return u(this, i) } } function p(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = a(t));); return t } function m(t, e, i) { return (m = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, i) { var s = p(t, e); if (s) { var n = Object.getOwnPropertyDescriptor(s, e); return n.get ? n.get.call(i) : n.value } })(t, e, i || t) } function v(t, e) { return w(t) || x(t, e) || S(t, e) || E() } function y(t) { return b(t) || g(t) || S(t) || T() } function b(t) { if (Array.isArray(t)) return k(t) } function w(t) { if (Array.isArray(t)) return t } function g(t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t) } function x(t, e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) { var i = [], s = !0, n = !1, o = void 0; try { for (var l, r = t[Symbol.iterator](); !(s = (l = r.next()).done) && (i.push(l.value), !e || i.length !== e); s = !0); } catch (a) { n = !0, o = a } finally { try { s || null == r.return || r.return() } finally { if (n) throw o } } return i } } function S(t, e) { if (t) { if ("string" == typeof t) return k(t, e); var i = Object.prototype.toString.call(t).slice(8, -1); return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? k(t, e) : void 0 } } function k(t, e) { (null == e || e > t.length) && (e = t.length); for (var i = 0, s = new Array(e); i < e; i++)s[i] = t[i]; return s } function T() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function E() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Smooth = exports.Native = exports.default = void 0; var A = { el: document, name: "scroll", offset: [0, 0], repeat: !1, smooth: !1, direction: "vertical", gestureDirection: "vertical", reloadOnContextChange: !1, lerp: .1, class: "is-inview", scrollbarContainer: !1, scrollbarClass: "c-scrollbar", scrollingClass: "has-scroll-scrolling", draggingClass: "has-scroll-dragging", smoothClass: "has-scroll-smooth", initClass: "has-scroll-init", getSpeed: !1, getDirection: !1, scrollFromAnywhere: !1, multiplier: 1, firefoxMultiplier: 50, touchMultiplier: 2, resetNativeScroll: !0, tablet: { smooth: !1, direction: "vertical", gestureDirection: "vertical", breakpoint: 1024 }, smartphone: { smooth: !1, direction: "vertical", gestureDirection: "vertical" } }, O = function () { function t() { var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e(this, t), Object.assign(this, A, i), this.smartphone = A.smartphone, i.smartphone && Object.assign(this.smartphone, i.smartphone), this.tablet = A.tablet, i.tablet && Object.assign(this.tablet, i.tablet), this.namespace = "locomotive", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = { x: this.windowWidth / 2, y: this.windowHeight / 2 }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = { scroll: { x: 0, y: 0 }, limit: { x: this.html.offsetHeight, y: this.html.offsetHeight }, currentElements: this.currentElements }, this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", this.isMobile && (this.direction = this[this.context].direction), "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener("resize", this.checkResize, !1) } return s(t, [{ key: "init", value: function () { this.initEvents() } }, { key: "checkScroll", value: function () { this.dispatchScroll() } }, { key: "checkResize", value: function () { var t = this; this.resizeTick || (this.resizeTick = !0, requestAnimationFrame(function () { t.resize(), t.resizeTick = !1 })) } }, { key: "resize", value: function () { } }, { key: "checkContext", value: function () { if (this.reloadOnContextChange) { this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint; var t = this.context; if (this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", t != this.context) ("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload() } } }, { key: "initEvents", value: function () { var t = this; this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]")), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach(function (e) { e.addEventListener("click", t.setScrollTo, !1) }) } }, { key: "setScrollTo", value: function (t) { t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute("data-".concat(this.name, "-href")) || t.currentTarget.getAttribute("href"), { offset: t.currentTarget.getAttribute("data-".concat(this.name, "-offset")) }) } }, { key: "addElements", value: function () { } }, { key: "detectElements", value: function (t) { var e = this, i = this.instance.scroll.y, s = i + this.windowHeight, n = this.instance.scroll.x, o = n + this.windowWidth; Object.entries(this.els).forEach(function (l) { var r = v(l, 2), a = r[0], c = r[1]; if (!c || c.inView && !t || ("horizontal" === e.direction ? o >= c.left && n < c.right && e.setInView(c, a) : s >= c.top && i < c.bottom && e.setInView(c, a)), c && c.inView) if ("horizontal" === e.direction) { var h = c.right - c.left; c.progress = (e.instance.scroll.x - (c.left - e.windowWidth)) / (h + e.windowWidth), (o < c.left || n > c.right) && e.setOutOfView(c, a) } else { var d = c.bottom - c.top; c.progress = (e.instance.scroll.y - (c.top - e.windowHeight)) / (d + e.windowHeight), (s < c.top || i > c.bottom) && e.setOutOfView(c, a) } }), this.hasScrollTicking = !1 } }, { key: "setInView", value: function (t, e) { this.els[e].inView = !0, t.el.classList.add(t.class), this.currentElements[e] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"), t.repeat || (this.els[e].call = !1)) } }, { key: "setOutOfView", value: function (t, e) { var i = this; this.els[e].inView = !1, Object.keys(this.currentElements).forEach(function (t) { t === e && delete i.currentElements[t] }), t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"), t.repeat && t.el.classList.remove(t.class) } }, { key: "dispatchCall", value: function (t, e) { this.callWay = e, this.callValue = t.call.split(",").map(function (t) { return t.trim() }), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]); var i = new Event(this.namespace + "call"); this.el.dispatchEvent(i) } }, { key: "dispatchScroll", value: function () { var t = new Event(this.namespace + "scroll"); this.el.dispatchEvent(t) } }, { key: "setEvents", value: function (t, e) { this.listeners[t] || (this.listeners[t] = []); var i = this.listeners[t]; i.push(e), 1 === i.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), "call" === t && (this.hasCallEventSet = !0, this.detectElements(!0)) } }, { key: "unsetEvents", value: function (t, e) { if (this.listeners[t]) { var i = this.listeners[t], s = i.indexOf(e); s < 0 || (i.splice(s, 1), 0 === i.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1)) } } }, { key: "checkEvent", value: function (t) { var e = this, i = t.type.replace(this.namespace, ""), s = this.listeners[i]; s && 0 !== s.length && s.forEach(function (t) { switch (i) { case "scroll": return t(e.instance); case "call": return t(e.callValue, e.callWay, e.callObj); default: return t() } }) } }, { key: "startScroll", value: function () { } }, { key: "stopScroll", value: function () { } }, { key: "setScroll", value: function (t, e) { this.instance.scroll = { x: 0, y: 0 } } }, { key: "destroy", value: function () { var t = this; window.removeEventListener("resize", this.checkResize, !1), Object.keys(this.listeners).forEach(function (e) { t.el.removeEventListener(t.namespace + e, t.checkEvent, !1) }), this.listeners = {}, this.scrollToEls.forEach(function (e) { e.removeEventListener("click", t.setScrollTo, !1) }), this.html.classList.remove(this.initClass) } }]), t }(), D = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}; function C(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var L = C(function (t, e) { !function () { t.exports = { polyfill: function () { var t = window, e = document; if (!("scrollBehavior" in e.documentElement.style && !0 !== t.__forceSmoothScrollPolyfill__)) { var i, s = t.HTMLElement || t.Element, n = 468, o = { scroll: t.scroll || t.scrollTo, scrollBy: t.scrollBy, elementScroll: s.prototype.scroll || a, scrollIntoView: s.prototype.scrollIntoView }, l = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now, r = (i = t.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(i) ? 1 : 0); t.scroll = t.scrollTo = function () { void 0 !== arguments[0] && (!0 !== c(arguments[0]) ? p.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : o.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset)) }, t.scrollBy = function () { void 0 !== arguments[0] && (c(arguments[0]) ? o.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : p.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset))) }, s.prototype.scroll = s.prototype.scrollTo = function () { if (void 0 !== arguments[0]) if (!0 !== c(arguments[0])) { var t = arguments[0].left, e = arguments[0].top; p.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e) } else { if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted"); o.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop) } }, s.prototype.scrollBy = function () { void 0 !== arguments[0] && (!0 !== c(arguments[0]) ? this.scroll({ left: ~~arguments[0].left + this.scrollLeft, top: ~~arguments[0].top + this.scrollTop, behavior: arguments[0].behavior }) : o.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop)) }, s.prototype.scrollIntoView = function () { if (!0 !== c(arguments[0])) { var i = function (t) { for (; t !== e.body && !1 === u(t);)t = t.parentNode || t.host; return t }(this), s = i.getBoundingClientRect(), n = this.getBoundingClientRect(); i !== e.body ? (p.call(this, i, i.scrollLeft + n.left - s.left, i.scrollTop + n.top - s.top), "fixed" !== t.getComputedStyle(i).position && t.scrollBy({ left: s.left, top: s.top, behavior: "smooth" })) : t.scrollBy({ left: n.left, top: n.top, behavior: "smooth" }) } else o.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0]) } } function a(t, e) { this.scrollLeft = t, this.scrollTop = e } function c(t) { if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0; if ("object" == typeof t && "smooth" === t.behavior) return !1; throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.") } function h(t, e) { return "Y" === e ? t.clientHeight + r < t.scrollHeight : "X" === e ? t.clientWidth + r < t.scrollWidth : void 0 } function d(e, i) { var s = t.getComputedStyle(e, null)["overflow" + i]; return "auto" === s || "scroll" === s } function u(t) { var e = h(t, "Y") && d(t, "Y"), i = h(t, "X") && d(t, "X"); return e || i } function f(e) { var i, s, o, r, a = (l() - e.startTime) / n; r = a = a > 1 ? 1 : a, i = .5 * (1 - Math.cos(Math.PI * r)), s = e.startX + (e.x - e.startX) * i, o = e.startY + (e.y - e.startY) * i, e.method.call(e.scrollable, s, o), s === e.x && o === e.y || t.requestAnimationFrame(f.bind(t, e)) } function p(i, s, n) { var r, c, h, d, u = l(); i === e.body ? (r = t, c = t.scrollX || t.pageXOffset, h = t.scrollY || t.pageYOffset, d = o.scroll) : (r = i, c = i.scrollLeft, h = i.scrollTop, d = a), f({ scrollable: r, method: d, startTime: u, startX: c, startY: h, x: s, y: n }) } } } }() }), M = L.polyfill, j = function (t) { r(n, t); var i = f(n); function n() { var t, s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e(this, n), (t = i.call(this, s)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0)), window.addEventListener("scroll", t.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = L, window.smoothscrollPolyfill.polyfill()), t } return s(n, [{ key: "init", value: function () { this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), m(a(n.prototype), "init", this).call(this) } }, { key: "checkScroll", value: function () { var t = this; m(a(n.prototype), "checkScroll", this).call(this), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame(function () { t.detectElements() }), this.hasScrollTicking = !0)) } }, { key: "addDirection", value: function () { window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up") } }, { key: "addSpeed", value: function () { window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0 } }, { key: "resize", value: function () { Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements()) } }, { key: "addElements", value: function () { var t = this; this.els = {}, this.el.querySelectorAll("[data-" + this.name + "]").forEach(function (e, i) { e.getBoundingClientRect(); var s, n, o, l = e.dataset[t.name + "Class"] || t.class, r = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : i, a = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset, c = e.dataset[t.name + "Repeat"], h = e.dataset[t.name + "Call"], d = e.dataset[t.name + "Target"], u = (o = void 0 !== d ? document.querySelector("".concat(d)) : e).getBoundingClientRect(); s = u.top + t.instance.scroll.y, n = u.left + t.instance.scroll.x; var f = s + o.offsetHeight, p = n + o.offsetWidth; "#header" === d && console.log(s, f), c = "false" != c && (null != c || t.repeat); var m = t.getRelativeOffset(a), v = { el: e, targetEl: o, id: r, class: l, top: s += m[0], bottom: f -= m[1], left: n, right: p, offset: a, progress: 0, repeat: c, inView: !1, call: h }; t.els[r] = v, e.classList.contains(l) && t.setInView(t.els[r], r) }) } }, { key: "updateElements", value: function () { var t = this; Object.entries(this.els).forEach(function (e) { var i = v(e, 2), s = i[0], n = i[1], o = n.targetEl.getBoundingClientRect().top + t.instance.scroll.y, l = o + n.targetEl.offsetHeight, r = t.getRelativeOffset(n.offset); t.els[s].top = o + r[0], t.els[s].bottom = l - r[1] }), this.hasScrollTicking = !1 } }, { key: "getRelativeOffset", value: function (t) { var e = [0, 0]; if (t) for (var i = 0; i < t.length; i++)"string" == typeof t[i] ? t[i].includes("%") ? e[i] = parseInt(t[i].replace("%", "") * this.windowHeight / 100) : e[i] = parseInt(t[i]) : e[i] = t[i]; return e } }, { key: "scrollTo", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = parseInt(e.offset) || 0, s = !!e.callback && e.callback; if ("string" == typeof t) { if ("top" === t) t = this.html; else if ("bottom" === t) t = this.html.offsetHeight - window.innerHeight; else if (!(t = document.querySelector(t))) return } else if ("number" == typeof t) t = parseInt(t); else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid"); if (i = "number" != typeof t ? t.getBoundingClientRect().top + i + this.instance.scroll.y : t + i, s) { i = i.toFixed(); window.addEventListener("scroll", function t() { window.pageYOffset.toFixed() === i && (window.removeEventListener("scroll", t), s()) }) } window.scrollTo({ top: i, behavior: "smooth" }) } }, { key: "update", value: function () { this.addElements(), this.detectElements() } }, { key: "destroy", value: function () { m(a(n.prototype), "destroy", this).call(this), window.removeEventListener("scroll", this.checkScroll, !1) } }]), n }(O), W = Object.getOwnPropertySymbols, B = Object.prototype.hasOwnProperty, _ = Object.prototype.propertyIsEnumerable; function H(t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function P() { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, i = 0; i < 10; i++)e["_" + String.fromCharCode(i)] = i; if ("0123456789" !== Object.getOwnPropertyNames(e).map(function (t) { return e[t] }).join("")) return !1; var s = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { s[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, s)).join("") } catch (n) { return !1 } } var R = P() ? Object.assign : function (t, e) { for (var i, s, n = H(t), o = 1; o < arguments.length; o++) { for (var l in i = Object(arguments[o])) B.call(i, l) && (n[l] = i[l]); if (W) { s = W(i); for (var r = 0; r < s.length; r++)_.call(i, s[r]) && (n[s[r]] = i[s[r]]) } } return n }; function Y() { } Y.prototype = { on: function (t, e, i) { var s = this.e || (this.e = {}); return (s[t] || (s[t] = [])).push({ fn: e, ctx: i }), this }, once: function (t, e, i) { var s = this; function n() { s.off(t, n), e.apply(i, arguments) } return n._ = e, this.on(t, n, i) }, emit: function (t) { for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), s = 0, n = i.length; s < n; s++)i[s].fn.apply(i[s].ctx, e); return this }, off: function (t, e) { var i = this.e || (this.e = {}), s = i[t], n = []; if (s && e) for (var o = 0, l = s.length; o < l; o++)s[o].fn !== e && s[o].fn._ !== e && n.push(s[o]); return n.length ? i[t] = n : delete i[t], this } }; var I = Y, z = C(function (t, e) { (function () { (null !== e ? e : this).Lethargy = function () { function t(t, e, i, s) { this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != i ? 1 + Math.abs(i) : 1.1, this.delay = null != s ? s : 150, this.lastUpDeltas = function () { var t, e, i; for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)i.push(null); return i }.call(this), this.lastDownDeltas = function () { var t, e, i; for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)i.push(null); return i }.call(this), this.deltasTimestamp = function () { var t, e, i; for (i = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)i.push(null); return i }.call(this) } return t.prototype.check = function (t) { var e; return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1)) }, t.prototype.isInertia = function (t) { var e, i, s, n, o, l, r; return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (s = e.slice(0, this.stability), i = e.slice(this.stability, 2 * this.stability), r = s.reduce(function (t, e) { return t + e }), o = i.reduce(function (t, e) { return t + e }), l = r / s.length, n = o / i.length, Math.abs(l) < Math.abs(n * this.tolerance) && this.sensitivity < Math.abs(n) && t) }, t.prototype.showLastUpDeltas = function () { return this.lastUpDeltas }, t.prototype.showLastDownDeltas = function () { return this.lastDownDeltas }, t }() }).call(D) }), X = { hasWheelEvent: "onwheel" in document, hasMouseWheelEvent: "onmousewheel" in document, hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch, hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1, hasPointer: !!window.navigator.msPointerEnabled, hasKeyDown: "onkeydown" in document, isFirefox: navigator.userAgent.indexOf("Firefox") > -1 }, V = Object.prototype.toString, F = Object.prototype.hasOwnProperty, q = function (t) { if (!t) return console.warn("bindAll requires at least one argument."); var e = Array.prototype.slice.call(arguments, 1); if (0 === e.length) for (var i in t) F.call(t, i) && "function" == typeof t[i] && "[object Function]" == V.call(t[i]) && e.push(i); for (var s = 0; s < e.length; s++) { var n = e[s]; t[n] = K(t[n], t) } }; function K(t, e) { return function () { return t.apply(e, arguments) } } var N = z.Lethargy, U = "virtualscroll", G = J, $ = { LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, SPACE: 32 }; function J(t) { q(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = R({ mouseMultiplier: 1, touchMultiplier: 2, firefoxMultiplier: 15, keyStep: 120, preventTouch: !1, unpreventTouchClass: "vs-touchmove-allowed", limitInertia: !1, useKeyboard: !0, useTouch: !0 }, t), this.options.limitInertia && (this._lethargy = new N), this._emitter = new I, this._event = { y: 0, x: 0, deltaX: 0, deltaY: 0 }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = { passive: this.options.passive }) } function Q(t, e, i) { return (1 - i) * t + i * e } function Z(t) { var e = {}; if (window.getComputedStyle) { var i = getComputedStyle(t), s = i.transform || i.webkitTransform || i.mozTransform, n = s.match(/^matrix3d\((.+)\)$/); return n ? (e.x = n ? parseFloat(n[1].split(", ")[12]) : 0, e.y = n ? parseFloat(n[1].split(", ")[13]) : 0) : (n = s.match(/^matrix\((.+)\)$/), e.x = n ? parseFloat(n[1].split(", ")[4]) : 0, e.y = n ? parseFloat(n[1].split(", ")[5]) : 0), e } } function tt(t) { for (var e = []; t && t !== document; t = t.parentNode)e.push(t); return e } J.prototype._notify = function (t) { var e = this._event; e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(U, { x: e.x, y: e.y, deltaX: e.deltaX, deltaY: e.deltaY, originalEvent: t }) }, J.prototype._onWheel = function (t) { var e = this.options; if (!this._lethargy || !1 !== this._lethargy.check(t)) { var i = this._event; i.deltaX = t.wheelDeltaX || -1 * t.deltaX, i.deltaY = t.wheelDeltaY || -1 * t.deltaY, X.isFirefox && 1 == t.deltaMode && (i.deltaX *= e.firefoxMultiplier, i.deltaY *= e.firefoxMultiplier), i.deltaX *= e.mouseMultiplier, i.deltaY *= e.mouseMultiplier, this._notify(t) } }, J.prototype._onMouseWheel = function (t) { if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) { var e = this._event; e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t) } }, J.prototype._onTouchStart = function (t) { var e = t.targetTouches ? t.targetTouches[0] : t; this.touchStartX = e.pageX, this.touchStartY = e.pageY }, J.prototype._onTouchMove = function (t) { var e = this.options; e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault(); var i = this._event, s = t.targetTouches ? t.targetTouches[0] : t; i.deltaX = (s.pageX - this.touchStartX) * e.touchMultiplier, i.deltaY = (s.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = s.pageX, this.touchStartY = s.pageY, this._notify(t) }, J.prototype._onKeyDown = function (t) { var e = this._event; e.deltaX = e.deltaY = 0; var i = window.innerHeight - 40; switch (t.keyCode) { case $.LEFT: case $.UP: e.deltaY = this.options.keyStep; break; case $.RIGHT: case $.DOWN: e.deltaY = -this.options.keyStep; break; case t.shiftKey: e.deltaY = i; break; case $.SPACE: e.deltaY = -i; break; default: return }this._notify(t) }, J.prototype._bind = function () { X.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions), X.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), X.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions), this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), X.hasPointer && X.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", this.el.addEventListener("MSPointerDown", this._onTouchStart, !0), this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)), X.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown) }, J.prototype._unbind = function () { X.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel), X.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel), X.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart), this.el.removeEventListener("touchmove", this._onTouchMove)), X.hasPointer && X.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0), this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)), X.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown) }, J.prototype.on = function (t, e) { this._emitter.on(U, t, e); var i = this._emitter.e; i && i[U] && 1 === i[U].length && this._bind() }, J.prototype.off = function (t, e) { this._emitter.off(U, t, e); var i = this._emitter.e; (!i[U] || i[U].length <= 0) && this._unbind() }, J.prototype.reset = function () { var t = this._event; t.x = 0, t.y = 0 }, J.prototype.destroy = function () { this._emitter.off(), this._unbind() }; var et = 4, it = .001, st = 1e-7, nt = 10, ot = 11, lt = 1 / (ot - 1), rt = "function" == typeof Float32Array; function at(t, e) { return 1 - 3 * e + 3 * t } function ct(t, e) { return 3 * e - 6 * t } function ht(t) { return 3 * t } function dt(t, e, i) { return ((at(e, i) * t + ct(e, i)) * t + ht(e)) * t } function ut(t, e, i) { return 3 * at(e, i) * t * t + 2 * ct(e, i) * t + ht(e) } function ft(t, e, i, s, n) { var o, l, r = 0; do { (o = dt(l = e + (i - e) / 2, s, n) - t) > 0 ? i = l : e = l } while (Math.abs(o) > st && ++r < nt); return l } function pt(t, e, i, s) { for (var n = 0; n < et; ++n) { var o = ut(e, i, s); if (0 === o) return e; e -= (dt(e, i, s) - t) / o } return e } function mt(t) { return t } var vt = function (t, e, i, s) { if (!(0 <= t && t <= 1 && 0 <= i && i <= 1)) throw new Error("bezier x values must be in [0, 1] range"); if (t === e && i === s) return mt; for (var n = rt ? new Float32Array(ot) : new Array(ot), o = 0; o < ot; ++o)n[o] = dt(o * lt, t, i); return function (o) { return 0 === o ? 0 : 1 === o ? 1 : dt(function (e) { for (var s = 0, o = 1, l = ot - 1; o !== l && n[o] <= e; ++o)s += lt; var r = s + (e - n[--o]) / (n[o + 1] - n[o]) * lt, a = ut(r, t, i); return a >= it ? pt(e, r, t, i) : 0 === a ? r : ft(e, s, s + lt, t, i) }(o), e, s) } }, yt = { LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, SPACE: 32, TAB: 9, PAGEUP: 33, PAGEDOWN: 34, HOME: 36, END: 35 }, bt = function (t) { r(n, t); var i = f(n); function n() { var t, s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e(this, n), history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0), (t = i.call(this, s)).inertia && (t.lerp = .1 * t.inertia), t.isScrolling = !1, t.isDraggingScrollbar = !1, t.isTicking = !1, t.hasScrollTicking = !1, t.parallaxElements = {}, t.stop = !1, t.scrollbarContainer = s.scrollbarContainer, t.checkKey = t.checkKey.bind(d(t)), window.addEventListener("keydown", t.checkKey, !1), t } return s(n, [{ key: "init", value: function () { var t = this; this.html.classList.add(this.smoothClass), this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction), this.instance = l({ delta: { x: 0, y: 0 } }, this.instance), this.vs = new G({ el: this.scrollFromAnywhere ? document : this.el, mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4, firefoxMultiplier: this.firefoxMultiplier, touchMultiplier: this.touchMultiplier, useKeyboard: !1, passive: !0 }), this.vs.on(function (e) { t.stop || t.isDraggingScrollbar || requestAnimationFrame(function () { t.updateDelta(e), t.isScrolling || t.startScrolling() }) }), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), m(a(n.prototype), "init", this).call(this) } }, { key: "setScrollLimit", value: function () { if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, "horizontal" === this.direction) { for (var t = 0, e = this.el.children, i = 0; i < e.length; i++)t += e[i].offsetWidth; this.instance.limit.x = t - this.windowWidth } } }, { key: "startScrolling", value: function () { this.startScrollTs = Date.now(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass) } }, { key: "stopScrolling", value: function () { cancelAnimationFrame(this.checkScrollRaf), this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass) } }, { key: "checkKey", value: function (t) { var e = this; if (this.stop) t.keyCode == yt.TAB && requestAnimationFrame(function () { e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0 }); else { switch (t.keyCode) { case yt.TAB: requestAnimationFrame(function () { e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0, e.scrollTo(document.activeElement, { offset: -window.innerHeight / 2 }) }); break; case yt.UP: this.instance.delta[this.directionAxis] -= 240; break; case yt.DOWN: this.instance.delta[this.directionAxis] += 240; break; case yt.PAGEUP: this.instance.delta[this.directionAxis] -= window.innerHeight; break; case yt.PAGEDOWN: this.instance.delta[this.directionAxis] += window.innerHeight; break; case yt.HOME: this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis]; break; case yt.END: this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis]; break; case yt.SPACE: document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight); break; default: return }this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass) } } }, { key: "checkScroll", value: function () { var t = this; if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0] || this.isScrolling || this.isDraggingScrollbar) { this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame(function () { return t.checkScroll() }), this.hasScrollTicking = !0), this.updateScroll(); var e = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]), i = Date.now() - this.startScrollTs; if (!this.animatingScroll && i > 100 && (e < .5 && 0 != this.instance.delta[this.directionAxis] || e < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach(function (e) { var i = v(e, 2), s = (i[0], i[1]); s.persistent || t.instance.scroll[t.directionAxis] > s.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < s.limit[t.directionAxis] ? ("horizontal" === t.direction ? t.transform(s.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(s.el, 0, -t.instance.scroll[t.directionAxis]), s.inView || (s.inView = !0, s.el.style.opacity = 1, s.el.style.pointerEvents = "all", s.el.setAttribute("data-".concat(t.name, "-section-inview"), ""))) : (s.inView && (s.inView = !1, s.el.style.opacity = 0, s.el.style.pointerEvents = "none", s.el.removeAttribute("data-".concat(t.name, "-section-inview"))), t.transform(s.el, 0, 0)) }), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) { var s = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis]; "horizontal" === this.direction ? this.transform(this.scrollbarThumb, s, 0) : this.transform(this.scrollbarThumb, 0, s) } m(a(n.prototype), "checkScroll", this).call(this), this.hasScrollTicking = !1 } } }, { key: "resize", value: function () { this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = { x: this.windowWidth / 2, y: this.windowHeight / 2 }, this.update() } }, { key: "updateDelta", value: function (t) { var e, i = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection; e = "both" === i ? t.deltaX + t.deltaY : "vertical" === i ? t.deltaY : "horizontal" === i ? t.deltaX : t.deltaY, this.instance.delta[this.directionAxis] -= e * this.multiplier, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]) } }, { key: "updateScroll", value: function (t) { this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = Q(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis]) } }, { key: "addDirection", value: function () { this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"), this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left") } }, { key: "addSpeed", value: function () { this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0 } }, { key: "initScrollBar", value: function () { if (this.scrollbar = document.createElement("span"), this.scrollbarThumb = document.createElement("span"), this.scrollbar.classList.add("".concat(this.scrollbarClass)), this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb")), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar), window.addEventListener("mouseup", this.releaseScrollBar), window.addEventListener("mousemove", this.moveScrollBar), this.hasScrollbar = !1, "horizontal" == this.direction) { if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return; this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = { x: this.scrollbarWidth - this.scrollbarThumbBCR.width, y: this.scrollbarHeight - this.scrollbarThumbBCR.height } } }, { key: "reinitScrollBar", value: function () { if (this.hasScrollbar = !1, "horizontal" == this.direction) { if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return; this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = { x: this.scrollbarWidth - this.scrollbarThumbBCR.width, y: this.scrollbarHeight - this.scrollbarThumbBCR.height } } }, { key: "destroyScrollBar", value: function () { this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar), window.removeEventListener("mouseup", this.releaseScrollBar), window.removeEventListener("mousemove", this.moveScrollBar), this.scrollbar.remove() } }, { key: "getScrollBar", value: function (t) { this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass) } }, { key: "releaseScrollBar", value: function (t) { this.isDraggingScrollbar = !1, this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass) } }, { key: "moveScrollBar", value: function (t) { var e = this; this.isDraggingScrollbar && requestAnimationFrame(function () { var i = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100, s = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100; s > 0 && s < e.instance.limit.y && (e.instance.delta.y = s), i > 0 && i < e.instance.limit.x && (e.instance.delta.x = i) }) } }, { key: "addElements", value: function () { var t = this; this.els = {}, this.parallaxElements = {}, this.el.querySelectorAll("[data-".concat(this.name, "]")).forEach(function (e, i) { var s, n, o, l = tt(e), r = Object.entries(t.sections).map(function (t) { var e = v(t, 2); e[0]; return e[1] }).find(function (t) { return l.includes(t.el) }), a = e.dataset[t.name + "Class"] || t.class, c = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "el" + i, h = e.dataset[t.name + "Repeat"], d = e.dataset[t.name + "Call"], u = e.dataset[t.name + "Position"], f = e.dataset[t.name + "Delay"], p = e.dataset[t.name + "Direction"], m = "string" == typeof e.dataset[t.name + "Sticky"], y = !!e.dataset[t.name + "Speed"] && parseFloat(e.dataset[t.name + "Speed"]) / 10, b = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset, w = e.dataset[t.name + "Target"], g = (o = void 0 !== w ? document.querySelector("".concat(w)) : e).getBoundingClientRect(); null === r ? (s = g.top + t.instance.scroll.y - Z(o).y, n = g.left + t.instance.scroll.x - Z(o).x) : r.inView ? (s = g.top + t.instance.scroll.y - Z(o).y, n = g.left + t.instance.scroll.x - Z(o).x) : (s = g.top - Z(r.el).y - Z(o).y, n = g.left - Z(r.el).x - Z(o).x); var x = s + o.offsetHeight, S = n + o.offsetWidth, k = { x: (S - n) / 2 + n, y: (x - s) / 2 + s }; if (m) { var T = e.getBoundingClientRect(), E = T.top, A = T.left, O = { x: A - n, y: E - s }; s += window.innerHeight, n += window.innerWidth, x = E + o.offsetHeight - e.offsetHeight - O[t.directionAxis], k = { x: ((S = A + o.offsetWidth - e.offsetWidth - O[t.directionAxis]) - n) / 2 + n, y: (x - s) / 2 + s } } h = "false" != h && (null != h || t.repeat); var D = [0, 0]; if (b) if ("horizontal" === t.direction) { for (var C = 0; C < b.length; C++)"string" == typeof b[C] ? b[C].includes("%") ? D[C] = parseInt(b[C].replace("%", "") * t.windowWidth / 100) : D[C] = parseInt(b[C]) : D[C] = b[C]; n += D[0], S -= D[1] } else { for (C = 0; C < b.length; C++)"string" == typeof b[C] ? b[C].includes("%") ? D[C] = parseInt(b[C].replace("%", "") * t.windowHeight / 100) : D[C] = parseInt(b[C]) : D[C] = b[C]; s += D[0], x -= D[1] } var L = { el: e, id: c, class: a, section: r, top: s, middle: k, bottom: x, left: n, right: S, offset: b, progress: 0, repeat: h, inView: !1, call: d, speed: y, delay: f, position: u, target: o, direction: p, sticky: m }; t.els[c] = L, e.classList.contains(a) && t.setInView(t.els[c], c), (!1 !== y || m) && (t.parallaxElements[c] = L) }) } }, { key: "addSections", value: function () { var t = this; this.sections = {}; var e = this.el.querySelectorAll("[data-".concat(this.name, "-section]")); 0 === e.length && (e = [this.el]), e.forEach(function (e, i) { var s = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "section" + i, n = e.getBoundingClientRect(), o = { x: n.left - 1.5 * window.innerWidth - Z(e).x, y: n.top - 1.5 * window.innerHeight - Z(e).y }, l = { x: o.x + n.width + 2 * window.innerWidth, y: o.y + n.height + 2 * window.innerHeight }, r = "string" == typeof e.dataset[t.name + "Persistent"]; e.setAttribute("data-scroll-section-id", s); var a = { el: e, offset: o, limit: l, inView: !1, persistent: r, id: s }; t.sections[s] = a }) } }, { key: "transform", value: function (t, e, i, s) { var n; if (s) { var o = Z(t), l = Q(o.x, e, s), r = Q(o.y, i, s); n = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(l, ",").concat(r, ",0,1)") } else n = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(e, ",").concat(i, ",0,1)"); t.style.webkitTransform = n, t.style.msTransform = n, t.style.transform = n } }, { key: "transformElements", value: function (t) { var e = this, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s = this.instance.scroll.x + this.windowWidth, n = this.instance.scroll.y + this.windowHeight, o = { x: this.instance.scroll.x + this.windowMiddle.x, y: this.instance.scroll.y + this.windowMiddle.y }; Object.entries(this.parallaxElements).forEach(function (l) { var r = v(l, 2), a = (r[0], r[1]), c = !1; if (t && (c = 0), a.inView || i) switch (a.position) { case "top": c = e.instance.scroll[e.directionAxis] * -a.speed; break; case "elementTop": c = (n - a.top) * -a.speed; break; case "bottom": c = (e.instance.limit[e.directionAxis] - n + e.windowHeight) * a.speed; break; case "left": c = e.instance.scroll[e.directionAxis] * -a.speed; break; case "elementLeft": c = (s - a.left) * -a.speed; break; case "right": c = (e.instance.limit[e.directionAxis] - s + e.windowHeight) * a.speed; break; default: c = (o[e.directionAxis] - a.middle[e.directionAxis]) * -a.speed }a.sticky && (c = a.inView ? "horizontal" === e.direction ? e.instance.scroll.x - a.left + window.innerWidth : e.instance.scroll.y - a.top + window.innerHeight : "horizontal" === e.direction ? e.instance.scroll.x < a.left - window.innerWidth && e.instance.scroll.x < a.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > a.right && e.instance.scroll.x > a.right + 100 && a.right - a.left + window.innerWidth : e.instance.scroll.y < a.top - window.innerHeight && e.instance.scroll.y < a.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > a.bottom && e.instance.scroll.y > a.bottom + 100 && a.bottom - a.top + window.innerHeight), !1 !== c && ("horizontal" === a.direction || "horizontal" === e.direction && "vertical" !== a.direction ? e.transform(a.el, c, 0, !t && a.delay) : e.transform(a.el, 0, c, !t && a.delay)) }) } }, { key: "scrollTo", value: function (t) { var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s = parseInt(i.offset) || 0, n = i.duration || 1e3, o = i.easing || [.25, 0, .35, 1], l = !!i.disableLerp, r = !!i.callback && i.callback; if (o = vt.apply(void 0, y(o)), "string" == typeof t) { if ("top" === t) t = 0; else if ("bottom" === t) t = this.instance.limit.y; else if ("left" === t) t = 0; else if ("right" === t) t = this.instance.limit.x; else if (!(t = document.querySelector(t))) return } else if ("number" == typeof t) t = parseInt(t); else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid"); if ("number" != typeof t) { if (!tt(t).includes(this.el)) return; var a = t.getBoundingClientRect(), c = a.top, h = a.left, d = tt(t).find(function (t) { return Object.entries(e.sections).map(function (t) { var e = v(t, 2); e[0]; return e[1] }).find(function (e) { return e.el == t }) }), u = 0; u = d ? Z(d)[this.directionAxis] : -this.instance.scroll[this.directionAxis], s = "horizontal" === this.direction ? h + s - u : c + s - u } else s = t + s; var f = parseFloat(this.instance.delta[this.directionAxis]), p = Math.max(0, Math.min(s, this.instance.limit[this.directionAxis])) - f, m = function (t) { l ? "horizontal" === e.direction ? e.setScroll(f + p * t, e.instance.delta.y) : e.setScroll(e.instance.delta.x, f + p * t) : e.instance.delta[e.directionAxis] = f + p * t }; this.animatingScroll = !0, this.stopScrolling(), this.startScrolling(); var b = Date.now(); !function t() { var i = (Date.now() - b) / n; i > 1 ? (m(1), e.animatingScroll = !1, 0 == n && e.update(), r && r()) : (e.scrollToRaf = requestAnimationFrame(t), m(o(i))) }() } }, { key: "update", value: function () { this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0) } }, { key: "startScroll", value: function () { this.stop = !1 } }, { key: "stopScroll", value: function () { this.stop = !0 } }, { key: "setScroll", value: function (t, e) { this.instance = l(l({}, this.instance), {}, { scroll: { x: t, y: e }, delta: { x: t, y: e }, speed: 0 }) } }, { key: "destroy", value: function () { m(a(n.prototype), "destroy", this).call(this), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener("keydown", this.checkKey, !1) } }]), n }(O), wt = function () { function t() { var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e(this, t), this.options = i, Object.assign(this, A, i), this.smartphone = A.smartphone, i.smartphone && Object.assign(this.smartphone, i.smartphone), this.tablet = A.tablet, i.tablet && Object.assign(this.tablet, i.tablet), this.smooth || "horizontal" != this.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible"), this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)"), this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"), this.init() } return s(t, [{ key: "init", value: function () { if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new bt(this.options) : this.scroll = new j(this.options), this.scroll.init(), window.location.hash) { var t = window.location.hash.slice(1, window.location.hash.length), e = document.getElementById(t); e && this.scroll.scrollTo(e) } } }, { key: "update", value: function () { this.scroll.update() } }, { key: "start", value: function () { this.scroll.startScroll() } }, { key: "stop", value: function () { this.scroll.stopScroll() } }, { key: "scrollTo", value: function (t, e) { this.scroll.scrollTo(t, e) } }, { key: "setScroll", value: function (t, e) { this.scroll.setScroll(t, e) } }, { key: "on", value: function (t, e) { this.scroll.setEvents(t, e) } }, { key: "off", value: function (t, e) { this.scroll.unsetEvents(t, e) } }, { key: "destroy", value: function () { this.scroll.destroy() } }]), t }(); exports.Smooth = wt; var gt = function () { function t() { var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; e(this, t), this.options = i, Object.assign(this, A, i), this.smartphone = A.smartphone, i.smartphone && Object.assign(this.smartphone, i.smartphone), this.tablet = A.tablet, i.tablet && Object.assign(this.tablet, i.tablet), this.init() } return s(t, [{ key: "init", value: function () { if (this.scroll = new j(this.options), this.scroll.init(), window.location.hash) { var t = window.location.hash.slice(1, window.location.hash.length), e = document.getElementById(t); e && this.scroll.scrollTo(e) } } }, { key: "update", value: function () { this.scroll.update() } }, { key: "start", value: function () { this.scroll.startScroll() } }, { key: "stop", value: function () { this.scroll.stopScroll() } }, { key: "scrollTo", value: function (t, e) { this.scroll.scrollTo(t, e) } }, { key: "setScroll", value: function (t, e) { this.scroll.setScroll(t, e) } }, { key: "on", value: function (t, e) { this.scroll.setEvents(t, e) } }, { key: "off", value: function (t, e) { this.scroll.unsetEvents(t, e) } }, { key: "destroy", value: function () { this.scroll.destroy() } }]), t }(); exports.Native = gt; var xt = wt; exports.default = xt;
    }, {}], "bxmL": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.EasePack = exports.RoughEase = exports.ExpoScaleEase = exports.SlowMo = void 0; var e, r, t, n = function () { return e || "undefined" != typeof window && (e = window.gsap) && e.registerPlugin && e }, o = function (e, r) { return !!(void 0 === e ? r : e && !~(e + "").indexOf("false")) }, a = function (o) { if (e = o || n()) { t = e.registerEase; var a, s = e.parseEase(), i = function (e) { return function (r) { var t = .5 + r / 2; e.config = function (r) { return e(2 * (1 - r) * r * t + r * r) } } }; for (a in s) s[a].config || i(s[a]); for (a in t("slow", p), t("expoScale", c), t("rough", x), v) "version" !== a && e.core.globals(a, v[a]); r = 1 } }, s = function (e, r, t) { var n = (e = Math.min(1, e || .7)) < 1 ? r || 0 === r ? r : .7 : 0, a = (1 - e) / 2, s = a + e, i = o(t); return function (e) { var r = e + (.5 - e) * n; return e < a ? i ? 1 - (e = 1 - e / a) * e : r - (e = 1 - e / a) * e * e * e * r : e > s ? i ? 1 === e ? 0 : 1 - (e = (e - s) / a) * e : r + (e - r) * (e = (e - s) / a) * e * e * e : i ? 1 : r } }, i = function (r, t, n) { var o = Math.log(t / r), a = t - r; return n && (n = e.parseEase(n)), function (e) { return (r * Math.exp(o * (n ? n(e) : e)) - r) / a } }, u = function (e, r, t) { this.t = e, this.v = r, t && (this.next = t, t.prev = this, this.c = t.v - r, this.gap = t.t - e) }, f = function (r) { "object" != typeof r && (r = { points: +r || 20 }); for (var t, n, a, s, i, f, p, c = r.taper || "none", x = [], v = 0, l = 0 | (+r.points || 20), g = l, h = o(r.randomize, !0), E = o(r.clamp), d = e ? e.parseEase(r.template) : 0, w = .4 * (+r.strength || 1); --g > -1;)t = h ? Math.random() : 1 / l * g, n = d ? d(t) : t, a = "none" === c ? w : "out" === c ? (s = 1 - t) * s * w : "in" === c ? t * t * w : t < .5 ? (s = 2 * t) * s * .5 * w : (s = 2 * (1 - t)) * s * .5 * w, h ? n += Math.random() * a - .5 * a : g % 2 ? n += .5 * a : n -= .5 * a, E && (n > 1 ? n = 1 : n < 0 && (n = 0)), x[v++] = { x: t, y: n }; for (x.sort(function (e, r) { return e.x - r.x }), f = new u(1, 1, null), g = l; g--;)i = x[g], f = new u(i.x, i.y, f); return p = new u(0, 0, f.t ? f : f.next), function (e) { var r = p; if (e > r.t) { for (; r.next && e >= r.t;)r = r.next; r = r.prev } else for (; r.prev && e <= r.t;)r = r.prev; return p = r, r.v + (e - r.t) / r.gap * r.c } }, p = s(.7); exports.SlowMo = p, p.ease = p, p.config = s; var c = i(1, 2); exports.ExpoScaleEase = c, c.config = i; var x = f(); exports.RoughEase = x, x.ease = x, x.config = f; var v = { SlowMo: p, RoughEase: x, ExpoScaleEase: c }; for (var l in exports.default = exports.EasePack = v, v) v[l].register = a, v[l].version = "3.5.1"; n() && e.registerPlugin(p);
    }, {}], "DAXG": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = require("./utils/utils"); function t(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function r(e, t) { for (var r = 0; r < t.length; r++) { var a = t[r]; a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a) } } function a(e, t, a) { return t && r(e.prototype, t), a && r(e, a), e } var n = function () { function r(a) { t(this, r), e.bindMethods.call(this), this.el = a, this.chars = "!<>-_\\/[]{}░▒▓—åß∂ƒ©˙∆˚æ≈ç√∫=+*^?#________λ$", this.frame } return a(r, [{ key: "setText", value: function (e) { var t = this, r = this.el.innerText, a = Math.max(r.length, e.length); return new Promise(function (n) { t.resolve = n, t.queue = []; for (var i = 0; i < a; i++) { var s = r[i] || "", o = e[i] || "", u = Math.floor(40 * Math.random()), h = u + Math.floor(40 * Math.random()); t.queue.push({ from: s, to: o, start: u, end: h }) } cancelAnimationFrame(t.frameRequest), t.frame = 0, t.update() }) } }, { key: "update", value: function () { for (var e = "", t = 0, r = 0, a = this.queue.length; r < a; r++) { var n = this.queue[r], i = n.from, s = n.to, o = n.start, u = n.end, h = n.char; this.frame >= u ? (t++, e += s) : this.frame >= o ? (!h || Math.random() < .28) && (h = this.randomChar(), this.queue[r].char = h, e += '<span class="dud">'.concat(h, "</span>")) : e += i } this.el.innerHTML = e, t === this.queue.length ? this.resolve() : (this.frameRequest = requestAnimationFrame(this.update), this.frame++) } }, { key: "randomChar", value: function () { return this.chars[Math.floor(Math.random() * this.chars.length)] } }]), r }(); exports.default = n;
    }, { "./utils/utils": "HUaJ" }], "bAir": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.dynamicSlogan = exports.navbarLinksAnimation = exports.headerFixer = exports.hideHeader = exports.showHeader = void 0; var e = l(require("@barba/core")), t = l(require("gsap")), o = require("gsap/EasePack"), a = l(require("./DynamicChar")), r = require("./utils/utils"), n = require("./magnetic"), i = l(require("./constants/global")); function l(e) { return e && e.__esModule ? e : { default: e } } t.default.registerPlugin(o.SlowMo); var s, c = document.querySelector(".header"), d = c.querySelector(".hamburger-trigger"), u = c.querySelector(".navbar"), y = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; t.default.to(".header", { opacity: 1, y: 0, duration: .7, onComplete: function () { (0, r.css)(document.querySelector(".header"), "pointerEvents", "all"), c.classList.add("show") } }), d.addEventListener("click", f, !1), e || (s = (0, n.magneticItemHover)(".header .secondary-menu", .4, !1)) }; exports.showHeader = y; var f = function () { d.classList.toggle("is-open"), u.classList.toggle("is-open") }, x = function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; t.default.to(".header", { opacity: 0, y: -400, duration: .7, onStart: function () { d.removeEventListener("click", f, !1) }, onComplete: function () { (0, r.css)(document.querySelector(".header"), "pointerEvents", "none"), c.classList.remove("show") } }), e && s && s() }; exports.hideHeader = x; var m = function () { if (!i.default.isMobile) { var e = document.querySelector(".header"), t = 0; window.addEventListener("scroll", function () { (t = window.scrollY) > window.lastScrollTop + 40 && e.classList.contains("show") ? x(!0) : t < window.lastScrollTop - 50 && !e.classList.contains("show") && y(!0), window.lastScrollTop = t }) } }; exports.headerFixer = m; var p = function () { var o = document.querySelectorAll(".header .navbar .menu a"), a = document.querySelector(".header .navbar .secondary-menu .contact"); document.querySelector(".footer"); Array.from(o).map(function (o) { var a = o.querySelectorAll(".circle.top-left"), n = o.querySelectorAll(".circle.top-right"), i = o.querySelectorAll(".circle.bottom-left"), l = o.querySelectorAll(".circle.bottom-right"), s = o.querySelector(".stroke"), c = t.default.timeline(), d = t.default.timeline(), u = t.default.timeline(), y = t.default.timeline(), f = t.default.timeline(), x = t.default.timeline(), m = t.default.timeline(), p = t.default.timeline(), v = t.default.timeline({ paused: !0, onStart: function () { o.classList.add("started"), o.classList.remove("active"), Array.from((0, r.siblingsOfEl)(o)).forEach(function (e) { e.classList.remove("active") }) }, onComplete: function () { o.classList.add("active"), o.classList.remove("started") } }); a.length && (c.to(a, { x: -25, y: -25, scaleY: 2, duration: 1.2, ease: "slow(0.1, 0.7, false)" }), c.to(a[0], { scale: .2, x: "+=6", y: "-=2", duration: .1 }), c.to(a[1], { scaleX: 1, scaleY: .8, x: "-=10", y: "-=7", duration: .1 }, "-=0.1"), c.to(a[2], { scale: .2, x: "-=15", y: "+=6", duration: .1 }, "-=0.1"), c.to(a[0], { scale: 0, x: "-=5", y: "-=15", opacity: 0, duration: 1 }), c.to(a[1], { scaleX: .4, scaleY: .4, x: "-=10", y: "-=10", opacity: 0, duration: 1 }, "-=1"), c.to(a[2], { scale: 0, x: "-=15", y: "+=5", opacity: 0, duration: 1 }, "-=1"), f.set(a, { x: 0, y: 0, rotation: -45 }), f.add(c)), n.length && (y.to(n, { x: 25, y: -25, scaleX: 2, duration: 1.2, ease: "slow(0.1, 0.7, false)" }), y.to(n[0], { scale: .2, x: "-=6", y: "-=2", duration: .1 }), y.to(n[1], { scaleX: 1, scaleY: .8, x: "+=10", y: "-=7", duration: .1 }, "-=0.1"), y.to(n[2], { scale: .2, x: "+=15", y: "+=6", duration: .1 }, "-=0.1"), y.to(n[0], { scale: 0, x: "+=5", y: "-=15", opacity: 0, duration: 1 }), y.to(n[1], { scaleX: .4, scaleY: .4, x: "+=10", y: "-=10", opacity: 0, duration: 1 }, "-=1"), y.to(n[2], { scale: 0, x: "+=15", y: "+=5", opacity: 0, duration: 1 }, "-=1"), p.set(n, { x: 0, y: 0, rotation: -45 }), p.add(y)), l.length && (d.set(l, { x: 0, y: 0 }), d.to(l, { x: 30, y: 30, duration: 1.1, ease: "slow(0.1, 0.7, false)" }), d.to(l[0], { scale: .2, x: "-=6", y: "+=3", duration: .1 }), d.to(l[1], { scale: .8, x: "+=7", y: "+=3", duration: .1 }, "-=0.1"), d.to(l[2], { scale: .2, x: "+=15", y: "-=6", duration: .1 }, "-=0.2"), d.to(l[0], { scale: 0, x: "+=5", y: "+=15", opacity: 0, duration: 1 }), d.to(l[1], { scale: .4, x: "+=7", y: "+=7", opacity: 0, duration: 1 }, "-=1"), d.to(l[2], { scale: 0, x: "+=15", y: "-=5", opacity: 0, duration: 1 }, "-=1"), x.set(l, { x: 0, y: 0, rotation: 45 }), x.add(d)), i.length && (u.set(i, { x: 0, y: 0 }), u.to(i, { x: -30, y: 30, duration: 1.1, ease: "slow(0.1, 0.7, false)" }), u.to(i[0], { scale: .2, x: "+=6", y: "+=3", duration: .1 }), u.to(i[1], { scale: .8, x: "-=7", y: "+=3", duration: .1 }, "-=0.1"), u.to(i[2], { scale: .2, x: "-=15", y: "-=6", duration: .1 }, "-=0.2"), u.to(i[0], { scale: 0, x: "-=5", y: "+=15", opacity: 0, duration: 1 }), u.to(i[1], { scale: .4, x: "-=7", y: "+=7", opacity: 0, duration: 1 }, "-=1"), u.to(i[2], { scale: 0, x: "-=15", y: "-=5", opacity: 0, duration: 1 }, "-=1"), m.set(i, { x: 0, y: 0, rotation: 45 }), m.add(u)), a.length && v.add(f, .2), n.length && v.add(p, .2), l.length && v.add(x, .2), i.length && v.add(m, .2), v.to(s, { scaleY: 1.3, scaleX: 1.1, duration: 1 }, .1), v.to(s, { scale: 1, duration: 1.9, ease: "elastic.out(1, 0.5)" }, 1.2), v.timeScale(2.6), o.addEventListener("click", function (t) { "home" === e.default.history.current.ns && (t.preventDefault(), v.restart()) }) }), a.addEventListener("click", function (e) { e.preventDefault(), f(); var t = document.body.scrollHeight; window.scrollTo({ top: t }) }) }; exports.navbarLinksAnimation = p; var v = function (e) { var t, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1900, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], l = String(e || ".header .logo .features"), s = document.querySelector(l), c = s.getAttribute("data-features"), d = s.querySelector(".prefix"), u = ["#35e5bb", "#fd6619", "#f81664"], y = ["", "An", "An", "A"], f = JSON.parse(c), x = s.querySelector("b"), m = new a.default(x), p = 0, v = 0; !function e() { if (!n || v !== n) { var a = u[p]; (0, r.css)(s.querySelector("b"), "color", a), i && (d.innerHTML = y[p + 1]), m.setText(f[p]).then(function () { t = setTimeout(e, o) }), p = (p + 1) % f.length, v++ } }(); return function () { return clearTimeout(t) } }; exports.dynamicSlogan = v;
    }, { "@barba/core": "nGBO", "gsap": "TpQl", "gsap/EasePack": "bxmL", "./DynamicChar": "DAXG", "./utils/utils": "HUaJ", "./magnetic": "FcVb", "./constants/global": "Utju" }], "nOG6": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.hideTopic = exports.topicAnimations = void 0; var t = l(require("gsap")), e = l(require("pure-parallaxify")), o = require("./utils/utils"), a = l(require("./constants/global")); function l(t) { return t && t.__esModule ? t : { default: t } } var i = function () { var l = document.querySelector(".topic"); t.default.set(".topic .first-line", { scale: .5 }), t.default.set(".topic .second-line", { scale: .4 }), t.default.to(".topic .first-line", { opacity: 1, scale: 1, duration: 1, ease: "elastic.out(1, 0.5)" }), t.default.to(".topic .second-line", { opacity: 1, scale: 1, delay: .3, duration: 1, ease: "elastic.out(1, 0.5)", onComplete: function () { (0, o.css)(l.querySelector(".parallax"), "opacity", 1), a.default.parallaxify || a.default.isMobile || (a.default.parallaxify = new e.default({ positionProperty: "transform" })), t.default.to(".topic-holder .scroll-down", { opacity: 1, duration: .4 }), window.addEventListener("scroll", function () { window.scrollY >= 150 ? t.default.to(".topic-holder .scroll-down", { opacity: 0, duration: .5 }) : t.default.to(".topic-holder .scroll-down", { opacity: 1, duration: .5 }) }, !1) } }) }; exports.topicAnimations = i; var r = function () { a.default.parallaxify && (a.default.parallaxify.destroy(), a.default.parallaxify = null); var e = document.querySelector(".topic").querySelector(".parallax"); t.default.to(".topic .first-line", { opacity: 0, scale: .7, delay: .01, duration: 1, onStart: function () { var o = setTimeout(function () { t.default.set(e, { opacity: 0, left: 0, top: 0 }), clearTimeout(o) }) }, onComplete: function () { window.removeEventListener("scroll", function () { }, !1) } }), t.default.to(".topic .second-line", { opacity: 0, scale: .5, delay: .3, duration: 1 }), t.default.to(".topic-holder .scroll-down", { opacity: 0, duration: .2, delay: .3 }) }; exports.hideTopic = r;
    }, { "gsap": "TpQl", "pure-parallaxify": "CgH9", "./utils/utils": "HUaJ", "./constants/global": "Utju" }], "j2Os": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.footerWaves = void 0; var e = t(require("./constants/global")); function t(e) { return e && e.__esModule ? e : { default: e } } var r = function t() { var r = document.body, i = r.offsetWidth, a = r.offsetHeight; window.addEventListener("resize", v); var o, n, u = r.offsetWidth, d = document.querySelectorAll(".footer-waves path"), l = Array.from(d).map(function (t) { var r, i, a, o, n = t.parentElement; return { el: t, speed: Number(null !== (r = e.default.isMobile ? n.getAttribute("data-mobile-speed") : n.getAttribute("data-speed")) && void 0 !== r ? r : .8), points: Number(null !== (i = e.default.isMobile ? n.getAttribute("data-mobile-points") : n.getAttribute("data-points")) && void 0 !== i ? i : 5), delta: Number(null !== (a = e.default.isMobile ? n.getAttribute("data-mobile-delta") : n.getAttribute("data-delta")) && void 0 !== a ? a : 5), height: Number(null !== (o = e.default.isMobile ? n.getAttribute("data-mobile-height") : n.getAttribute("data-height")) && void 0 !== o ? o : 650) } }); var s = 0; function f() { window.removeEventListener("resize", v), cancelAnimationFrame(o) } function v() { f(), t() } return function e() { var t = window.Date.now(); if (n) { var r = (t - n) / 1e3; n = t; var d = (s += r) * Math.PI; l.forEach(function (e) { return e.el.setAttribute("d", function (e) { var t = "M " + e[0].x + " " + e[0].y, r = { x: (e[1].x - e[0].x) / 2, y: e[1].y - e[0].y + e[0].y + (e[1].y - e[0].y) }; t += " C " + r.x + " " + r.y + " " + r.x + " " + r.y + " " + e[1].x + " " + e[1].y; for (var o = r, n = -1, u = 1; u < e.length - 1; u++) { Math.sqrt(o.x * o.x + o.y * o.y); var d = { x: e[u].x - o.x + e[u].x, y: e[u].y - o.y + e[u].y }; t += " C " + d.x + " " + d.y + " " + d.x + " " + d.y + " " + e[u + 1].x + " " + e[u + 1].y, o = d, n = -n } return t += " L " + i + " " + a, t += " L 0 " + a + " Z" }(function (e, t, r, i) { for (var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 650, o = [], n = 0; n <= t; n++) { var d = n / t * u, l = (e + (n + n % t)) * r * 100, s = Math.sin(l / 100) * i, f = Math.sin(l / 100) * s + a; o.push({ x: d, y: f }) } return o }(d, e.points, e.speed, e.delta, e.height))) }) } else n = t; o = requestAnimationFrame(e) }(), f }; exports.footerWaves = r;
    }, { "./constants/global": "Utju" }], "dsjG": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = require("./utils/utils"); function t(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function i(e, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function r(e, t, r) { return t && i(e.prototype, t), r && i(e, r), e } var n = function () { function i() { var r = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div[data-barba]", s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "div[data-scroll]", l = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1; t(this, i), e.bindMethods.call(this), this.mathUtils = { map: function (e, t, i, r, n) { return (e - t) * (n - r) / (i - t) + r }, lerp: function (e, t, i) { return (1 - i) * e + i * t } }, this.winsize, this.docScroll, this.body = document.body, this.DOM = { main: document.querySelector(n) }, this.DOM.scrollable = this.DOM.main.querySelector(s), this.renderedStyles = { translationY: { previous: 0, current: 0, ease: l, setValue: function () { return r.docScroll } } }, window.addEventListener("resize", this.calcSize, !1), window.addEventListener("scroll", this.getPageYScroll, !1), this.calcSize(), this.style(), this.getPageYScroll(), this.update(), this.render() } return r(i, [{ key: "calcSize", value: function () { this.setSize() } }, { key: "getPageYScroll", value: function () { this.docScroll = window.pageYOffset || document.documentElement.scrollTop } }, { key: "setSize", value: function () { this.body.style.height = "".concat(this.DOM.scrollable.scrollHeight, "px") } }, { key: "style", value: function () { this.DOM.main.style.position = "fixed", this.DOM.main.style.width = this.DOM.main.style.height = "100%", this.DOM.main.style.top = this.DOM.main.style.left = 0, this.DOM.main.style.overflow = "hidden" } }, { key: "update", value: function () { for (var e in this.renderedStyles) this.renderedStyles[e].current = this.renderedStyles[e].previous = this.renderedStyles[e].setValue(); this.layout() } }, { key: "layout", value: function () { this.DOM.scrollable.style.transform = "translate3d(0,".concat(-1 * this.renderedStyles.translationY.previous, "px,0)") } }, { key: "render", value: function () { for (var e in this.renderedStyles) this.renderedStyles[e].current = this.renderedStyles[e].setValue(), this.renderedStyles[e].previous = this.mathUtils.lerp(this.renderedStyles[e].previous, this.renderedStyles[e].current, this.renderedStyles[e].ease); this.layout(), this.reqAnimationFrame = requestAnimationFrame(this.render) } }, { key: "dispose", value: function () { window.removeEventListener("resize", this.calcWinsize, !1), window.removeEventListener("scroll", this.getPageYScroll, !1), cancelAnimationFrame(this.reqAnimationFrame) } }]), i }(); exports.default = n;
    }, { "./utils/utils": "HUaJ" }], "qPEW": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Home = void 0; var e = d(require("gsap/gsap-core")), t = d(require("eol")), o = d(require("locomotive-scroll")), i = require("./utils/utils"), r = require("./navbar"), a = require("./topic"), l = require("./footer-waves"), s = d(require("./Bubble")), n = require("./magnetic"), c = d(require("./constants/global")), u = d(require("./SmoothScroll")); function d(e) { return e && e.__esModule ? e : { default: e } } function f(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function m(e, t) { for (var o = 0; o < t.length; o++) { var i = t[o]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function h(e, t, o) { return t && m(e.prototype, t), o && m(e, o), e } var v = function () { function d(e, t) { f(this, d), i.bindMethods.call(this), this.stage = e, this.bird = t, this.magneticSocialHover, this.magneticEmailHover, this.awwwards = document.querySelector("#awwwards") } return h(d, [{ key: "init", value: function () { var i, r; if (c.default.isMobile) { var a = document.querySelector("[data-scroll-container]"); a && (this.locomotiveScroll = new o.default({ el: a, smooth: !0 })) } e.default.to(this.awwwards, { opacity: 1, pointerEvents: "all" }); var l = null === (i = window.location.hash) || void 0 === i ? void 0 : i.split("#")[1], s = document.querySelector(".header"); if (l) { var n = s.querySelector(".menu a.".concat(l)); n && n.classList.add("active") } else s.querySelector(".menu a:first-child").classList.add("active"); var d = document.querySelector(".audio-toggle"); if (e.default.to(d, { visibility: "visible", pointerEvents: "all" }), !c.default.isMobile) { var f = document.querySelectorAll(".projects .project-row"); Array.from(f).forEach(function (e) { var o = e.querySelector(".description-wrapper .content"), i = o.innerText; o.innerHTML = "", t.default.split(i).filter(function (e) { return !!e }).forEach(function (e) { var t = document.createElement("p"); t.innerText = e, o.append(t) }) }) } var m = s.querySelector(".menu a.active"); this.loadProjectsOfCategory(null !== (r = m.classList.item(0)) && void 0 !== r ? r : null), this.arrangeProjects(), this.revealBlocks(), c.default.isMobile || (this.smoothScroll = new u.default) } }, { key: "revealBlocks", value: function () { var e = this; document.querySelector("html").classList.remove("stop-scroll"); var t = document.querySelector(".header .signature"); (0, r.showHeader)(), (0, r.navbarLinksAnimation)(), this.dynamicSloganKill = (0, r.dynamicSlogan)(); var o = setTimeout(function () { (0, a.topicAnimations)(), clearTimeout(o) }, 400), s = setTimeout(function () { e.addBubbles(), e.handleLinksClick(); e.bird.flying(), e.bird.colorizeAndResizeBird(function () { e.bird.goToElementPosition(t, !0) }), clearTimeout(s) }, 1e3), u = setTimeout(function () { e.footerWavesKill = (0, l.footerWaves)(); var t = document.querySelector(".footer"); c.default.isMobile || (e.magneticSocialHover = (0, n.magneticItemHover)(".social"), e.magneticEmailHover = (0, n.magneticItemHover)(".footer .email", .2)), (0, i.css)(t, "opacity", 1), (0, i.css)(t, "pointerEvents", "all"), clearTimeout(u) }, 1e3) } }, { key: "addBubbles", value: function () { var e = this; this.stage.bubbles = Array.from(this.projects).map(function (t, o) { var r = t.querySelector(".bubble-wrapper"), a = (0, i.getBubbleTypeFromClass)(t.classList), l = new s.default(r, e.stage.scene, e.stage.camera, e.stage.geometry, a, o, !0); return l.division = 20, l }) } }, { key: "handleLinksClick", value: function () { var e = this; document.querySelector(".header").querySelectorAll(".menu a").forEach(function (t) { t.addEventListener("click", e.eachMenuLinkClick, !1) }) } }, { key: "eachMenuLinkClick", value: function (e) { var t = this, o = e.target, i = ("SPAN" === o.tagName ? o.parentElement : o).classList.item(0), r = document.querySelector(".header .navbar"), a = document.querySelector(".header .hamburger-trigger"); c.default.isMobile && r.classList.contains("is-open") && (r.classList.remove("is-open"), a.classList.remove("is-open")), this.hideProjects(function () { t.removeBubbles(), setTimeout(function () { t.loadProjectsOfCategory(i), t.arrangeProjects(), t.addBubbles() }, 100) }) } }, { key: "loadProjectsOfCategory", value: function (e) { this.projects = e ? document.querySelectorAll(".projects .project-row.".concat(e)) : document.querySelectorAll(".projects .project-row") } }, { key: "arrangeProjects", value: function () { var t = this, o = Array.from(this.projects); o.forEach(function (e, t) { var i, r; t % 2 == 0 && (null === (i = o[t]) || void 0 === i || i.classList.add("left"), null === (r = o[t + 1]) || void 0 === r || r.classList.add("right")); c.default.isMobile && e.classList.add("colored-title"), e.classList.add("visible") }), e.default.to(o, { y: 0, opacity: 1, duration: .5, stagger: .1, onComplete: function () { t.smoothScroll && t.smoothScroll.setSize() } }) } }, { key: "hideProjects", value: function (t) { var o = this, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = e.default.timeline({ onComplete: function () { r.kill(), t() } }); i ? r.to(this.projects, { opacity: 0, duration: .5, stagger: .2, onStart: function () { o.stage.bubbles && o.stage.bubbles.forEach(function (e) { return e.hide() }) } }, "-=0.2") : (r.to(this.projects, { y: c.default.isMobile ? -100 : -150, stagger: .1 }), r.to(this.projects, { y: 200, opacity: 0, duration: .5, stagger: .2, onStart: function () { o.stage.bubbles && o.stage.bubbles.forEach(function (e) { return e.hide() }) } }, "-=0.2")) } }, { key: "dispose", value: function () { var t, o = this, i = document.querySelector(".header").querySelectorAll(".menu a"); (this.smoothScroll && this.smoothScroll.dispose(), i.forEach(function (e) { e.removeEventListener("click", o.eachMenuLinkClick, !1) }), (0, r.hideHeader)(), this.dynamicSloganKill(), (0, a.hideTopic)(), this.footerWavesKill(), this.hideProjects(function () { o.removeBubbles() }, !0), this.locomotiveScroll) && (null === (t = this.locomotiveScroll) || void 0 === t || t.destroy()); this.magneticSocialHover && this.magneticSocialHover(), this.magneticEmailHover && this.magneticEmailHover(); var l = document.querySelector(".footer"); e.default.to(l, { opacity: 0, duration: .3, onComplete: function () { e.default.set(l, { pointerEvents: "none" }) } }), this.bird.dispose() } }, { key: "removeBubbles", value: function () { this.projects.forEach(function (e) { e.classList.remove("visible", "right", "left") }), this.projects = null, this.stage.bubbles.forEach(function (e) { return e.dispose() }), this.stage.bubbles = null } }]), d }(); exports.Home = v;
    }, { "gsap/gsap-core": "TNS6", "eol": "HFPo", "locomotive-scroll": "ez7q", "./utils/utils": "HUaJ", "./navbar": "bAir", "./topic": "nOG6", "./footer-waves": "j2Os", "./Bubble": "t3hd", "./magnetic": "FcVb", "./constants/global": "Utju", "./SmoothScroll": "dsjG" }], "a2rU": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Panzoom = exports.Fancybox = exports.Carousel = void 0; const t = t => "object" == typeof t && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t), e = (...i) => { let s = !1; "boolean" == typeof i[0] && (s = i.shift()); let o = i[0]; if (!o || "object" != typeof o) throw new Error("extendee must be an object"); const n = i.slice(1), a = n.length; for (let r = 0; r < a; r++) { const i = n[r]; for (let n in i) if (i.hasOwnProperty(n)) { const a = i[n]; if (s && (Array.isArray(a) || t(a))) { const t = Array.isArray(a) ? [] : {}; o[n] = e(!0, o.hasOwnProperty(n) ? o[n] : t, a) } else o[n] = a } } return o }, i = (t, e = 1e4) => (t = parseFloat(t) || 0, Math.round((t + Number.EPSILON) * e) / e), s = "undefined" != typeof window && window.ResizeObserver || class { constructor(t) { this.observables = [], this.boundCheck = this.check.bind(this), this.boundCheck(), this.callback = t } observe(t) { if (this.observables.some(e => e.el === t)) return; const e = { el: t, size: { height: t.clientHeight, width: t.clientWidth } }; this.observables.push(e) } unobserve(t) { this.observables = this.observables.filter(e => e.el !== t) } disconnect() { this.observables = [] } check() { const t = this.observables.filter(t => { const e = t.el.clientHeight, i = t.el.clientWidth; if (t.size.height !== e || t.size.width !== i) return t.size.height = e, t.size.width = i, !0 }).map(t => t.el); t.length > 0 && this.callback(t), window.requestAnimationFrame(this.boundCheck) } }; class o { constructor(t) { this.id = -1, this.id = t.pointerId || t.identifier || -1, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, this.clientY = t.clientY, this.nativePointer = t } } function n(t, e) { return e ? Math.sqrt((e.clientX - t.clientX) ** 2 + (e.clientY - t.clientY) ** 2) : 0 } function a(t, e) { return e ? { clientX: (t.clientX + e.clientX) / 2, clientY: (t.clientY + e.clientY) / 2 } : t } class r { constructor(t, { start: e = (() => !0), move: i = (() => { }), end: s = (() => { }) } = {}) { this.element = t, this.startPointers = [], this.currentPointers = [], this.startCallback = e, this.moveCallback = i, this.endCallback = s, this.onStart = (t => { if (t.button && 0 !== t.button) return; const e = new o(t); if (!1 === this.startCallback(e, t)) return !1; t.preventDefault(), (() => { const t = window.getSelection ? window.getSelection() : document.selection; t && t.rangeCount && t.getRangeAt(0).getClientRects().length && (t.removeAllRanges ? t.removeAllRanges() : t.empty && t.empty()) })(), this.currentPointers.push(e), this.startPointers.push(e), (t.target && "setPointerCapture" in t.target ? t.target : this.element).setPointerCapture(t.pointerId), this.element.addEventListener("pointermove", this.onMove), this.element.addEventListener("pointerup", this.onEnd), this.element.addEventListener("pointercancel", this.onEnd) }), this.onMove = (t => { const e = this.currentPointers.slice(), i = []; for (const s of [new o(t)]) { const t = this.currentPointers.findIndex(t => t.id === s.id); t < 0 || (i.push(s), this.currentPointers[t] = s) } i.length && this.moveCallback(e, this.currentPointers, t) }), this.onEnd = (t => { const e = new o(t), i = this.currentPointers.findIndex(t => t.id === e.id); if (-1 === i) return !1; this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this.endCallback(e, t), this.currentPointers.length || (this.element.removeEventListener("pointermove", this.onMove), this.element.removeEventListener("pointerup", this.onEnd), this.element.removeEventListener("pointercancel", this.onEnd)) }), this.element.addEventListener("pointerdown", this.onStart) } stop() { this.element.removeEventListener("pointerdown", this.onStart), this.element.removeEventListener("pointermove", this.onMove), this.element.removeEventListener("pointerup", this.onEnd), this.element.removeEventListener("pointercancel", this.onEnd) } } const l = function (t) { return !!(t && "object" == typeof t && t instanceof Element && t !== document.body) && (function (t) { const e = getComputedStyle(t)["overflow-y"], i = getComputedStyle(t)["overflow-x"], s = ("scroll" === e || "auto" === e) && Math.abs(t.scrollHeight - t.clientHeight) > 1, o = ("scroll" === i || "auto" === i) && Math.abs(t.scrollWidth - t.clientWidth) > 1; return s || o }(t) ? t : l(t.parentNode)) }; class h { constructor(t = {}) { this.options = e(!0, {}, t), this.plugins = [], this.events = {}; for (const e of ["on", "once"]) for (const t of Object.entries(this.options[e] || {})) this[e](...t) } option(t, e, ...i) { let s = (o = t = String(t), n = this.options, o.split(".").reduce(function (t, e) { return t && t[e] }, n)); var o, n; return "function" == typeof s && (s = s.call(this, this, ...i)), void 0 === s ? e : s } localize(t, e = []) { return (t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t, i, s) => { let o = ""; s ? o = this.option(`${i[0] + i.toLowerCase().substring(1)}.l10n.${s}`) : i && (o = this.option(`l10n.${i}`)), o || (o = t); for (let n = 0; n < e.length; n++)o = o.split(e[n][0]).join(e[n][1]); return o })).replace(/\{\{(.*)\}\}/, (t, e) => e) } on(e, i) { if (t(e)) { for (const t of Object.entries(e)) this.on(...t); return this } return String(e).split(" ").forEach(t => { const e = this.events[t] = this.events[t] || []; -1 == e.indexOf(i) && e.push(i) }), this } once(e, i) { if (t(e)) { for (const t of Object.entries(e)) this.once(...t); return this } return String(e).split(" ").forEach(t => { const e = (...s) => { this.off(t, e), i.call(this, this, ...s) }; e._ = i, this.on(t, e) }), this } off(e, i) { if (!t(e)) return e.split(" ").forEach(t => { const e = this.events[t]; if (!e || !e.length) return this; let s = -1; for (let o = 0, n = e.length; o < n; o++) { const t = e[o]; if (t && (t === i || t._ === i)) { s = o; break } } -1 != s && e.splice(s, 1) }), this; for (const t of Object.entries(e)) this.off(...t) } trigger(t, ...e) { for (const i of [...this.events[t] || []].slice()) if (i && !1 === i.call(this, this, ...e)) return !1; for (const i of [...this.events["*"] || []].slice()) if (i && !1 === i.call(this, t, this, ...e)) return !1; return !0 } attachPlugins(t) { const i = {}; for (const [s, o] of Object.entries(t || {})) !1 === this.options[s] || this.plugins[s] || (this.options[s] = e({}, o.defaults || {}, this.options[s]), i[s] = new o(this)); for (const [e, s] of Object.entries(i)) s.attach(this); return this.plugins = Object.assign({}, this.plugins, i), this } detachPlugins() { for (const t in this.plugins) { let e; (e = this.plugins[t]) && "function" == typeof e.detach && e.detach(this) } return this.plugins = {}, this } } const c = { touch: !0, zoom: !0, pinchToZoom: !0, panOnlyZoomed: !1, lockAxis: !1, friction: .64, decelFriction: .88, zoomFriction: .74, bounceForce: .2, baseScale: 1, minScale: 1, maxScale: 2, step: .5, textSelection: !1, click: "toggleZoom", wheel: "zoom", wheelFactor: 42, wheelLimit: 5, draggableClass: "is-draggable", draggingClass: "is-dragging", ratio: 1 }; class d extends h { constructor(t, i = {}) { super(e(!0, {}, c, i)), this.state = "init", this.$container = t; for (const e of ["onLoad", "onWheel", "onClick"]) this[e] = this[e].bind(this); this.initLayout(), this.resetValues(), this.attachPlugins(d.Plugins), this.trigger("init"), this.updateMetrics(), this.attachEvents(), this.trigger("ready"), !1 === this.option("centerOnStart") ? this.state = "ready" : this.panTo({ friction: 0 }) } initLayout() { const t = this.$container; if (!(t instanceof HTMLElement)) throw new Error("Panzoom: Container not found"); const e = this.option("content") || t.querySelector(".panzoom__content"); if (!e) throw new Error("Panzoom: Content not found"); this.$content = e; let i = this.option("viewport") || t.querySelector(".panzoom__viewport"); i || !1 === this.option("wrapInner") || ((i = document.createElement("div")).classList.add("panzoom__viewport"), i.append(...t.childNodes), t.appendChild(i)), this.$viewport = i || e.parentNode } resetValues() { this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24), this.container = { width: 0, height: 0 }, this.viewport = { width: 0, height: 0 }, this.content = { origWidth: 0, origHeight: 0, width: 0, height: 0, x: this.option("x", 0), y: this.option("y", 0), scale: this.option("baseScale") }, this.transform = { x: 0, y: 0, scale: 1 }, this.resetDragPosition() } onLoad(t) { this.updateMetrics(), this.panTo({ scale: this.option("baseScale"), friction: 0 }), this.trigger("load", t) } onClick(t) { if (t.defaultPrevented) return; if (this.option("textSelection") && window.getSelection().toString().length) return void t.stopPropagation(); const e = this.$content.getClientRects()[0]; if ("ready" !== this.state && (this.dragPosition.midPoint || Math.abs(e.top - this.dragStart.rect.top) > 1 || Math.abs(e.left - this.dragStart.rect.left) > 1)) return t.preventDefault(), void t.stopPropagation(); !1 !== this.trigger("click", t) && this.option("zoom") && "toggleZoom" === this.option("click") && (t.preventDefault(), t.stopPropagation(), this.zoomWithClick(t)) } onWheel(t) { !1 !== this.trigger("wheel", t) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(t) } zoomWithWheel(t) { void 0 === this.changedDelta && (this.changedDelta = 0); const e = Math.max(-1, Math.min(1, -t.deltaY || -t.deltaX || t.wheelDelta || -t.detail)), i = this.content.scale; let s = i * (100 + e * this.option("wheelFactor")) / 100; if (e < 0 && Math.abs(i - this.option("minScale")) < .01 || e > 0 && Math.abs(i - this.option("maxScale")) < .01 ? (this.changedDelta += Math.abs(e), s = i) : (this.changedDelta = 0, s = Math.max(Math.min(s, this.option("maxScale")), this.option("minScale"))), this.changedDelta > this.option("wheelLimit")) return; if (t.preventDefault(), s === i) return; const o = this.$content.getBoundingClientRect(), n = t.clientX - o.left, a = t.clientY - o.top; this.zoomTo(s, { x: n, y: a }) } zoomWithClick(t) { const e = this.$content.getClientRects()[0], i = t.clientX - e.left, s = t.clientY - e.top; this.toggleZoom({ x: i, y: s }) } attachEvents() { this.$content.addEventListener("load", this.onLoad), this.$container.addEventListener("wheel", this.onWheel, { passive: !1 }), this.$container.addEventListener("click", this.onClick, { passive: !1 }), this.initObserver(); const t = new r(this.$container, { start: (e, i) => { if (!this.option("touch")) return !1; if (!(this.velocity.scale < 0)) { if (!t.currentPointers.length) { if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(i.target.nodeName)) return !1; if (this.option("textSelection") && ((t, e, i) => { const s = t.childNodes, o = document.createRange(); for (let n = 0; n < s.length; n++) { const t = s[n]; if (t.nodeType !== Node.TEXT_NODE) continue; o.selectNodeContents(t); const a = o.getBoundingClientRect(); if (e >= a.left && i >= a.top && e <= a.right && i <= a.bottom) return t } return !1 })(i.target, i.clientX, i.clientY)) return !1; if (l(i.target)) return !1 } return !1 !== this.trigger("touchStart", i) && (this.state = "pointerdown", this.resetDragPosition(), this.dragPosition.midPoint = null, this.dragPosition.time = Date.now(), !0) } }, move: (e, i, s) => { if ("pointerdown" !== this.state) return; if (0 == this.trigger("touchMove", s)) return void s.preventDefault(); if (i.length < 2 && 1 == this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale")) return; if (i.length > 1 && (!this.option("zoom") || !1 === this.option("pinchToZoom"))) return; s.preventDefault(), s.stopPropagation(); const o = a(e[0], e[1]), r = a(i[0], i[1]), l = r.clientX - o.clientX, h = r.clientY - o.clientY, c = n(e[0], e[1]), d = n(i[0], i[1]), u = c ? d / c : 1; this.dragOffset.x += l, this.dragOffset.y += h, this.dragOffset.scale *= u, this.dragOffset.time = Date.now() - this.dragPosition.time; const f = 1 === this.dragStart.scale && this.option("lockAxis"); if (f && !this.lockAxis) { if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return; if ("xy" === f) { const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI); this.lockAxis = t > 45 && t < 135 ? "y" : "x" } else this.lockAxis = f } if (this.lockAxis && (this.dragOffset["x" === this.lockAxis ? "y" : "x"] = 0), this.$container.classList.add(this.option("draggingClass")), this.transform.scale === this.option("baseScale") && "y" === this.lockAxis || (this.dragPosition.x = this.dragStart.x + this.dragOffset.x), this.transform.scale === this.option("baseScale") && "x" === this.lockAxis || (this.dragPosition.y = this.dragStart.y + this.dragOffset.y), this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale, i.length > 1) { const e = a(t.startPointers[0], t.startPointers[1]), i = e.clientX - this.dragStart.rect.x, s = e.clientY - this.dragStart.rect.y, { deltaX: o, deltaY: n } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, i, s); this.dragPosition.x -= o, this.dragPosition.y -= n, this.dragPosition.midPoint = r } else this.setDragResistance(); this.transform = { x: this.dragPosition.x, y: this.dragPosition.y, scale: this.dragPosition.scale }, this.startAnimation() }, end: (e, i) => { if ("pointerdown" !== this.state) return; if (this._dragOffset = { ...this.dragOffset }, t.currentPointers.length) return void this.resetDragPosition(); if (this.state = "decel", this.friction = this.option("decelFriction"), this.recalculateTransform(), this.$container.classList.remove(this.option("draggingClass")), !1 === this.trigger("touchEnd", i)) return; if ("decel" !== this.state) return; const s = this.option("minScale"); if (this.transform.scale < s) return void this.zoomTo(s, { friction: .64 }); const o = this.option("maxScale"); if (this.transform.scale - o > .01) { const t = this.dragPosition.midPoint || e, i = this.$content.getClientRects()[0]; this.zoomTo(o, { friction: .64, x: t.clientX - i.left, y: t.clientY - i.top }) } } }); this.pointerTracker = t } initObserver() { this.resizeObserver || (this.resizeObserver = new s(() => { this.updateTimer || (this.updateTimer = setTimeout(() => { const t = this.$container.getBoundingClientRect(); t.width && t.height ? ((Math.abs(t.width - this.container.width) > 1 || Math.abs(t.height - this.container.height) > 1) && (this.isAnimating() && this.endAnimation(!0), this.updateMetrics(), this.panTo({ x: this.content.x, y: this.content.y, scale: this.option("baseScale"), friction: 0 })), this.updateTimer = null) : this.updateTimer = null }, this.updateRate)) }), this.resizeObserver.observe(this.$container)) } resetDragPosition() { this.lockAxis = null, this.friction = this.option("friction"), this.velocity = { x: 0, y: 0, scale: 0 }; const { x: t, y: e, scale: i } = this.content; this.dragStart = { rect: this.$content.getBoundingClientRect(), x: t, y: e, scale: i }, this.dragPosition = { ...this.dragPosition, x: t, y: e, scale: i }, this.dragOffset = { x: 0, y: 0, scale: 1, time: 0 } } updateMetrics(t) { !0 !== t && this.trigger("beforeUpdate"); const e = this.$container, s = this.$content, o = this.$viewport, n = s instanceof HTMLImageElement, a = this.option("zoom"), r = this.option("resizeParent", a); let l = this.option("width"), h = this.option("height"), c = l || (d = s, Math.max(parseFloat(d.naturalWidth || 0), parseFloat(d.width && d.width.baseVal && d.width.baseVal.value || 0), parseFloat(d.offsetWidth || 0), parseFloat(d.scrollWidth || 0))); var d; let u = h || (t => Math.max(parseFloat(t.naturalHeight || 0), parseFloat(t.height && t.height.baseVal && t.height.baseVal.value || 0), parseFloat(t.offsetHeight || 0), parseFloat(t.scrollHeight || 0)))(s); Object.assign(s.style, { width: l ? `${l}px` : "", height: h ? `${h}px` : "", maxWidth: "", maxHeight: "" }), r && Object.assign(o.style, { width: "", height: "" }); const f = this.option("ratio"); l = c = i(c * f), h = u = i(u * f); const g = s.getBoundingClientRect(), p = o.getBoundingClientRect(), m = o == e ? p : e.getBoundingClientRect(); let y = Math.max(o.offsetWidth, i(p.width)), b = Math.max(o.offsetHeight, i(p.height)), v = window.getComputedStyle(o); if (y -= parseFloat(v.paddingLeft) + parseFloat(v.paddingRight), b -= parseFloat(v.paddingTop) + parseFloat(v.paddingBottom), this.viewport.width = y, this.viewport.height = b, a) { if (Math.abs(c - g.width) > .1 || Math.abs(u - g.height) > .1) { const t = ((t, e, i, s) => { const o = Math.min(i / t || 0, s / e); return { width: t * o || 0, height: e * o || 0 } })(c, u, Math.min(c, g.width), Math.min(u, g.height)); l = i(t.width), h = i(t.height) } Object.assign(s.style, { width: `${l}px`, height: `${h}px`, transform: "" }) } if (r && (Object.assign(o.style, { width: `${l}px`, height: `${h}px` }), this.viewport = { ...this.viewport, width: l, height: h }), n && a && "function" != typeof this.options.maxScale) { const t = this.option("maxScale"); this.options.maxScale = function () { return this.content.origWidth > 0 && this.content.fitWidth > 0 ? this.content.origWidth / this.content.fitWidth : t } } this.content = { ...this.content, origWidth: c, origHeight: u, fitWidth: l, fitHeight: h, width: l, height: h, scale: 1, isZoomable: a }, this.container = { width: m.width, height: m.height }, !0 !== t && this.trigger("afterUpdate") } zoomIn(t) { this.zoomTo(this.content.scale + (t || this.option("step"))) } zoomOut(t) { this.zoomTo(this.content.scale - (t || this.option("step"))) } toggleZoom(t = {}) { const e = this.option("maxScale"), i = this.option("baseScale"), s = this.content.scale > i + .5 * (e - i) ? i : e; this.zoomTo(s, t) } zoomTo(t = this.option("baseScale"), { x: e = null, y: s = null } = {}) { t = Math.max(Math.min(t, this.option("maxScale")), this.option("minScale")); const o = i(this.content.scale / (this.content.width / this.content.fitWidth), 1e7); null === e && (e = this.content.width * o * .5), null === s && (s = this.content.height * o * .5); const { deltaX: n, deltaY: a } = this.getZoomDelta(t, e, s); e = this.content.x - n, s = this.content.y - a, this.panTo({ x: e, y: s, scale: t, friction: this.option("zoomFriction") }) } getZoomDelta(t, e = 0, i = 0) { const s = this.content.fitWidth * this.content.scale, o = this.content.fitHeight * this.content.scale, n = e > 0 && s ? e / s : 0, a = i > 0 && o ? i / o : 0; return { deltaX: (this.content.fitWidth * t - s) * n, deltaY: (this.content.fitHeight * t - o) * a } } panTo({ x: t = this.content.x, y: e = this.content.y, scale: i, friction: s = this.option("friction"), ignoreBounds: o = !1 } = {}) { if (i = i || this.content.scale || 1, !o) { const { boundX: s, boundY: o } = this.getBounds(i); s && (t = Math.max(Math.min(t, s.to), s.from)), o && (e = Math.max(Math.min(e, o.to), o.from)) } this.friction = s, this.transform = { ...this.transform, x: t, y: e, scale: i }, s ? (this.state = "panning", this.velocity = { x: (1 / this.friction - 1) * (t - this.content.x), y: (1 / this.friction - 1) * (e - this.content.y), scale: (1 / this.friction - 1) * (i - this.content.scale) }, this.startAnimation()) : this.endAnimation() } startAnimation() { this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"), this.rAF = requestAnimationFrame(() => this.animate()) } animate() { if (this.setEdgeForce(), this.setDragForce(), this.velocity.x *= this.friction, this.velocity.y *= this.friction, this.velocity.scale *= this.friction, this.content.x += this.velocity.x, this.content.y += this.velocity.y, this.content.scale += this.velocity.scale, this.isAnimating()) this.setTransform(); else if ("pointerdown" !== this.state) return void this.endAnimation(); this.rAF = requestAnimationFrame(() => this.animate()) } getBounds(t) { let e = this.boundX, s = this.boundY; if (void 0 !== e && void 0 !== s) return { boundX: e, boundY: s }; e = { from: 0, to: 0 }, s = { from: 0, to: 0 }, t = t || this.transform.scale; const o = this.content.fitWidth, n = this.content.fitHeight, a = o * t, r = n * t, l = this.viewport.width, h = this.viewport.height; if (o <= l) { const t = .5 * (l - a), s = .5 * (a - o); e.from = i(t - s), e.to = i(t + s) } else e.from = i(l - a); if (n <= h) { const t = .5 * (h - r), e = .5 * (r - n); s.from = i(t - e), s.to = i(t + e) } else s.from = i(h - a); return { boundX: e, boundY: s } } setEdgeForce() { if ("decel" !== this.state) return; const t = this.option("bounceForce"), { boundX: e, boundY: i } = this.getBounds(Math.max(this.transform.scale, this.content.scale)); let s, o, n, a; if (e && (s = this.content.x < e.from, o = this.content.x > e.to), i && (n = this.content.y < i.from, a = this.content.y > i.to), s || o) { let i = ((s ? e.from : e.to) - this.content.x) * t; const o = this.content.x + (this.velocity.x + i) / this.friction; o >= e.from && o <= e.to && (i += this.velocity.x), this.velocity.x = i, this.recalculateTransform() } if (n || a) { let e = ((n ? i.from : i.to) - this.content.y) * t; const s = this.content.y + (e + this.velocity.y) / this.friction; s >= i.from && s <= i.to && (e += this.velocity.y), this.velocity.y = e, this.recalculateTransform() } } setDragResistance() { if ("pointerdown" !== this.state) return; const { boundX: t, boundY: e } = this.getBounds(this.dragPosition.scale); let i, s, o, n; if (t && (i = this.dragPosition.x < t.from, s = this.dragPosition.x > t.to), e && (o = this.dragPosition.y < e.from, n = this.dragPosition.y > e.to), (i || s) && (!i || !s)) { const e = i ? t.from : t.to, s = e - this.dragPosition.x; this.dragPosition.x = e - .3 * s } if ((o || n) && (!o || !n)) { const t = o ? e.from : e.to, i = t - this.dragPosition.y; this.dragPosition.y = t - .3 * i } } setDragForce() { "pointerdown" === this.state && (this.velocity.x = this.dragPosition.x - this.content.x, this.velocity.y = this.dragPosition.y - this.content.y, this.velocity.scale = this.dragPosition.scale - this.content.scale) } recalculateTransform() { this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1), this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1), this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1) } isAnimating() { return !(!this.friction || !(Math.abs(this.velocity.x) > .05 || Math.abs(this.velocity.y) > .05 || Math.abs(this.velocity.scale) > .05)) } setTransform(t) { let e, s, o; if (t ? (e = i(this.transform.x), s = i(this.transform.y), o = this.transform.scale, this.content = { ...this.content, x: e, y: s, scale: o }) : (e = i(this.content.x), s = i(this.content.y), o = this.content.scale / (this.content.width / this.content.fitWidth), this.content = { ...this.content, x: e, y: s }), this.trigger("beforeTransform"), e = i(this.content.x), s = i(this.content.y), t && this.option("zoom")) { let t, n; t = i(this.content.fitWidth * o), n = i(this.content.fitHeight * o), this.content.width = t, this.content.height = n, this.transform = { ...this.transform, width: t, height: n, scale: o }, Object.assign(this.$content.style, { width: `${t}px`, height: `${n}px`, maxWidth: "none", maxHeight: "none", transform: `translate3d(${e}px, ${s}px, 0) scale(1)` }) } else this.$content.style.transform = `translate3d(${e}px, ${s}px, 0) scale(${o})`; this.trigger("afterTransform") } endAnimation(t) { cancelAnimationFrame(this.rAF), this.rAF = null, this.velocity = { x: 0, y: 0, scale: 0 }, this.setTransform(!0), this.state = "ready", this.handleCursor(), !0 !== t && this.trigger("endAnimation") } handleCursor() { const t = this.option("draggableClass"); t && this.option("touch") && (1 == this.option("panOnlyZoomed") && this.content.width <= this.viewport.width && this.content.height <= this.viewport.height && this.transform.scale <= this.option("baseScale") ? this.$container.classList.remove(t) : this.$container.classList.add(t)) } detachEvents() { this.$content.removeEventListener("load", this.onLoad), this.$container.removeEventListener("wheel", this.onWheel, { passive: !1 }), this.$container.removeEventListener("click", this.onClick, { passive: !1 }), this.pointerTracker && (this.pointerTracker.stop(), this.pointerTracker = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null) } destroy() { "destroy" !== this.state && (this.state = "destroy", clearTimeout(this.updateTimer), this.updateTimer = null, cancelAnimationFrame(this.rAF), this.rAF = null, this.detachEvents(), this.detachPlugins(), this.resetDragPosition()) } } exports.Panzoom = d, d.version = "4.0.12", d.Plugins = {}; const u = (t, e) => { let i = 0; return function (...s) { const o = (new Date).getTime(); if (!(o - i < e)) return i = o, t(...s) } }; class f { constructor(t) { this.$container = null, this.$prev = null, this.$next = null, this.carousel = t, this.onRefresh = this.onRefresh.bind(this) } option(t) { return this.carousel.option(`Navigation.${t}`) } createButton(t) { const e = document.createElement("button"); e.setAttribute("title", this.carousel.localize(`{{${t.toUpperCase()}}}`)); const i = this.option("classNames.button") + " " + this.option(`classNames.${t}`); return e.classList.add(...i.split(" ")), e.setAttribute("tabindex", "0"), e.innerHTML = this.carousel.localize(this.option(`${t}Tpl`)), e.addEventListener("click", e => { e.preventDefault(), e.stopPropagation(), this.carousel["slide" + ("next" === t ? "Next" : "Prev")]() }), e } build() { this.$container || (this.$container = document.createElement("div"), this.$container.classList.add(this.option("classNames.main")), this.carousel.$container.appendChild(this.$container)), this.$next || (this.$next = this.createButton("next"), this.$container.appendChild(this.$next)), this.$prev || (this.$prev = this.createButton("prev"), this.$container.appendChild(this.$prev)) } onRefresh() { const t = this.carousel.pages.length; t <= 1 || t > 1 && this.carousel.elemDimWidth < this.carousel.wrapDimWidth && !Number.isInteger(this.carousel.option("slidesPerPage")) ? this.cleanup() : (this.build(), this.$prev.removeAttribute("disabled"), this.$next.removeAttribute("disabled"), this.carousel.option("infiniteX", this.carousel.option("infinite")) || (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""), this.carousel.page >= t - 1 && this.$next.setAttribute("disabled", ""))) } cleanup() { this.$prev && this.$prev.remove(), this.$prev = null, this.$next && this.$next.remove(), this.$next = null, this.$container && this.$container.remove(), this.$container = null } attach() { this.carousel.on("refresh change", this.onRefresh) } detach() { this.carousel.off("refresh change", this.onRefresh), this.cleanup() } } f.defaults = { prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>', nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', classNames: { main: "carousel__nav", button: "carousel__button", next: "is-next", prev: "is-prev" } }; class g { constructor(t) { this.carousel = t, this.selectedIndex = null, this.friction = 0, this.onNavReady = this.onNavReady.bind(this), this.onNavClick = this.onNavClick.bind(this), this.onNavCreateSlide = this.onNavCreateSlide.bind(this), this.onTargetChange = this.onTargetChange.bind(this) } addAsTargetFor(t) { this.target = this.carousel, this.nav = t, this.attachEvents() } addAsNavFor(t) { this.target = t, this.nav = this.carousel, this.attachEvents() } attachEvents() { this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.on("createSlide", this.onNavCreateSlide), this.nav.on("Panzoom.click", this.onNavClick), this.target.on("change", this.onTargetChange), this.target.on("Panzoom.afterUpdate", this.onTargetChange) } onNavReady() { this.onTargetChange(!0) } onNavClick(t, e, i) { const s = i.target.closest(".carousel__slide"); if (!s) return; i.stopPropagation(); const o = parseInt(s.dataset.index, 10), n = this.target.findPageForSlide(o); this.target.page !== n && this.target.slideTo(n, { friction: this.friction }), this.markSelectedSlide(o) } onNavCreateSlide(t, e) { e.index === this.selectedIndex && this.markSelectedSlide(e.index) } onTargetChange() { const t = this.target.pages[this.target.page].indexes[0], e = this.nav.findPageForSlide(t); this.nav.slideTo(e), this.markSelectedSlide(t) } markSelectedSlide(t) { this.selectedIndex = t, [...this.nav.slides].filter(t => t.$el && t.$el.classList.remove("is-nav-selected")); const e = this.nav.slides[t]; e && e.$el && e.$el.classList.add("is-nav-selected") } attach(t) { const e = t.options.Sync; (e.target || e.nav) && (e.target ? this.addAsNavFor(e.target) : e.nav && this.addAsTargetFor(e.nav), this.friction = e.friction) } detach() { this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("createSlide", this.onNavCreateSlide)), this.target && (this.target.off("Panzoom.afterUpdate", this.onTargetChange), this.target.off("change", this.onTargetChange)) } } g.defaults = { friction: .92 }; const p = { Navigation: f, Dots: class { constructor(t) { this.carousel = t, this.$list = null, this.events = { change: this.onChange.bind(this), refresh: this.onRefresh.bind(this) } } buildList() { if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) return; const t = document.createElement("ol"); return t.classList.add("carousel__dots"), t.addEventListener("click", t => { if (!("page" in t.target.dataset)) return; t.preventDefault(), t.stopPropagation(); const e = parseInt(t.target.dataset.page, 10), i = this.carousel; e !== i.page && (i.pages.length < 3 && i.option("infinite") ? i[0 == e ? "slidePrev" : "slideNext"]() : i.slideTo(e)) }), this.$list = t, this.carousel.$container.appendChild(t), this.carousel.$container.classList.add("has-dots"), t } removeList() { this.$list && (this.$list.parentNode.removeChild(this.$list), this.$list = null), this.carousel.$container.classList.remove("has-dots") } rebuildDots() { let t = this.$list; const e = !!t, i = this.carousel.pages.length; if (i < 2) return void (e && this.removeList()); e || (t = this.buildList()); const s = this.$list.children.length; if (s > i) for (let o = i; o < s; o++)this.$list.removeChild(this.$list.lastChild); else { for (let t = s; t < i; t++) { const e = document.createElement("li"); e.classList.add("carousel__dot"), e.dataset.page = t, e.setAttribute("role", "button"), e.setAttribute("tabindex", "0"), e.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", t + 1]])), e.addEventListener("keydown", t => { const i = t.code; let s; "Enter" === i || "NumpadEnter" === i ? s = e : "ArrowRight" === i ? s = e.nextSibling : "ArrowLeft" === i && (s = e.previousSibling), s && s.click() }), this.$list.appendChild(e) } this.setActiveDot() } } setActiveDot() { if (!this.$list) return; this.$list.childNodes.forEach(t => { t.classList.remove("is-selected") }); const t = this.$list.childNodes[this.carousel.page]; t && t.classList.add("is-selected") } onChange() { this.setActiveDot() } onRefresh() { this.rebuildDots() } attach() { this.carousel.on(this.events) } detach() { this.removeList(), this.carousel.off(this.events), this.carousel = null } }, Sync: g }, m = { slides: [], preload: 0, slidesPerPage: "auto", initialPage: null, initialSlide: null, friction: .92, center: !0, infinite: !0, fill: !0, dragFree: !1, prefix: "", classNames: { viewport: "carousel__viewport", track: "carousel__track", slide: "carousel__slide", slideSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } }; class y extends h { constructor(t, i = {}) { if (super(i = e(!0, {}, m, i)), this.state = "init", this.$container = t, !(this.$container instanceof HTMLElement)) throw new Error("No root element provided"); this.slideNext = u(this.slideNext.bind(this), 250), this.slidePrev = u(this.slidePrev.bind(this), 250), this.init() } init() { this.pages = [], this.page = this.pageIndex = null, this.prevPage = this.prevPageIndex = null, this.attachPlugins(y.Plugins), this.trigger("init"), this.initLayout(), this.initSlides(), this.updateMetrics(), this.$track && this.pages.length && (this.$track.style.transform = `translate3d(${-1 * this.pages[this.page].left}px, 0px, 0) scale(1)`), this.manageSlideVisiblity(), this.initPanzoom(), this.state = "ready", this.trigger("ready") } initLayout() { const t = this.option("prefix"), e = this.option("classNames"); this.$viewport = this.option("viewport") || this.$container.querySelector(`.${t}${e.viewport}`), this.$viewport || (this.$viewport = document.createElement("div"), this.$viewport.classList.add(t + e.viewport), this.$viewport.append(...this.$container.childNodes), this.$container.appendChild(this.$viewport)), this.$track = this.option("track") || this.$container.querySelector(`.${t}${e.track}`), this.$track || (this.$track = document.createElement("div"), this.$track.classList.add(t + e.track), this.$track.append(...this.$viewport.childNodes), this.$viewport.appendChild(this.$track)) } initSlides() { this.slides = [], this.$viewport.querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`).forEach(t => { const e = { $el: t, isDom: !0 }; this.slides.push(e), this.trigger("createSlide", e, this.slides.length) }), Array.isArray(this.options.slides) && (this.slides = e(!0, [...this.slides], this.options.slides)) } updateMetrics() { let t, e = 0, s = []; this.slides.forEach((i, o) => { const n = i.$el, a = i.isDom || !t ? this.getSlideMetrics(n) : t; i.index = o, i.width = a, i.left = e, t = a, e += a, s.push(o) }); let o = Math.max(this.$track.offsetWidth, i(this.$track.getBoundingClientRect().width)), n = getComputedStyle(this.$track); o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), this.contentWidth = e, this.viewportWidth = o; const a = [], r = this.option("slidesPerPage"); if (Number.isInteger(r) && e > o) for (let i = 0; i < this.slides.length; i += r)a.push({ indexes: s.slice(i, i + r), slides: this.slides.slice(i, i + r) }); else { let t = 0, e = 0; for (let i = 0; i < this.slides.length; i += 1) { let s = this.slides[i]; (!a.length || e + s.width > o) && (a.push({ indexes: [], slides: [] }), t = a.length - 1, e = 0), e += s.width, a[t].indexes.push(i), a[t].slides.push(s) } } const l = this.option("center"), h = this.option("fill"); a.forEach((t, i) => { t.index = i, t.width = t.slides.reduce((t, e) => t + e.width, 0), t.left = t.slides[0].left, l && (t.left += .5 * (o - t.width) * -1), h && !this.option("infiniteX", this.option("infinite")) && e > o && (t.left = Math.max(t.left, 0), t.left = Math.min(t.left, e - o)) }); const c = []; let d; a.forEach(t => { const e = { ...t }; d && e.left === d.left ? (d.width += e.width, d.slides = [...d.slides, ...e.slides], d.indexes = [...d.indexes, ...e.indexes]) : (e.index = c.length, d = e, c.push(e)) }), this.pages = c; let u = this.page; if (null === u) { const t = this.option("initialSlide"); u = null !== t ? this.findPageForSlide(t) : this.option("initialPage", 0), c[u] || (u = c.length && u > c.length ? c[c.length - 1].index : 0), this.page = u, this.pageIndex = u } this.updatePanzoom(), this.trigger("refresh") } getSlideMetrics(t) { if (!t) { const e = this.slides[0]; (t = document.createElement("div")).dataset.isTestEl = 1, t.style.visibility = "hidden", t.classList.add(this.option("prefix") + this.option("classNames.slide")), e.customClass && t.classList.add(...e.customClass.split(" ")), this.$track.prepend(t) } let e = Math.max(t.offsetWidth, i(t.getBoundingClientRect().width)); const s = t.currentStyle || window.getComputedStyle(t); return e = e + (parseFloat(s.marginLeft) || 0) + (parseFloat(s.marginRight) || 0), t.dataset.isTestEl && t.remove(), e } findPageForSlide(t) { const e = this.pages.find(e => e.indexes.indexOf(t) > -1); return e ? e.index : null } slideNext() { this.slideTo(this.pageIndex + 1) } slidePrev() { this.slideTo(this.pageIndex - 1) } slideTo(t, e = {}) { const { x: i = -1 * this.setPage(t, !0), y: s = 0, friction: o = this.option("friction") } = e; this.Panzoom.content.x === i && !this.Panzoom.velocity.x && o || (this.Panzoom.panTo({ x: i, y: s, friction: o, ignoreBounds: !0 }), "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle")) } initPanzoom() { this.Panzoom && this.Panzoom.destroy(); const t = e(!0, {}, { content: this.$track, wrapInner: !1, resizeParent: !1, zoom: !1, click: !1, lockAxis: "x", x: this.pages.length ? -1 * this.pages[this.page].left : 0, centerOnStart: !1, textSelection: () => this.option("textSelection", !1), panOnlyZoomed: function () { return this.content.width <= this.viewport.width } }, this.option("Panzoom")); this.Panzoom = new d(this.$container, t), this.Panzoom.on({ "*": (t, ...e) => this.trigger(`Panzoom.${t}`, ...e), afterUpdate: () => { this.updatePage() }, beforeTransform: this.onBeforeTransform.bind(this), touchEnd: this.onTouchEnd.bind(this), endAnimation: () => { this.trigger("settle") } }), this.updateMetrics(), this.manageSlideVisiblity() } updatePanzoom() { this.Panzoom && (this.Panzoom.content = { ...this.Panzoom.content, fitWidth: this.contentWidth, origWidth: this.contentWidth, width: this.contentWidth }, this.pages.length > 1 && this.option("infiniteX", this.option("infinite")) ? this.Panzoom.boundX = null : this.pages.length && (this.Panzoom.boundX = { from: -1 * this.pages[this.pages.length - 1].left, to: -1 * this.pages[0].left }), this.option("infiniteY", this.option("infinite")) ? this.Panzoom.boundY = null : this.Panzoom.boundY = { from: 0, to: 0 }, this.Panzoom.handleCursor()) } manageSlideVisiblity() { const t = this.contentWidth, e = this.viewportWidth; let i = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages.length ? this.pages[this.page].left : 0; const s = this.option("preload"), o = this.option("infiniteX", this.option("infinite")), n = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")), a = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right")); this.slides.forEach(r => { let l, h, c = 0; l = i - n, h = i + e + a, l -= s * (e + n + a), h += s * (e + n + a); const d = r.left + r.width > l && r.left < h; l = i + t - n, h = i + t + e + a, l -= s * (e + n + a); const u = o && r.left + r.width > l && r.left < h; l = i - t - n, h = i - t + e + a, l -= s * (e + n + a); const f = o && r.left + r.width > l && r.left < h; u || d || f ? (this.createSlideEl(r), d && (c = 0), u && (c = -1), f && (c = 1), r.left + r.width > i && r.left <= i + e + a && (c = 0)) : this.removeSlideEl(r), r.hasDiff = c }); let r = 0, l = 0; this.slides.forEach((e, i) => { let s = 0; e.$el ? (i !== r || e.hasDiff ? s = l + e.hasDiff * t : l = 0, e.$el.style.left = Math.abs(s) > .1 ? `${l + e.hasDiff * t}px` : "", r++) : l += e.width }), this.markSelectedSlides() } createSlideEl(t) { if (!t) return; if (t.$el) { if (parseInt(t.$el.dataset.index, 10) !== t.index) { let e; t.$el.dataset.index = t.index, t.$el.querySelectorAll("[data-lazy-src]").forEach(t => { let e = t.dataset.lazySrc; t instanceof HTMLImageElement ? t.src = e : t.style.backgroundImage = `url('${e}')` }), t.$el.querySelectorAll("[data-lazy-srcset]").forEach(t => { t.srcset = t.dataset.lazySrcset }), (e = t.$el.dataset.lazySrc) && (t.$el.style.backgroundImage = `url('${e}')`), t.state = "ready" } return } const e = document.createElement("div"); e.dataset.index = t.index, e.classList.add(this.option("prefix") + this.option("classNames.slide")), t.customClass && e.classList.add(...t.customClass.split(" ")), t.html && (e.innerHTML = t.html); const i = []; this.slides.forEach((t, e) => { t.$el && i.push(e) }); const s = t.index; let o = null; if (i.length) { let t = i.reduce((t, e) => Math.abs(e - s) < Math.abs(t - s) ? e : t); o = this.slides[t] } return this.$track.insertBefore(e, o && o.$el ? o.index < t.index ? o.$el.nextSibling : o.$el : null), t.$el = e, this.trigger("createSlide", t, s), t } removeSlideEl(t) { t.$el && !t.isDom && (this.trigger("removeSlide", t), t.$el.remove(), t.$el = null) } markSelectedSlides() { const t = this.option("classNames.slideSelected"), e = "aria-hidden"; this.slides.forEach((i, s) => { const o = i.$el; if (!o) return; const n = this.pages[this.page]; n && n.indexes && n.indexes.indexOf(s) > -1 ? (t && !o.classList.contains(t) && (o.classList.add(t), this.trigger("selectSlide", i)), o.removeAttribute(e)) : (t && o.classList.contains(t) && (o.classList.remove(t), this.trigger("unselectSlide", i)), o.setAttribute(e, !0)) }) } updatePage() { this.updateMetrics(), this.slideTo(this.page, { friction: 0 }) } onBeforeTransform() { this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity() } manageInfiniteTrack() { const t = this.contentWidth, e = this.viewportWidth; if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || t < e) return; const i = this.Panzoom; let s = !1; return i.content.x < -1 * (t - e) && (i.content.x += t, this.pageIndex = this.pageIndex - this.pages.length, s = !0), i.content.x > e && (i.content.x -= t, this.pageIndex = this.pageIndex + this.pages.length, s = !0), s && "pointerdown" === i.state && i.resetDragPosition(), s } onTouchEnd(t, e) { const i = this.option("dragFree"); if (!i && this.pages.length > 1 && t.dragOffset.time < 350 && Math.abs(t.dragOffset.y) < 1 && Math.abs(t.dragOffset.x) > 5) this[t.dragOffset.x < 0 ? "slideNext" : "slidePrev"](); else if (i) { const [, e] = this.getPageFromPosition(-1 * t.transform.x); this.setPage(e) } else this.slideToClosest() } slideToClosest(t = {}) { let [, e] = this.getPageFromPosition(-1 * this.Panzoom.content.x); this.slideTo(e, t) } getPageFromPosition(t) { const e = this.pages.length; this.option("center") && (t += .5 * this.viewportWidth); const i = Math.floor(t / this.contentWidth); t -= i * this.contentWidth; let s = this.slides.find(e => e.left <= t && e.left + e.width > t); if (s) { let t = this.findPageForSlide(s.index); return [t, t + i * e] } return [0, 0] } setPage(t, e) { let i = 0, s = parseInt(t, 10) || 0; const o = this.page, n = this.pageIndex, a = this.pages.length, r = this.contentWidth, l = this.viewportWidth; if (t = (s % a + a) % a, this.option("infiniteX", this.option("infinite")) && r > l) { const o = Math.floor(s / a) || 0, n = r; if (i = this.pages[t].left + o * n, !0 === e && a > 2) { let t = -1 * this.Panzoom.content.x; const e = i - n, o = i + n, r = Math.abs(t - i), l = Math.abs(t - e), h = Math.abs(t - o); h < r && h <= l ? (i = o, s += a) : l < r && l < h && (i = e, s -= a) } } else t = s = Math.max(0, Math.min(s, a - 1)), i = this.pages.length ? this.pages[t].left : 0; return this.page = t, this.pageIndex = s, null !== o && t !== o && (this.prevPage = o, this.prevPageIndex = n, this.trigger("change", t, o)), i } destroy() { this.state = "destroy", this.slides.forEach(t => { this.removeSlideEl(t) }), this.slides = [], this.Panzoom.destroy(), this.detachPlugins() } } exports.Carousel = y, y.version = "4.0.12", y.Plugins = p; const b = !("undefined" == typeof window || !window.document || !window.document.createElement); let v = null; const x = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'], w = t => { if (t && b) { null === v && document.createElement("div").focus({ get preventScroll() { return v = !0, !1 } }); try { if (t.setActive) t.setActive(); else if (v) t.focus({ preventScroll: !0 }); else { const e = window.pageXOffset || document.body.scrollTop, i = window.pageYOffset || document.body.scrollLeft; t.focus(), document.body.scrollTo({ top: e, left: i, behavior: "auto" }) } } catch (t) { } } }; class $ { constructor(t) { this.fancybox = t, this.$container = null, this.state = "init"; for (const e of ["onPrepare", "onClosing", "onKeydown"]) this[e] = this[e].bind(this); this.events = { prepare: this.onPrepare, closing: this.onClosing, keydown: this.onKeydown } } onPrepare() { this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount") ? this.state = "disabled" : !0 === this.fancybox.option("Thumbs.autoStart") && this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") && this.build() } onClosing() { this.Carousel && this.Carousel.Panzoom.detachEvents() } onKeydown(t, e) { e === t.option("Thumbs.key") && this.toggle() } build() { if (this.$container) return; const t = document.createElement("div"); t.classList.add("fancybox__thumbs"), this.fancybox.$carousel.parentNode.insertBefore(t, this.fancybox.$carousel.nextSibling), this.Carousel = new y(t, e(!0, { Dots: !1, Navigation: !1, Sync: { friction: 0 }, infinite: !1, center: !0, fill: !0, dragFree: !0, slidesPerPage: 1, preload: 1 }, this.fancybox.option("Thumbs.Carousel"), { Sync: { target: this.fancybox.Carousel }, slides: this.getSlides() })), this.Carousel.Panzoom.on("wheel", (t, e) => { e.preventDefault(), this.fancybox[e.deltaY < 0 ? "prev" : "next"]() }), this.$container = t, this.state = "visible" } getSlides() { const t = []; for (const e of this.fancybox.items) { const i = e.thumb; i && t.push({ html: `<div class="fancybox__thumb" style="background-image:url('${i}')"></div>`, customClass: `has-thumb has-${e.type || "image"}` }) } return t } toggle() { "visible" === this.state ? this.hide() : "hidden" === this.state ? this.show() : this.build() } show() { "hidden" === this.state && (this.$container.style.display = "", this.Carousel.Panzoom.attachEvents(), this.state = "visible") } hide() { "visible" === this.state && (this.Carousel.Panzoom.detachEvents(), this.$container.style.display = "none", this.state = "hidden") } cleanup() { this.Carousel && (this.Carousel.destroy(), this.Carousel = null), this.$container && (this.$container.remove(), this.$container = null), this.state = "init" } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events), this.cleanup() } } $.defaults = { minSlideCount: 2, minScreenHeight: 500, autoStart: !0, key: "t", Carousel: {} }; const C = t => Object.entries(t).map(t => t.map(encodeURIComponent).join("=")).join("&"), S = { video: { autoplay: !0, ratio: 16 / 9 }, youtube: { autohide: 1, fs: 1, rel: 0, hd: 1, wmode: "transparent", enablejsapi: 1, html5: 1 }, vimeo: { hd: 1, show_title: 1, show_byline: 1, show_portrait: 0, fullscreen: 1 }, html5video: { tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>', format: "" } }; class E { constructor(t) { this.fancybox = t; for (const e of ["onInit", "onReady", "onCreateSlide", "onRemoveSlide", "onSelectSlide", "onUnselectSlide", "onRefresh", "onMessage"]) this[e] = this[e].bind(this); this.events = { init: this.onInit, ready: this.onReady, "Carousel.createSlide": this.onCreateSlide, "Carousel.removeSlide": this.onRemoveSlide, "Carousel.selectSlide": this.onSelectSlide, "Carousel.unselectSlide": this.onUnselectSlide, "Carousel.refresh": this.onRefresh } } onInit() { for (const t of this.fancybox.items) this.processType(t) } processType(t) { if (t.html) return t.src = t.html, t.type = "html", void delete t.html; const i = t.src || ""; let s = t.type || this.fancybox.options.type, o = null; if (!i || "string" == typeof i) { if (o = i.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) { const e = C(this.fancybox.option("Html.youtube")), i = encodeURIComponent(o[1]); t.videoId = i, t.src = `https://www.youtube-nocookie.com/embed/${i}?${e}`, t.thumb = t.thumb || `https://i.ytimg.com/vi/${i}/mqdefault.jpg`, t.vendor = "youtube", s = "video" } else if (o = i.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) { const e = C(this.fancybox.option("Html.vimeo")), i = encodeURIComponent(o[1]); t.videoId = i, t.src = `https://player.vimeo.com/video/${i}?${e}`, t.vendor = "vimeo", s = "video" } else (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = `//maps.google.${o[1]}/?ll=${(o[2] ? o[2] + "&z=" + Math.floor(o[3]) + (o[4] ? o[4].replace(/^\//, "&") : "") : o[4] + "").replace(/\?/, "&")}&output=${o[4] && o[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, s = "map") : (o = i.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = `//maps.google.${o[1]}/maps?q=${o[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, s = "map"); s || ("#" === i.charAt(0) ? s = "inline" : (o = i.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (s = "html5video", t.format = t.format || "video/" + ("ogv" === o[1] ? "ogg" : o[1])) : i.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? s = "image" : i.match(/\.(pdf)((\?|#).*)?$/i) && (s = "pdf")), t.type = s || this.fancybox.option("defaultType", "image"), "html5video" !== s && "video" !== s || (t.video = e({}, this.fancybox.option("Html.video"), t.video), t._width && t._height ? t.ratio = parseFloat(t._width) / parseFloat(t._height) : t.ratio = t.ratio || t.video.ratio || S.video.ratio) } } onReady() { this.fancybox.Carousel.slides.forEach(t => { t.$el && (this.setContent(t), t.index === this.fancybox.getSlide().index && this.playVideo(t)) }) } onCreateSlide(t, e, i) { "ready" === this.fancybox.state && this.setContent(i) } loadInlineContent(t) { let e; if (t.src instanceof HTMLElement) e = t.src; else if ("string" == typeof t.src) { const i = t.src.split("#", 2), s = 2 === i.length && "" === i[0] ? i[1] : i[0]; e = document.getElementById(s) } if (e) { if ("clone" === t.type || e.$placeHolder) { let i = (e = e.cloneNode(!0)).getAttribute("id"); i = i ? `${i}--clone` : `clone-${this.fancybox.id}-${t.index}`, e.setAttribute("id", i) } else { const t = document.createElement("div"); t.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(t, e), e.$placeHolder = t } this.fancybox.setContent(t, e) } else this.fancybox.setError(t, "{{ELEMENT_NOT_FOUND}}") } loadAjaxContent(t) { const e = this.fancybox, i = new XMLHttpRequest; e.showLoading(t), i.onreadystatechange = function () { i.readyState === XMLHttpRequest.DONE && "ready" === e.state && (e.hideLoading(t), 200 === i.status ? e.setContent(t, i.responseText) : e.setError(t, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}")) }, i.open("GET", t.src), i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.send(t.ajax || null), t.xhr = i } loadIframeContent(t) { const e = this.fancybox, i = document.createElement("iframe"); if (i.className = "fancybox__iframe", i.setAttribute("id", `fancybox__iframe_${e.id}_${t.index}`), i.setAttribute("allow", "autoplay; fullscreen"), i.setAttribute("scrolling", "auto"), t.$iframe = i, "iframe" !== t.type || !1 === t.preload) return i.setAttribute("src", t.src), this.fancybox.setContent(t, i), void this.resizeIframe(t); e.showLoading(t); const s = document.createElement("div"); s.style.visibility = "hidden", this.fancybox.setContent(t, s), s.appendChild(i), i.onerror = (() => { e.setError(t, "{{IFRAME_ERROR}}") }), i.onload = (() => { e.hideLoading(t); let s = !1; i.isReady || (i.isReady = !0, s = !0), i.src.length && (i.parentNode.style.visibility = "", this.resizeIframe(t), s && e.revealContent(t)) }), i.setAttribute("src", t.src) } setAspectRatio(t) { const e = t.$content, i = t.ratio; if (!e) return; let s = t._width, o = t._height; if (i || s && o) { Object.assign(e.style, { width: s && o ? "100%" : "", height: s && o ? "100%" : "", maxWidth: "", maxHeight: "" }); let t = e.offsetWidth, n = e.offsetHeight; if (o = o || n, (s = s || t) > t || o > n) { let e = Math.min(t / s, n / o); s *= e, o *= e } Math.abs(s / o - i) > .01 && (i < s / o ? s = o * i : o = s / i), Object.assign(e.style, { width: `${s}px`, height: `${o}px` }) } } resizeIframe(t) { const e = t.$iframe; if (!e) return; let i = t._width || 0, s = t._height || 0; i && s && (t.autoSize = !1); const o = e.parentNode, n = o.style; if (!1 !== t.preload && !1 !== t.autoSize) try { const a = window.getComputedStyle(o), r = parseFloat(a.paddingLeft) + parseFloat(a.paddingRight), l = parseFloat(a.paddingTop) + parseFloat(a.paddingBottom), h = e.contentWindow.document, c = h.getElementsByTagName("html")[0], d = h.body; d.style.overflow = "hidden", i = i || c.scrollWidth + r, n.width = `${i}px`, d.style.overflow = "", n.flex = "0 0 auto", n.height = `${d.scrollHeight}px`, s = c.scrollHeight + l } catch (t) { } if (i || s) { const t = { flex: "0 1 auto" }; i && (t.width = `${i}px`), s && (t.height = `${s}px`), Object.assign(n, t) } } onRefresh(t, e) { e.slides.forEach(t => { t.$el && (t.$iframe && this.resizeIframe(t), t.ratio && this.setAspectRatio(t)) }) } setContent(t) { if (t && !t.isDom) { switch (t.type) { case "html": this.fancybox.setContent(t, t.src); break; case "html5video": this.fancybox.setContent(t, this.fancybox.option("Html.html5video.tpl").replace(/\{\{src\}\}/gi, t.src).replace("{{format}}", t.format || t.html5video && t.html5video.format || "").replace("{{poster}}", t.poster || t.thumb || "")); break; case "inline": case "clone": this.loadInlineContent(t); break; case "ajax": this.loadAjaxContent(t); break; case "iframe": case "pdf": case "video": case "map": this.loadIframeContent(t) }t.ratio && this.setAspectRatio(t) } } onSelectSlide(t, e, i) { "ready" === t.state && this.playVideo(i) } playVideo(t) { if ("html5video" === t.type && t.video.autoplay) try { const e = t.$el.querySelector("video"); if (e) { const t = e.play(); void 0 !== t && t.then(() => { }).catch(t => { e.muted = !0, e.play() }) } } catch (t) { } if ("video" !== t.type || !t.$iframe || !t.$iframe.contentWindow) return; const e = () => { if ("done" === t.state && t.$iframe && t.$iframe.contentWindow) { let e; if (t.$iframe.isReady) return t.video && t.video.autoplay && (e = "youtube" == t.vendor ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }), void (e && t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*")); "youtube" === t.vendor && (e = { event: "listening", id: t.$iframe.getAttribute("id") }, t.$iframe.contentWindow.postMessage(JSON.stringify(e), "*")) } t.poller = setTimeout(e, 250) }; e() } onUnselectSlide(t, e, i) { if ("html5video" === i.type) { try { i.$el.querySelector("video").pause() } catch (t) { } return } let s = !1; "vimeo" == i.vendor ? s = { method: "pause", value: "true" } : "youtube" === i.vendor && (s = { event: "command", func: "pauseVideo" }), s && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(s), "*"), clearTimeout(i.poller) } onRemoveSlide(t, e, i) { i.xhr && (i.xhr.abort(), i.xhr = null), i.$iframe && (i.$iframe.onload = i.$iframe.onerror = null, i.$iframe.src = "//about:blank", i.$iframe = null); const s = i.$content; "inline" === i.type && s && (s.classList.remove("fancybox__content"), "none" !== s.style.display && (s.style.display = "none")), i.$closeButton && (i.$closeButton.remove(), i.$closeButton = null); const o = s && s.$placeHolder; o && (o.parentNode.insertBefore(s, o), o.remove(), s.$placeHolder = null) } onMessage(t) { try { let e = JSON.parse(t.data); if ("https://player.vimeo.com" === t.origin) { if ("ready" === e.event) for (let i of document.getElementsByClassName("fancybox__iframe")) i.contentWindow === t.source && (i.isReady = 1) } else "https://www.youtube-nocookie.com" === t.origin && "onReady" === e.event && (document.getElementById(e.id).isReady = 1) } catch (t) { } } attach() { this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1) } detach() { this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1) } } E.defaults = S; class P { constructor(t) { this.fancybox = t; for (const e of ["onReady", "onClosing", "onDone", "onPageChange", "onCreateSlide", "onRemoveSlide", "onImageStatusChange"]) this[e] = this[e].bind(this); this.events = { ready: this.onReady, closing: this.onClosing, done: this.onDone, "Carousel.change": this.onPageChange, "Carousel.createSlide": this.onCreateSlide, "Carousel.removeSlide": this.onRemoveSlide } } onReady() { this.fancybox.Carousel.slides.forEach(t => { t.$el && this.setContent(t) }) } onDone(t, e) { this.handleCursor(e) } onClosing(t) { clearTimeout(this.clickTimer), this.clickTimer = null, t.Carousel.slides.forEach(t => { t.$image && (t.state = "destroy"), t.Panzoom && t.Panzoom.detachEvents() }), "closing" === this.fancybox.state && this.canZoom(t.getSlide()) && this.zoomOut() } onCreateSlide(t, e, i) { "ready" === this.fancybox.state && this.setContent(i) } onRemoveSlide(t, e, i) { i.$image && (i.$el.classList.remove(t.option("Image.canZoomInClass")), i.$image.remove(), i.$image = null), i.Panzoom && (i.Panzoom.destroy(), i.Panzoom = null), i.$el && i.$el.dataset && delete i.$el.dataset.imageFit } setContent(t) { if (t.isDom || t.html || t.type && "image" !== t.type) return; if (t.$image) return; t.type = "image", t.state = "loading"; const e = document.createElement("div"); e.style.visibility = "hidden"; const i = document.createElement("img"); i.addEventListener("load", e => { e.stopImmediatePropagation(), this.onImageStatusChange(t) }), i.addEventListener("error", () => { this.onImageStatusChange(t) }), i.src = t.src, i.alt = "", i.draggable = !1, i.classList.add("fancybox__image"), t.srcset && i.setAttribute("srcset", t.srcset), t.sizes && i.setAttribute("sizes", t.sizes), t.$image = i; const s = this.fancybox.option("Image.wrap"); if (s) { const o = document.createElement("div"); o.classList.add("string" == typeof s ? s : "fancybox__image-wrap"), o.appendChild(i), e.appendChild(o), t.$wrap = o } else e.appendChild(i); t.$el.dataset.imageFit = this.fancybox.option("Image.fit"), this.fancybox.setContent(t, e), i.complete || i.error ? this.onImageStatusChange(t) : this.fancybox.showLoading(t) } onImageStatusChange(t) { const e = t.$image; e && "loading" === t.state && (e.complete && e.naturalWidth && e.naturalHeight ? (this.fancybox.hideLoading(t), "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(t), t.$el.addEventListener("wheel", e => this.onWheel(t, e), { passive: !1 }), t.$content.addEventListener("click", e => this.onClick(t, e), { passive: !1 }), this.revealContent(t)) : this.fancybox.setError(t, "{{IMAGE_ERROR}}")) } initSlidePanzoom(t) { t.Panzoom || (t.Panzoom = new d(t.$el, e(!0, this.fancybox.option("Image.Panzoom", {}), { viewport: t.$wrap, content: t.$image, width: t._width, height: t._height, wrapInner: !1, textSelection: !0, touch: this.fancybox.option("Image.touch"), panOnlyZoomed: !0, click: !1, wheel: !1 })), t.Panzoom.on("startAnimation", () => { this.fancybox.trigger("Image.startAnimation", t) }), t.Panzoom.on("endAnimation", () => { "zoomIn" === t.state && this.fancybox.done(t), this.handleCursor(t), this.fancybox.trigger("Image.endAnimation", t) }), t.Panzoom.on("afterUpdate", () => { this.handleCursor(t), this.fancybox.trigger("Image.afterUpdate", t) })) } revealContent(t) { null === this.fancybox.Carousel.prevPage && t.index === this.fancybox.options.startIndex && this.canZoom(t) ? this.zoomIn() : this.fancybox.revealContent(t) } getZoomInfo(t) { const e = t.$thumb.getBoundingClientRect(), i = e.width, s = e.height, o = t.$content.getBoundingClientRect(), n = o.width, a = o.height, r = o.top - e.top, l = o.left - e.left; let h = this.fancybox.option("Image.zoomOpacity"); return "auto" === h && (h = Math.abs(i / s - n / a) > .1), { top: r, left: l, scale: n && i ? i / n : 1, opacity: h } } canZoom(t) { const e = this.fancybox, i = e.$container; if (window.visualViewport && 1 !== window.visualViewport.scale) return !1; if (t.Panzoom && !t.Panzoom.content.width) return !1; if (!e.option("Image.zoom") || "contain" !== e.option("Image.fit")) return !1; const s = t.$thumb; if (!s || "loading" === t.state) return !1; i.classList.add("fancybox__no-click"); const o = s.getBoundingClientRect(); let n; if (this.fancybox.option("Image.ignoreCoveredThumbnail")) { const t = document.elementFromPoint(o.left + 1, o.top + 1) === s, e = document.elementFromPoint(o.right - 1, o.bottom - 1) === s; n = t && e } else n = document.elementFromPoint(o.left + .5 * o.width, o.top + .5 * o.height) === s; return i.classList.remove("fancybox__no-click"), n } zoomIn() { const t = this.fancybox, e = t.getSlide(), i = e.Panzoom, { top: s, left: o, scale: n, opacity: a } = this.getZoomInfo(e); e.state = "zoomIn", t.trigger("reveal", e), i.panTo({ x: -1 * o, y: -1 * s, scale: n, friction: 0, ignoreBounds: !0 }), e.$content.style.visibility = "", !0 === a && i.on("afterTransform", t => { "zoomIn" !== e.state && "zoomOut" !== e.state || (t.$content.style.opacity = Math.min(1, 1 - (1 - t.content.scale) / (1 - n))) }), i.panTo({ x: 0, y: 0, scale: 1, friction: this.fancybox.option("Image.zoomFriction") }) } zoomOut() { const t = this.fancybox, e = t.getSlide(), i = e.Panzoom; if (!i) return; e.state = "zoomOut", t.state = "customClosing", e.$caption && (e.$caption.style.visibility = "hidden"); let s = this.fancybox.option("Image.zoomFriction"); const o = t => { const { top: o, left: n, scale: a, opacity: r } = this.getZoomInfo(e); t || r || (s *= .82), i.panTo({ x: -1 * n, y: -1 * o, scale: a, friction: s, ignoreBounds: !0 }), s *= .98 }; window.addEventListener("scroll", o), i.once("endAnimation", () => { window.removeEventListener("scroll", o), t.destroy() }), o() } handleCursor(t) { if ("image" !== t.type || !t.$el) return; const e = t.Panzoom, i = this.fancybox.option("Image.click", !1, t), s = this.fancybox.option("Image.touch"), o = t.$el.classList, n = this.fancybox.option("Image.canZoomInClass"), a = this.fancybox.option("Image.canZoomOutClass"); e && "toggleZoom" === i ? e && 1 === e.content.scale && e.option("maxScale") - e.content.scale > .01 ? (o.remove(a), o.add(n)) : e.content.scale > 1 && !s && o.add(a) : "close" === i && o.add(a) } onWheel(t, e) { if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", e)) switch (this.fancybox.option("Image.wheel")) { case "zoom": t.Panzoom && t.Panzoom.zoomWithWheel(e); break; case "close": this.fancybox.close(); break; case "slide": this.fancybox[e.deltaY < 0 ? "prev" : "next"]() } } onClick(t, e) { if ("ready" !== this.fancybox.state) return; const i = t.Panzoom; if (i && (i.dragPosition.midPoint || 0 !== i.dragOffset.x || 0 !== i.dragOffset.y || 1 !== i.dragOffset.scale)) return; if (this.fancybox.Carousel.Panzoom.lockAxis) return !1; const s = i => { switch (i) { case "toggleZoom": e.stopPropagation(), t.Panzoom && t.Panzoom.zoomWithClick(e); break; case "close": this.fancybox.close(); break; case "next": e.stopPropagation(), this.fancybox.next() } }, o = this.fancybox.option("Image.click"), n = this.fancybox.option("Image.doubleClick"); n ? this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null, s(n)) : this.clickTimer = setTimeout(() => { this.clickTimer = null, s(o) }, 300) : s(o) } onPageChange(t, e) { const i = t.getSlide(); e.slides.forEach(t => { t.Panzoom && "done" === t.state && t.index !== i.index && t.Panzoom.panTo({ x: 0, y: 0, scale: 1, friction: .8 }) }) } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events) } } P.defaults = { canZoomInClass: "can-zoom_in", canZoomOutClass: "can-zoom_out", zoom: !0, zoomOpacity: "auto", zoomFriction: .82, ignoreCoveredThumbnail: !1, touch: !0, click: "toggleZoom", doubleClick: null, wheel: "zoom", fit: "contain", wrap: !1, Panzoom: { ratio: 1 } }; const T = function () { const t = window.location.hash.substr(1), e = t.split("-"), i = e.length > 1 && /^\+?\d+$/.test(e[e.length - 1]) && parseInt(e.pop(-1), 10) || null; return { hash: t, slug: e.join("-"), index: i } }; class L { constructor(t) { this.fancybox = t; for (const e of ["onChange", "onClosing"]) this[e] = this[e].bind(this); this.events = { initCarousel: this.onChange, "Carousel.change": this.onChange, closing: this.onClosing }, this.hasCreatedHistory = !1, this.origHash = "", this.timer = null } onChange() { const t = this.fancybox, e = t.Carousel; this.timer && clearTimeout(this.timer); const i = null === e.prevPage, s = t.getSlide(), o = s.$trigger && s.$trigger.dataset, n = window.location.hash.substr(1); let a = !1; if (s.slug) a = s.slug; else { let t = o && o.fancybox; t && t.length && "true" !== t && (a = t + (e.slides.length > 1 ? "-" + (s.index + 1) : "")) } i && (this.origHash = n !== a ? this.origHash : ""), a && n !== a && (this.timer = setTimeout(() => { try { window.history[i ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + "#" + a), i && (this.hasCreatedHistory = !0) } catch (t) { } }, 300)) } onClosing() { if (this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose) { if (!this.hasCreatedHistory) try { return void window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash ? "#" + this.origHash : "")) } catch (t) { } window.history.back() } } attach(t) { t.on(this.events) } detach(t) { t.off(this.events) } static startFromUrl() { if (!L.Fancybox || L.Fancybox.getInstance()) return; const { hash: t, slug: e, index: i } = T(); if (!e) return; let s = document.querySelector(`[data-slug="${t}"]`); if (s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 })), L.Fancybox.getInstance()) return; const o = document.querySelectorAll(`[data-fancybox="${e}"]`); o.length && (null === i && 1 === o.length ? s = o[0] : i && (s = o[i - 1]), s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 }))) } static onHashChange() { const { slug: t, index: e } = T(), i = L.Fancybox.getInstance(); if (i) { if (t) { const s = i.Carousel; for (let e of s.slides) if (e.slug && e.slug === t) return s.slideTo(e.index); const o = i.getSlide(), n = o.$trigger && o.$trigger.dataset; if (n && n.fancybox === t) return s.slideTo(e - 1) } i.plugins.Hash.hasSilentClose = !0, i.close() } L.startFromUrl() } static create(t) { function e() { window.addEventListener("hashchange", L.onHashChange, !1), L.startFromUrl() } L.Fancybox = t, b && window.requestAnimationFrame(() => { /complete|interactive|loaded/.test(document.readyState) ? e() : document.addEventListener("DOMContentLoaded", e) }) } static destroy() { window.removeEventListener("hashchange", L.onHashChange, !1) } } const A = { pageXOffset: 0, pageYOffset: 0, element: () => document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement, activate(t) { A.pageXOffset = window.pageXOffset, A.pageYOffset = window.pageYOffset, t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen() }, deactivate() { document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() } }; class z { constructor(t) { this.fancybox = t, this.active = !1, this.handleVisibilityChange = this.handleVisibilityChange.bind(this) } isActive() { return this.active } setTimer() { if (!this.active || this.timer) return; const t = this.fancybox.option("slideshow.delay", 3e3); this.timer = setTimeout(() => { this.timer = null, this.fancybox.option("infinite") || this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1 ? this.fancybox.next() : this.fancybox.jumpTo(0, { friction: 0 }) }, t); let e = this.$progress; e || ((e = document.createElement("div")).classList.add("fancybox__progress"), this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel), this.$progress = e, e.offsetHeight), e.style.transitionDuration = `${t}ms`, e.style.transform = "scaleX(1)" } clearTimer() { clearTimeout(this.timer), this.timer = null, this.$progress && (this.$progress.style.transitionDuration = "", this.$progress.style.transform = "", this.$progress.offsetHeight) } activate() { this.active || (this.active = !0, this.fancybox.$container.classList.add("has-slideshow"), "done" === this.fancybox.getSlide().state && this.setTimer(), document.addEventListener("visibilitychange", this.handleVisibilityChange, !1)) } handleVisibilityChange() { this.deactivate() } deactivate() { this.active = !1, this.clearTimer(), this.fancybox.$container.classList.remove("has-slideshow"), document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1) } toggle() { this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate() } } const k = { display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"], autoEnable: !0, items: { counter: { type: "div", class: "fancybox__counter", html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>', tabindex: -1, position: "left" }, prev: { type: "button", class: "fancybox__button--prev", label: "PREV", html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>', attr: { "data-fancybox-prev": "" } }, next: { type: "button", class: "fancybox__button--next", label: "NEXT", html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>', attr: { "data-fancybox-next": "" } }, fullscreen: { type: "button", class: "fancybox__button--fullscreen", label: "TOGGLE_FULLSCREEN", html: '<svg viewBox="0 0 24 24">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>', click: function (t) { t.preventDefault(), A.element() ? A.deactivate() : A.activate(this.fancybox.$container) } }, slideshow: { type: "button", class: "fancybox__button--slideshow", label: "TOGGLE_SLIDESHOW", html: '<svg viewBox="0 0 24 24">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>', click: function (t) { t.preventDefault(), this.Slideshow.toggle() } }, zoom: { type: "button", class: "fancybox__button--zoom", label: "TOGGLE_ZOOM", html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>', click: function (t) { t.preventDefault(); const e = this.fancybox.getSlide().Panzoom; e && e.toggleZoom() } }, download: { type: "link", label: "DOWNLOAD", class: "fancybox__button--download", html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>', click: function (t) { t.stopPropagation() } }, thumbs: { type: "button", label: "TOGGLE_THUMBS", class: "fancybox__button--thumbs", html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>', click: function (t) { t.stopPropagation(); const e = this.fancybox.plugins.Thumbs; e && e.toggle() } }, close: { type: "button", label: "CLOSE", class: "fancybox__button--close", html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>', tabindex: 0, attr: { "data-fancybox-close": "" } } } }; class _ { constructor(t) { this.fancybox = t, this.$container = null, this.state = "init"; for (const e of ["onInit", "onPrepare", "onDone", "onKeydown", "onClosing", "onChange", "onSettle", "onRefresh"]) this[e] = this[e].bind(this); this.events = { init: this.onInit, prepare: this.onPrepare, done: this.onDone, keydown: this.onKeydown, closing: this.onClosing, "Carousel.change": this.onChange, "Carousel.settle": this.onSettle, "Carousel.Panzoom.touchStart": () => this.onRefresh(), "Image.startAnimation": (t, e) => this.onRefresh(e), "Image.afterUpdate": (t, e) => this.onRefresh(e) } } onInit() { if (this.fancybox.option("Toolbar.autoEnable")) { let t = !1; for (const e of this.fancybox.items) if ("image" === e.type) { t = !0; break } if (!t) return void (this.state = "disabled") } for (const e of this.fancybox.option("Toolbar.display")) if ("close" === (t(e) ? e.id : e)) { this.fancybox.options.closeButton = !1; break } } onPrepare() { const t = this.fancybox; if ("init" === this.state && (this.build(), this.update(), this.Slideshow = new z(t), !t.Carousel.prevPage && (t.option("slideshow.autoStart") && this.Slideshow.activate(), t.option("fullscreen.autoStart") && !A.element()))) try { A.activate(t.$container) } catch (t) { } } onFsChange() { window.scrollTo(A.pageXOffset, A.pageYOffset) } onSettle() { const t = this.fancybox, e = this.Slideshow; e && e.isActive() && (t.getSlide().index !== t.Carousel.slides.length - 1 || t.option("infinite") ? "done" === t.getSlide().state && e.setTimer() : e.deactivate()) } onChange() { this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer() } onDone(t, e) { const i = this.Slideshow; e.index === t.getSlide().index && (this.update(), i && i.isActive() && (t.option("infinite") || e.index !== t.Carousel.slides.length - 1 ? i.setTimer() : i.deactivate())) } onRefresh(t) { t && t.index !== this.fancybox.getSlide().index || (this.update(), !this.Slideshow || !this.Slideshow.isActive() || t && "done" !== t.state || this.Slideshow.deactivate()) } onKeydown(t, e, i) { " " === e && this.Slideshow && (this.Slideshow.toggle(), i.preventDefault()) } onClosing() { this.Slideshow && this.Slideshow.deactivate(), document.removeEventListener("fullscreenchange", this.onFsChange) } createElement(t) { let e; "div" === t.type ? e = document.createElement("div") : (e = document.createElement("link" === t.type ? "a" : "button")).classList.add("carousel__button"), e.innerHTML = t.html, e.setAttribute("tabindex", t.tabindex || 0), t.class && e.classList.add(...t.class.split(" ")); for (let s in t.attr) e.setAttribute(s, t[s]); t.label && e.setAttribute("title", this.fancybox.localize(`{{${t.label}}}`)), t.click && e.addEventListener("click", t.click.bind(this)), "prev" === t.id && e.setAttribute("data-fancybox-prev", ""), "next" === t.id && e.setAttribute("data-fancybox-next", ""); const i = e.querySelector("svg"); return i && (i.setAttribute("role", "img"), i.setAttribute("tabindex", "-1"), i.setAttribute("xmlns", "http://www.w3.org/2000/svg")), e } build() { this.cleanup(); const i = this.fancybox.option("Toolbar.items"), s = [{ position: "left", items: [] }, { position: "center", items: [] }, { position: "right", items: [] }], o = this.fancybox.plugins.Thumbs; for (const a of this.fancybox.option("Toolbar.display")) { let n, r; if (t(a) ? (n = a.id, r = e({}, i[n], a)) : r = i[n = a], ["counter", "next", "prev", "slideshow"].includes(n) && this.fancybox.items.length < 2) continue; if ("fullscreen" === n) { if (!document.fullscreenEnabled || window.fullScreen) continue; document.addEventListener("fullscreenchange", this.onFsChange) } if ("thumbs" === n && (!o || "disabled" === o.state)) continue; if (!r) continue; let l = r.position || "right", h = s.find(t => t.position === l); h && h.items.push(r) } const n = document.createElement("div"); n.classList.add("fancybox__toolbar"); for (const t of s) if (t.items.length) { const e = document.createElement("div"); e.classList.add("fancybox__toolbar__items"), e.classList.add(`fancybox__toolbar__items--${t.position}`); for (const i of t.items) e.appendChild(this.createElement(i)); n.appendChild(e) } this.fancybox.$carousel.parentNode.insertBefore(n, this.fancybox.$carousel), this.$container = n } update() { const t = this.fancybox.getSlide(), e = t.index, i = this.fancybox.items.length, s = t.downloadSrc || ("image" !== t.type || t.error ? null : t.src); for (const a of this.fancybox.$container.querySelectorAll("a.fancybox__button--download")) s ? (a.removeAttribute("disabled"), a.removeAttribute("tabindex"), a.setAttribute("href", s), a.setAttribute("download", s), a.setAttribute("target", "_blank")) : (a.setAttribute("disabled", ""), a.setAttribute("tabindex", -1), a.removeAttribute("href"), a.removeAttribute("download")); const o = t.Panzoom, n = o && o.option("maxScale") > o.option("baseScale"); for (const a of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom")) n ? a.removeAttribute("disabled") : a.setAttribute("disabled", ""); for (const a of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) a.innerHTML = t.index + 1; for (const a of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) a.innerHTML = i; if (!this.fancybox.option("infinite")) { for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]")) 0 === e ? t.setAttribute("disabled", "") : t.removeAttribute("disabled"); for (const t of this.fancybox.$container.querySelectorAll("[data-fancybox-next]")) e === i - 1 ? t.setAttribute("disabled", "") : t.removeAttribute("disabled") } } cleanup() { this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(), this.$container && this.$container.remove(), this.$container = null } attach() { this.fancybox.on(this.events) } detach() { this.fancybox.off(this.events), this.cleanup() } } _.defaults = k; const O = { ScrollLock: class { constructor(t) { this.fancybox = t, this.viewport = null, this.pendingUpdate = null; for (const e of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) this[e] = this[e].bind(this) } onReady() { const t = window.visualViewport; t && (this.viewport = t, this.startY = 0, t.addEventListener("resize", this.onResize), this.updateViewport()), window.addEventListener("touchstart", this.onTouchstart, { passive: !1 }), window.addEventListener("touchmove", this.onTouchmove, { passive: !1 }) } onResize() { this.updateViewport() } updateViewport() { const t = this.fancybox, e = this.viewport, i = e.scale || 1, s = t.$container; if (!s) return; let o = "", n = "", a = ""; i - 1 > .1 && (o = e.width * i + "px", n = e.height * i + "px", a = `translate3d(${e.offsetLeft}px, ${e.offsetTop}px, 0) scale(${1 / i})`), s.style.width = o, s.style.height = n, s.style.transform = a } onTouchstart(t) { this.startY = t.touches ? t.touches[0].screenY : t.screenY } onTouchmove(t) { const e = this.startY, i = window.innerWidth / window.document.documentElement.clientWidth; if (!t.cancelable) return; if (t.touches.length > 1 || 1 !== i) return; const s = t.target, o = l(s); if (!o) return void t.preventDefault(); const n = window.getComputedStyle(o), a = parseInt(n.getPropertyValue("height"), 10), r = t.touches ? t.touches[0].screenY : t.screenY, h = e <= r && 0 === o.scrollTop, c = e >= r && o.scrollHeight - o.scrollTop === a; (h || c) && t.preventDefault() } cleanup() { this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), this.pendingUpdate = null); const t = this.viewport; t && (t.removeEventListener("resize", this.onResize), this.viewport = null), window.removeEventListener("touchstart", this.onTouchstart, !1), window.removeEventListener("touchmove", this.onTouchmove, !1) } attach() { this.fancybox.on("initLayout", this.onReady) } detach() { this.fancybox.off("initLayout", this.onReady), this.cleanup() } }, Thumbs: $, Html: E, Toolbar: _, Image: P, Hash: L }, M = { startIndex: 0, preload: 1, infinite: !0, showClass: "fancybox-zoomInUp", hideClass: "fancybox-fadeOut", animated: !0, hideScrollbar: !0, parentEl: null, mainClass: null, autoFocus: !0, trapFocus: !0, placeFocusBack: !0, click: "close", closeButton: "inside", dragToClose: !0, keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "next", ArrowDown: "prev", ArrowRight: "next", ArrowLeft: "prev" }, template: { closeButton: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>', spinner: '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>', main: null }, l10n: { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" } }, I = {}; let F = 0; class R extends h { constructor(t, i = {}) { super(e(!0, {}, M, i)), this.bindHandlers(), this.state = "init", this.setItems(t), this.attachPlugins(R.Plugins), this.trigger("init"), !0 === this.option("hideScrollbar") && this.hideScrollbar(), this.initLayout(), this.initCarousel(), this.attachEvents(), I[this.id] = this, this.trigger("prepare"), this.state = "ready", this.trigger("ready"), this.$container.setAttribute("aria-hidden", "false"), this.option("trapFocus") && this.focus() } bindHandlers() { for (const t of ["onMousedown", "onKeydown", "onClick", "onFocus", "onCreateSlide", "onSettle", "onTouchMove", "onTouchEnd", "onTransform"]) this[t] = this[t].bind(this) } attachEvents() { document.addEventListener("mousedown", this.onMousedown), document.addEventListener("keydown", this.onKeydown, !0), this.option("trapFocus") && document.addEventListener("focus", this.onFocus, !0), this.$container.addEventListener("click", this.onClick) } detachEvents() { document.removeEventListener("mousedown", this.onMousedown), document.removeEventListener("keydown", this.onKeydown, !0), document.removeEventListener("focus", this.onFocus, !0), this.$container.removeEventListener("click", this.onClick) } initLayout() { this.$root = this.option("parentEl") || document.body; let t = this.option("template.main"); t && (this.$root.insertAdjacentHTML("beforeend", this.localize(t)), this.$container = this.$root.querySelector(".fancybox__container")), this.$container || (this.$container = document.createElement("div"), this.$root.appendChild(this.$container)), this.$container.onscroll = (() => (this.$container.scrollLeft = 0, !1)), Object.entries({ class: "fancybox__container", role: "dialog", tabIndex: "-1", "aria-modal": "true", "aria-hidden": "true", "aria-label": this.localize("{{MODAL}}") }).forEach(t => this.$container.setAttribute(...t)), this.option("animated") && this.$container.classList.add("is-animated"), this.$backdrop = this.$container.querySelector(".fancybox__backdrop"), this.$backdrop || (this.$backdrop = document.createElement("div"), this.$backdrop.classList.add("fancybox__backdrop"), this.$container.appendChild(this.$backdrop)), this.$carousel = this.$container.querySelector(".fancybox__carousel"), this.$carousel || (this.$carousel = document.createElement("div"), this.$carousel.classList.add("fancybox__carousel"), this.$container.appendChild(this.$carousel)), this.$container.Fancybox = this, this.id = this.$container.getAttribute("id"), this.id || (this.id = this.options.id || ++F, this.$container.setAttribute("id", "fancybox-" + this.id)); const e = this.options.mainClass; return e && this.$container.classList.add(...e.split(" ")), document.documentElement.classList.add("with-fancybox"), this.trigger("initLayout"), this } setItems(t) { const e = []; for (const i of t) { const t = i.$trigger; if (t) { const e = t.dataset || {}; i.src = e.src || t.getAttribute("href") || i.src, i.type = e.type || i.type, !i.src && t instanceof HTMLImageElement && (i.src = t.currentSrc || i.$trigger.src) } let s = i.$thumb; if (!s) { let t = i.$trigger && i.$trigger.origTarget; t && (s = t instanceof HTMLImageElement ? t : t.querySelector("img")), !s && i.$trigger && (s = i.$trigger instanceof HTMLImageElement ? i.$trigger : i.$trigger.querySelector("img")) } i.$thumb = s || null; let o = i.thumb; !o && s && (!(o = s.currentSrc || s.src) && s.dataset && (o = s.dataset.lazySrc || s.dataset.src)), o || "image" !== i.type || (o = i.src), i.thumb = o || null, i.caption = i.caption || "", e.push(i) } this.items = e } initCarousel() { return this.Carousel = new y(this.$carousel, e(!0, {}, { prefix: "", classNames: { viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" }, textSelection: !0, preload: this.option("preload"), friction: .88, slides: this.items, initialPage: this.options.startIndex, slidesPerPage: 1, infiniteX: this.option("infinite"), infiniteY: !0, l10n: this.option("l10n"), Dots: !1, Navigation: { classNames: { main: "fancybox__nav", button: "carousel__button", next: "is-next", prev: "is-prev" } }, Panzoom: { textSelection: !0, panOnlyZoomed: () => this.Carousel && this.Carousel.pages && this.Carousel.pages.length < 2 && !this.options.dragToClose, lockAxis: () => { if (this.Carousel) { let t = "x"; return this.options.dragToClose && (t += "y"), t } } }, on: { "*": (t, ...e) => this.trigger(`Carousel.${t}`, ...e), init: t => this.Carousel = t, createSlide: this.onCreateSlide, settle: this.onSettle } }, this.option("Carousel"))), this.option("dragToClose") && this.Carousel.Panzoom.on({ touchMove: this.onTouchMove, afterTransform: this.onTransform, touchEnd: this.onTouchEnd }), this.trigger("initCarousel"), this } onCreateSlide(t, e) { let i = e.caption || ""; if ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, e)), "string" == typeof i && i.length) { const t = document.createElement("div"), s = `fancybox__caption_${this.id}_${e.index}`; t.className = "fancybox__caption", t.innerHTML = i, t.setAttribute("id", s), e.$caption = e.$el.appendChild(t), e.$el.classList.add("has-caption"), e.$el.setAttribute("aria-labelledby", s) } } onSettle() { this.option("autoFocus") && this.focus() } onFocus(t) { this.focus(t) } onClick(t) { if (t.defaultPrevented) return; let e = t.target; if (e.matches("[data-fancybox-close]")) return t.preventDefault(), void R.close(!1); if (e.matches("[data-fancybox-next]")) return t.preventDefault(), void R.next(); if (e.matches("[data-fancybox-prev]")) return t.preventDefault(), void R.prev(); if (!e.closest(".fancybox__content") && !getSelection().toString().length && !1 !== this.trigger("click", t)) switch (this.option("click")) { case "close": this.close(); break; case "next": this.next() } } onTouchMove() { const t = this.getSlide().Panzoom; return !t || 1 === t.content.scale } onTouchEnd(t) { const e = t.dragOffset.y; Math.abs(e) >= 150 || Math.abs(e) >= 35 && t.dragOffset.time < 350 ? (this.option("hideClass") && (this.getSlide().hideClass = "fancybox-throwOut" + (t.content.y < 0 ? "Up" : "Down")), this.close()) : "y" === t.lockAxis && t.panTo({ y: 0 }) } onTransform(t) { if (this.$backdrop) { const e = Math.abs(t.content.y), i = e < 1 ? "" : Math.max(.33, Math.min(1, 1 - e / t.content.fitHeight * 1.5)); this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""), this.$container.style.setProperty("--fancybox-opacity", i) } } onMousedown() { "ready" === this.state && document.body.classList.add("is-using-mouse") } onKeydown(t) { if (R.getInstance().id !== this.id) return; document.body.classList.remove("is-using-mouse"); const e = t.key, i = this.option("keyboard"); if (!i || t.ctrlKey || t.altKey || t.shiftKey) return; const s = document.activeElement && document.activeElement.classList, o = s && s.contains("carousel__button"); if ("Escape" !== e && !o && (t.target.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(t.target.nodeName))) return; if (!1 === this.trigger("keydown", e, t)) return; const n = i[e]; "function" == typeof this[n] && this[n]() } getSlide() { const t = this.Carousel; if (!t) return null; const e = null === t.page ? t.option("initialPage") : t.page, i = t.pages || []; return i.length && i[e] ? i[e].slides[0] : null } focus(t) { if (R.ignoreFocusChange) return; if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) return; t && t.preventDefault(), R.ignoreFocusChange = !0; const e = this.$container, i = this.getSlide(), s = "done" === i.state ? i.$el : null, o = Array.from(e.querySelectorAll(x)); let n, a = []; for (let r of o) { const t = r.offsetParent, e = s && s.contains(r), i = !this.Carousel.$viewport.contains(r); t && (e || i) ? (a.push(r), void 0 !== r.dataset.origTabindex && (r.tabIndex = r.dataset.origTabindex, r.removeAttribute("data-orig-tabindex")), (r.hasAttribute("autoFocus") || !n && e && !r.classList.contains("carousel__button")) && (n = r)) : (r.dataset.origTabindex = void 0 === r.dataset.origTabindex ? r.getAttribute("tabindex") : r.dataset.origTabindex, r.tabIndex = -1) } t ? a.indexOf(t.target) > -1 ? this.lastFocus = t.target : this.lastFocus === e ? w(a[a.length - 1]) : w(e) : this.option("autoFocus") && n ? w(n) : a.indexOf(document.activeElement) < 0 && w(e), this.lastFocus = document.activeElement, R.ignoreFocusChange = !1 } hideScrollbar() { if (!b) return; const t = window.innerWidth - document.documentElement.getBoundingClientRect().width, e = "fancybox-style-noscroll"; let i = document.getElementById(e); i || t > 0 && ((i = document.createElement("style")).id = e, i.type = "text/css", i.innerHTML = `.compensate-for-scrollbar {padding-right: ${t}px;}`, document.getElementsByTagName("head")[0].appendChild(i), document.body.classList.add("compensate-for-scrollbar")) } revealScrollbar() { document.body.classList.remove("compensate-for-scrollbar"); const t = document.getElementById("fancybox-style-noscroll"); t && t.remove() } clearContent(t) { this.Carousel.trigger("removeSlide", t), t.$content && (t.$content.remove(), t.$content = null), t.$closeButton && (t.$closeButton.remove(), t.$closeButton = null), t._className && t.$el.classList.remove(t._className) } setContent(t, e, i = {}) { let s; const o = t.$el; if (e instanceof HTMLElement) ["img", "iframe", "video", "audio"].indexOf(e.nodeName.toLowerCase()) > -1 ? (s = document.createElement("div")).appendChild(e) : s = e; else { const t = document.createRange().createContextualFragment(e); (s = document.createElement("div")).appendChild(t) } if (t.filter && !t.error && (s = s.querySelector(t.filter)), s instanceof Element) return t._className = `has-${i.suffix || t.type || "unknown"}`, o.classList.add(t._className), s.classList.add("fancybox__content"), "none" !== s.style.display && "none" !== getComputedStyle(s).getPropertyValue("display") || (s.style.display = t.display || this.option("defaultDisplay") || "flex"), t.id && s.setAttribute("id", t.id), t.$content = s, o.prepend(s), this.manageCloseButton(t), "loading" !== t.state && this.revealContent(t), s; this.setError(t, "{{ELEMENT_NOT_FOUND}}") } manageCloseButton(t) { const e = void 0 === t.closeButton ? this.option("closeButton") : t.closeButton; if (!e || "top" === e && this.$closeButton) return; const i = document.createElement("button"); i.classList.add("carousel__button", "is-close"), i.setAttribute("title", this.options.l10n.CLOSE), i.innerHTML = this.option("template.closeButton"), i.addEventListener("click", t => this.close(t)), "inside" === e ? (t.$closeButton && t.$closeButton.remove(), t.$closeButton = t.$content.appendChild(i)) : this.$closeButton = this.$container.insertBefore(i, this.$container.firstChild) } revealContent(t) { this.trigger("reveal", t), t.$content.style.visibility = ""; let e = !1; t.error || "loading" === t.state || null !== this.Carousel.prevPage || t.index !== this.options.startIndex || (e = void 0 === t.showClass ? this.option("showClass") : t.showClass), e ? (t.state = "animating", this.animateCSS(t.$content, e, () => { this.done(t) })) : this.done(t) } animateCSS(t, e, i) { if (t && t.dispatchEvent(new CustomEvent("animationend", { bubbles: !0, cancelable: !0 })), !t || !e) return void ("function" == typeof i && i()); const s = function (o) { o.currentTarget === this && (t.removeEventListener("animationend", s), i && i(), t.classList.remove(e)) }; t.addEventListener("animationend", s), t.classList.add(e) } done(t) { t.state = "done", this.trigger("done", t); const e = this.getSlide(); e && t.index === e.index && this.option("autoFocus") && this.focus() } setError(t, e) { t.error = e, this.hideLoading(t), this.clearContent(t); const i = document.createElement("div"); i.classList.add("fancybox-error"), i.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), this.setContent(t, i, { suffix: "error" }) } showLoading(t) { t.state = "loading", t.$el.classList.add("is-loading"); let e = t.$el.querySelector(".fancybox__spinner"); e || ((e = document.createElement("div")).classList.add("fancybox__spinner"), e.innerHTML = this.option("template.spinner"), e.addEventListener("click", () => { this.Carousel.Panzoom.velocity || this.close() }), t.$el.prepend(e)) } hideLoading(t) { const e = t.$el && t.$el.querySelector(".fancybox__spinner"); e && (e.remove(), t.$el.classList.remove("is-loading")), "loading" === t.state && (this.trigger("load", t), t.state = "ready") } next() { const t = this.Carousel; t && t.pages.length > 1 && t.slideNext() } prev() { const t = this.Carousel; t && t.pages.length > 1 && t.slidePrev() } jumpTo(...t) { this.Carousel && this.Carousel.slideTo(...t) } close(t) { if (t && t.preventDefault(), ["closing", "customClosing", "destroy"].includes(this.state)) return; if (!1 === this.trigger("shouldClose", t)) return; if (this.state = "closing", this.Carousel.Panzoom.destroy(), this.detachEvents(), this.trigger("closing", t), "destroy" === this.state) return; this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing"); const e = this.getSlide(); if (this.Carousel.slides.forEach(t => { t.$content && t.index !== e.index && this.Carousel.trigger("removeSlide", t) }), "closing" === this.state) { const t = void 0 === e.hideClass ? this.option("hideClass") : e.hideClass; this.animateCSS(e.$content, t, () => { this.destroy() }, !0) } } destroy() { if ("destroy" === this.state) return; this.state = "destroy", this.trigger("destroy"); const t = this.option("placeFocusBack") ? this.getSlide().$trigger : null; this.Carousel.destroy(), this.detachPlugins(), this.Carousel = null, this.options = {}, this.events = {}, this.$container.remove(), this.$container = this.$backdrop = this.$carousel = null, t && w(t), delete I[this.id]; const e = R.getInstance(); e ? e.focus() : (document.documentElement.classList.remove("with-fancybox"), document.body.classList.remove("is-using-mouse"), this.revealScrollbar()) } static show(t, e = {}) { return new R(t, e) } static fromEvent(t, e = {}) { if (t.defaultPrevented) return; if (t.button && 0 !== t.button) return; if (t.ctrlKey || t.metaKey || t.shiftKey) return; let i, s, o, n = t.target; if ((n.matches("[data-fancybox-trigger]") || (n = n.closest("[data-fancybox-trigger]"))) && (i = n && n.dataset && n.dataset.fancyboxTrigger), i) { const t = document.querySelectorAll(`[data-fancybox="${i}"]`), e = parseInt(n.dataset.fancyboxIndex, 10) || 0; n = t.length ? t[e] : n } n || (n = t.target), Array.from(R.openers.keys()).reverse().some(e => { o = n; let i = !1; try { o instanceof Element && ("string" == typeof e || e instanceof String) && (i = o.matches(e) || (o = o.closest(e))) } catch (t) { } return !!i && (t.preventDefault(), s = e, !0) }); let a = !1; if (s) { e.event = t, e.target = o, o.origTarget = t.target, a = R.fromOpener(s, e); const i = R.getInstance(); i && "ready" === i.state && t.detail && document.body.classList.add("is-using-mouse") } return a } static fromOpener(t, i = {}) { let s = [], o = i.startIndex || 0, n = i.target || null; const a = void 0 !== (i = e({}, i, R.openers.get(t))).groupAll && i.groupAll, r = void 0 === i.groupAttr ? "data-fancybox" : i.groupAttr, l = r && n ? n.getAttribute(`${r}`) : ""; if ((!n || l || a) && (s = [].slice.call(document.querySelectorAll(t))), n && !a && (s = l ? s.filter(t => t.getAttribute(`${r}`) === l) : [n]), !s.length) return !1; const h = R.getInstance(); return !(h && s.indexOf(h.options.$trigger) > -1) && (o = n ? s.indexOf(n) : o, s = s.map(function (t) { const e = ["false", "0", "no", "null", "undefined"], i = ["true", "1", "yes"], s = Object.assign({}, t.dataset), o = {}; for (let [n, a] of Object.entries(s)) if ("fancybox" !== n) if ("width" === n || "height" === n) o[`_${n}`] = a; else if ("string" == typeof a || a instanceof String) if (e.indexOf(a) > -1) o[n] = !1; else if (i.indexOf(o[n]) > -1) o[n] = !0; else try { o[n] = JSON.parse(a) } catch (e) { o[n] = a } else o[n] = a; return t instanceof Element && (o.$trigger = t), o }), new R(s, e({}, i, { startIndex: o, $trigger: n }))) } static bind(t, e = {}) { function i() { document.body.addEventListener("click", R.fromEvent, !1) } b && (R.openers.size || (/complete|interactive|loaded/.test(document.readyState) ? i() : document.addEventListener("DOMContentLoaded", i)), R.openers.set(t, e)) } static unbind(t) { R.openers.delete(t), R.openers.size || R.destroy() } static destroy() { let t; for (; t = R.getInstance();)t.destroy(); R.openers = new Map, document.body.removeEventListener("click", R.fromEvent, !1) } static getInstance(t) { return t ? I[t] : Object.values(I).reverse().find(t => !["closing", "customClosing", "destroy"].includes(t.state) && t) || null } static close(t = !0) { let e = null; for (; e = R.getInstance();)if (e.close(), !t) return } static next() { const t = R.getInstance(); t && t.next() } static prev() { const t = R.getInstance(); t && t.prev() } } exports.Fancybox = R, R.version = "4.0.12", R.defaults = M, R.openers = new Map, R.Plugins = O, R.bind("[data-fancybox]"); for (const [N, D] of Object.entries(R.Plugins || {})) "function" == typeof D.create && D.create(R);
    }, {}], "BQvw": [function (require, module, exports) {
        var define;
        var global = arguments[3];
        var t, e = arguments[3]; !function (e, n) { "function" == typeof t && t.amd ? t(n) : "object" == typeof module && module.exports ? module.exports = n() : e.EvEmitter = n() }("undefined" != typeof window ? window : this, function () { "use strict"; function t() { } var e = t.prototype; return e.on = function (t, e) { if (t && e) { var n = this._events = this._events || {}, i = n[t] = n[t] || []; return -1 == i.indexOf(e) && i.push(e), this } }, e.once = function (t, e) { if (t && e) { this.on(t, e); var n = this._onceEvents = this._onceEvents || {}; return (n[t] = n[t] || {})[e] = !0, this } }, e.off = function (t, e) { var n = this._events && this._events[t]; if (n && n.length) { var i = n.indexOf(e); return -1 != i && n.splice(i, 1), this } }, e.emitEvent = function (t, e) { var n = this._events && this._events[t]; if (n && n.length) { n = n.slice(0), e = e || []; for (var i = this._onceEvents && this._onceEvents[t], s = 0; s < n.length; s++) { var o = n[s]; i && i[o] && (this.off(t, o), delete i[o]), o.apply(this, e) } return this } }, e.allOff = function () { delete this._events, delete this._onceEvents }, t });
    }, {}], "lc7f": [function (require, module, exports) {
        var define;
        var t; !function (e, i) { "use strict"; "function" == typeof t && t.amd ? t(["ev-emitter/ev-emitter"], function (t) { return i(e, t) }) : "object" == typeof module && module.exports ? module.exports = i(e, require("ev-emitter")) : e.imagesLoaded = i(e, e.EvEmitter) }("undefined" != typeof window ? window : this, function (t, e) { "use strict"; var i = t.jQuery, o = t.console; function r(t, e) { for (var i in e) t[i] = e[i]; return t } var s = Array.prototype.slice; function n(t, e, h) { if (!(this instanceof n)) return new n(t, e, h); var a, m = t; ("string" == typeof t && (m = document.querySelectorAll(t)), m) ? (this.elements = (a = m, Array.isArray(a) ? a : "object" == typeof a && "number" == typeof a.length ? s.call(a) : [a]), this.options = r({}, this.options), "function" == typeof e ? h = e : r(this.options, e), h && this.on("always", h), this.getImages(), i && (this.jqDeferred = new i.Deferred), setTimeout(this.check.bind(this))) : o.error("Bad element for imagesLoaded " + (m || t)) } n.prototype = Object.create(e.prototype), n.prototype.options = {}, n.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, n.prototype.addElementImages = function (t) { "IMG" == t.nodeName && this.addImage(t), !0 === this.options.background && this.addElementBackgroundImages(t); var e = t.nodeType; if (e && h[e]) { for (var i = t.querySelectorAll("img"), o = 0; o < i.length; o++) { var r = i[o]; this.addImage(r) } if ("string" == typeof this.options.background) { var s = t.querySelectorAll(this.options.background); for (o = 0; o < s.length; o++) { var n = s[o]; this.addElementBackgroundImages(n) } } } }; var h = { 1: !0, 9: !0, 11: !0 }; function a(t) { this.img = t } function m(t, e) { this.url = t, this.element = e, this.img = new Image } return n.prototype.addElementBackgroundImages = function (t) { var e = getComputedStyle(t); if (e) for (var i = /url\((['"])?(.*?)\1\)/gi, o = i.exec(e.backgroundImage); null !== o;) { var r = o && o[2]; r && this.addBackground(r, t), o = i.exec(e.backgroundImage) } }, n.prototype.addImage = function (t) { var e = new a(t); this.images.push(e) }, n.prototype.addBackground = function (t, e) { var i = new m(t, e); this.images.push(i) }, n.prototype.check = function () { var t = this; function e(e, i, o) { setTimeout(function () { t.progress(e, i, o) }) } this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? this.images.forEach(function (t) { t.once("progress", e), t.check() }) : this.complete() }, n.prototype.progress = function (t, e, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent("progress", [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount == this.images.length && this.complete(), this.options.debug && o && o.log("progress: " + i, t, e) }, n.prototype.complete = function () { var t = this.hasAnyBroken ? "fail" : "done"; if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent("always", [this]), this.jqDeferred) { var e = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[e](this) } }, a.prototype = Object.create(e.prototype), a.prototype.check = function () { this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.proxyImage.src = this.img.src) }, a.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, a.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent("progress", [this, this.img, e]) }, a.prototype.handleEvent = function (t) { var e = "on" + t.type; this[e] && this[e](t) }, a.prototype.onload = function () { this.confirm(!0, "onload"), this.unbindEvents() }, a.prototype.onerror = function () { this.confirm(!1, "onerror"), this.unbindEvents() }, a.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, m.prototype = Object.create(a.prototype), m.prototype.check = function () { this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents()) }, m.prototype.unbindEvents = function () { this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, m.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent("progress", [this, this.element, e]) }, n.makeJQueryPlugin = function (e) { (e = e || t.jQuery) && ((i = e).fn.imagesLoaded = function (t, e) { return new n(this, t, e).jqDeferred.promise(i(this)) }) }, n.makeJQueryPlugin(), n });
    }, { "ev-emitter": "BQvw" }], "sCyn": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.SingleProject = void 0; var e = d(require("gsap")), t = require("gsap/ScrollTrigger"), r = require("@fancyapps/ui"), o = d(require("imagesloaded")), n = require("./utils/utils"), i = require("./navbar"), l = require("./footer-waves"), a = require("./magnetic"), s = d(require("./Cursor")), c = d(require("./constants/global")), u = d(require("./Bubble")), f = d(require("./SmoothScroll")); function d(e) { return e && e.__esModule ? e : { default: e } } function h(e) { return v(e) || p(e) || m(e) || g() } function g() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function m(e, t) { if (e) { if ("string" == typeof e) return y(e, t); var r = Object.prototype.toString.call(e).slice(8, -1); return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? y(e, t) : void 0 } } function p(e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) } function v(e) { if (Array.isArray(e)) return y(e) } function y(e, t) { (null == t || t > e.length) && (t = e.length); for (var r = 0, o = new Array(t); r < t; r++)o[r] = e[r]; return o } function b(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function w(e, t) { for (var r = 0; r < t.length; r++) { var o = t[r]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } function S(e, t, r) { return t && w(e.prototype, t), r && w(e, r), e } function E(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } e.default.registerPlugin(t.ScrollTrigger); var q = function () { function t(e, r) { b(this, t), E(this, "percentageOfElementInViewport", function (e) { var t = window.pageYOffset, r = window.pageYOffset + window.innerHeight, o = e.getBoundingClientRect(), n = o.y + window.pageYOffset, i = o.y + o.height + window.pageYOffset; if (t > i || r < n) return 0; if (t < n && r > i) return 100; if (n < t && i > r) return 100; var l = o.height, a = l; n < t && (a = l - (window.pageYOffset - n)), i > r && (a -= i - r); var s = a / window.innerHeight * 100; return Math.round(s) }), n.bindMethods.call(this), this.stage = e, this.bird = r, this.magneticSocialHover, this.magneticEmailHover, this.smoothScrollInterval, this.scrollTimeout } return S(t, [{ key: "init", value: function () { document.querySelector("html").classList.remove("stop-scroll"), c.default.isMobile || this.heroSticky(), this.bird.flying(); var t = document.querySelector(".audio-toggle"); if (e.default.to(t, { visibility: "visible", pointerEvents: "all" }), (0, i.showHeader)(), (0, i.navbarLinksAnimation)(), this.dynamicSloganKill = (0, i.dynamicSlogan)(), (0, i.headerFixer)(), !c.default.isMobile) { c.default.cursor && (c.default.cursor.destroy(), c.default.cursor = null); var r = setTimeout(function () { c.default.cursor = new s.default(".back-to-home"), e.default.set(".bubbles-cursor", { opacity: 0 }), clearTimeout(r) }) } this.footerWavesKill = (0, l.footerWaves)(); var u = document.querySelector(".footer"); if (this.magneticSocialHover = (0, a.magneticItemHover)(".social"), this.magneticEmailHover = (0, a.magneticItemHover)(".footer .email", .2), (0, n.css)(u, "opacity", 1), (0, n.css)(u, "pointerEvents", "all"), this.showUpPostContentElements(), this.relatedPostBubble(), !c.default.isMobile) { window.addEventListener("scroll", this.onPageScroll, !1), this.smoothScroll = new f.default; var d = this.smoothScroll, h = document.querySelectorAll(".post-content img"); (0, o.default)(h, function () { d.setSize() }), this.smoothScrollInterval = setInterval(function () { d.setSize() }, 3e3) } this.projectScrollUp() } }, { key: "heroSticky", value: function () { var t = navigator.vendor.match(/apple/i) && !navigator.userAgent.match(/crios/i) && !navigator.userAgent.match(/fxios/i) && !navigator.userAgent.match(/Opera|OPT\//), r = document.querySelector(".hero-sections-parent"); e.default.fromTo(".hero-sections-parent", { y: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: 0, end: 1.8 * r.scrollHeight, scrub: .1 }, y: -2.62 * window.innerHeight }), e.default.fromTo([".hero-sections-parent .background-hero", ".hero-sections-parent .foreground-hero"], { yPercent: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: 0, end: r.scrollHeight, scrub: .1 }, yPercent: t ? 20 : 140 }) } }, { key: "showUpPostContentElements", value: function () { var e = new IntersectionObserver(this.onIntersectionChange, { root: null, rootMargin: "0px", threshold: .17 }), t = document.querySelectorAll(".post-content > *"); Array.from(t).forEach(function (t) { return e.observe(t) }) } }, { key: "onPageScroll", value: function () { clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout(this.getVisibleItemsInViewport, 1e3) } }, { key: "getVisibleItemsInViewport", value: function () { var e = this, t = document.querySelectorAll(".post-content > *"), r = Array.from(t).map(function (t) { if (!t.children.length) return null; if (t.parentElement.classList.contains("post-content") && e.isElementPartiallyInViewport(t)) return { el: t, percentage: e.percentageOfElementInViewport(t) }; return null }).filter(function (e) { return !!e }); console.log(r); var o = r.map(function (e) { return e.percentage }), n = Math.max.apply(Math, h(o)), i = r.filter(function (e) { return e.percentage === n }).pop(); if (null == i ? void 0 : i.el) { var l = i.el; this.stickScrollToElement(l) } } }, { key: "isElementPartiallyInViewport", value: function (e) { var t = e.getBoundingClientRect(), r = window.innerHeight || document.documentElement.clientHeight, o = window.innerWidth || document.documentElement.clientWidth, n = t.top <= r && t.top + t.height >= 0, i = t.left <= o && t.left + t.width >= 0; return n && i } }, { key: "stickScrollToElement", value: function (e) { if (e !== e.parentNode.children[e.parentNode.children.length - 1] && e !== e.parentNode.children[0]) { var t = e.getBoundingClientRect(), r = (window.innerHeight - t.height) / 2, o = t.top + window.scrollY; t.height > window.innerHeight || window.scrollTo({ top: o - r }) } } }, { key: "onIntersectionChange", value: function (t, r) { t.forEach(function (t) { t.intersectionRatio > 0 && (e.default.to(t.target, { opacity: 1, y: 0, duration: .4 }), r.unobserve(t.target)) }) } }, { key: "initializeFancybox", value: function () { var e = document.querySelectorAll("figure"); Array.from(e).forEach(function (e) { var t = e.querySelector("img"), o = document.createElement("a"); o.href = t.src, o.setAttribute("data-srcset", t.srcset), o.setAttribute("data-sizes", t.sizes), o.setAttribute("data-fancybox", "single"), o.onclick = function (e) { e.preventDefault(); var o = [{ src: t.src, thumb: t.src }]; return r.Fancybox.show(o), !1 }, e.append(o) }) } }, { key: "relatedPostBubble", value: function () { var e = this, t = document.querySelector(".see-more.projects"); if (t) { var r = t.querySelectorAll(".project-row"); this.stage.bubbles = Array.from(r).map(function (t, r) { (0, n.css)(t, "opacity", "1"), t.classList.add("visible"); var o = t.querySelector(".bubble-wrapper"), i = (0, n.getBubbleTypeFromClass)(t.classList), l = new u.default(o, e.stage.scene, e.stage.camera, e.stage.geometry, i, r, !0, !0, !0); return l.division = 20, l }) } } }, { key: "projectScrollUp", value: function () { document.querySelector(".up-holder .up").addEventListener("click", function () { window.scrollTo({ top: 0 }) }) } }, { key: "dispose", value: function () { (0, i.hideHeader)(), this.dynamicSloganKill(), c.default.isMobile || window.removeEventListener("scroll", this.onPageScroll, !1), this.smoothScroll && (this.smoothScroll.dispose(), clearInterval(this.smoothScrollInterval)), this.stage.bubbles.forEach(function (e) { return e.dispose() }), this.stage.bubbles = null, c.default.parallaxify && (c.default.parallaxify.destroy(), c.default.parallaxify = null), this.footerWavesKill(), this.magneticSocialHover && this.magneticSocialHover(), this.magneticEmailHover && this.magneticEmailHover(), c.default.cursor && (c.default.cursor.destroy(), c.default.cursor = null, c.default.cursor = new s.default, e.default.set(".bubbles-cursor", { opacity: .7 })); var t = document.querySelector(".footer"); e.default.to(t, { opacity: 0, duration: .3, onComplete: function () { e.default.set(t, { pointerEvents: "none" }) } }), this.bird.dispose() } }]), t }(); exports.SingleProject = q;
    }, { "gsap": "TpQl", "gsap/ScrollTrigger": "TgBN", "@fancyapps/ui": "a2rU", "imagesloaded": "lc7f", "./utils/utils": "HUaJ", "./navbar": "bAir", "./footer-waves": "j2Os", "./magnetic": "FcVb", "./Cursor": "cc6K", "./constants/global": "Utju", "./Bubble": "t3hd", "./SmoothScroll": "dsjG" }], "XovL": [function (require, module, exports) {

        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.About = void 0; var e = u(require("pure-parallaxify")), t = u(require("gsap")), o = require("./utils/utils"), r = require("./navbar"), a = require("./footer-waves"), i = require("./magnetic"), n = u(require("./constants/global")), l = u(require("./Bubble")), s = u(require("./SmoothScroll")); function u(e) { return e && e.__esModule ? e : { default: e } } function c(e, t, o) { return t in e ? Object.defineProperty(e, t, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = o, e } function d(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function f(e, t) { for (var o = 0; o < t.length; o++) { var r = t[o]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function g(e, t, o) { return t && f(e.prototype, t), o && f(e, o), e } var h = function () { function u(e, t) { d(this, u), o.bindMethods.call(this), this.stage = e, this.bird = t, this.signatureTop, this.magneticEmailHover, this.magneticSocialHover, this.awwwards = document.querySelector("#awwwards") } return g(u, [{ key: "init", value: function () { var l = this; document.querySelector("html").classList.remove("stop-scroll"), n.default.isMobile || (this.smoothScroll = new s.default), t.default.to(this.awwwards, { opacity: 1, pointerEvents: "all" }), this.bird.flying(), (0, r.showHeader)(), (0, r.navbarLinksAnimation)(), this.dynamicSloganKill = (0, r.dynamicSlogan)(), (0, r.headerFixer)(); var u = document.querySelector(".audio-toggle"); t.default.to(u, { visibility: "visible", pointerEvents: "all" }); var c = setTimeout(function () { n.default.parallaxify || n.default.isMobile || (n.default.parallaxify = new e.default), l.aboutHero(), l.initBubblesForImages(), l.textsShowUpAnimation(), l.aboutScrollUp(), l.aboutLogoDraw(), n.default.isMobile || (l.magneticEmailHover = (0, i.magneticItemHover)(".about-page .section-4 .email", .2), l.magneticSocialHover = (0, i.magneticItemHover)(".social")), clearTimeout(c) }, 1e3), d = setTimeout(function () { l.footerWavesKill = (0, a.footerWaves)(); var e = document.querySelector(".footer"); (0, o.css)(e, "opacity", 1), (0, o.css)(e, "pointerEvents", "all"), clearTimeout(d) }, 1e3) } }, { key: "aboutHero", value: function () { var e = document.querySelector(".about-hero-holder"), o = window.innerWidth <= 576; t.default.fromTo(".about-hero-holder .images-wrapper svg path", {}, { scrollTrigger: { trigger: "div[data-scroll]", start: 0, end: e.scrollHeight, scrub: .1, onEnter: function () { t.default.to(".about-hero-holder .first-time-layer", { opacity: 0 }), t.default.to(".about-hero-holder .scroll-down.second", { opacity: 1, delay: .2 }) } }, strokeDashoffset: 0 }), t.default.fromTo(".about-hero-holder .words span", { opacity: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: e.scrollHeight / 2, end: e.scrollHeight, scrub: .1 }, opacity: 1, x: 0 }), t.default.fromTo(".about-hero-holder .images-wrapper img", { opacity: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: e.scrollHeight, end: 1.5 * e.scrollHeight, scrub: .1 }, opacity: 1 }), o && t.default.fromTo(".about-hero-holder .images-wrapper .mobile-cover", { opacity: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: 1.2 * e.scrollHeight, end: 1.6 * e.scrollHeight, scrub: .1 }, opacity: 1 }), t.default.fromTo(".about-hero-holder .words span", { color: "#00000000" }, { scrollTrigger: { trigger: "div[data-scroll]", start: e.scrollHeight, end: 1.5 * e.scrollHeight, scrub: .1 }, color: "#ffffff" }), t.default.fromTo(".about-hero-holder", { y: 0 }, { scrollTrigger: { trigger: "div[data-scroll]", start: 1.5 * e.scrollHeight, end: e.scrollHeight * (o ? 2.8 : 2.7), scrub: .1 }, y: -1.2 * window.innerHeight }) } }, { key: "initBubblesForImages", value: function () { var e = this, t = document.querySelectorAll(".section .image-holder"); t && (this.stage.bubbles = Array.from(t).map(function (t, o) { var r = new l.default(t, e.stage.scene, e.stage.camera, e.stage.geometry, "ui_ux", o, !0, !0, !1); return r.spikes = 30, r.division = 20, r })) } }, { key: "textsShowUpAnimation", value: function () { var e = new IntersectionObserver(this.onContentIntersectionChange, { root: null, rootMargin: "0px", threshold: .5 }), t = document.querySelectorAll(".about-page .content > *"); Array.from(t).forEach(function (t) { return e.observe(t) }) } }, { key: "onContentIntersectionChange", value: function (e, o) { e.forEach(function (e) { e.intersectionRatio > 0 && (t.default.to(e.target, { opacity: 1, y: 0, duration: .4 }), o.unobserve(e.target)) }) } }, { key: "aboutScrollUp", value: function () { document.querySelector(".about-page .section-4 .up").addEventListener("click", function () { window.scrollTo({ top: 0 }) }) } }, { key: "aboutLogoDraw", value: function () { var e = document.querySelector(".about-page .section-4 .draw-path"); new IntersectionObserver(this.onIntersectionChange, { root: null, rootMargin: "0px", threshold: 1 }).observe(e) } }, { key: "onIntersectionChange", value: function (e, o) { e.forEach(function (e) { if (e.intersectionRatio > 0) { var r = t.default.timeline({ paused: !0, onComplete: function () { return r.kill() } }); r.to(".about-page .section-4 .draw-path .stage-1", { strokeDashoffset: 0, duration: 1.5, ease: "power4.out" }), r.to(".about-page .section-4 .draw-path .stage-2", { opacity: 1 }, "-=0.5"), r.to(".about-page .section-4 .draw-path .stage-3", { strokeDashoffset: 0, duration: 1, ease: "power4.out" }, "-=0.5"), r.to(".about-page .section-4 .draw-path .stage-4", { strokeDashoffset: 0, duration: 1, ease: "power4.out" }, "-=0.5"), r.to(".about-page .section-4 .draw-path .stage-5", { strokeDashoffset: 0, duration: 1, ease: "power4.out" }, "-=0.5"), r.to(".about-page .section-4 .draw-path .stage-6", { strokeDashoffset: 0, duration: 1, ease: "power4.out" }, "-=0.5"), r.to(".about-page .section-4 .draw-path .stage-7", c({ strokeDashoffset: 0, duration: 1, ease: "power4.out" }, "duration", 2), "-=0.5"), r.restart(), o.unobserve(e.target) } }) } }, { key: "getCoords", value: function (e) { var t = e.getBoundingClientRect(), o = document.body, r = document.documentElement, a = window.pageYOffset || r.scrollTop || o.scrollTop, i = window.pageXOffset || r.scrollLeft || o.scrollLeft, n = r.clientTop || o.clientTop || 0, l = r.clientLeft || o.clientLeft || 0, s = t.top + a - n, u = t.left + i - l; return { top: Math.round(s), left: Math.round(u) } } }, { key: "dispose", value: function () { (0, r.hideHeader)(), this.dynamicSloganKill(), this.smoothScroll && this.smoothScroll.dispose(), n.default.parallaxify && (n.default.parallaxify.destroy(), n.default.parallaxify = null), this.footerWavesKill(), this.magneticEmailHover && this.magneticEmailHover(), this.magneticSocialHover && this.magneticSocialHover(), this.stage.bubbles.forEach(function (e) { return e.dispose() }), this.stage.bubbles = null; var e = document.querySelector(".footer"); t.default.to(e, { opacity: 0, duration: .3, onComplete: function () { t.default.set(e, { pointerEvents: "none" }) } }), this.bird.dispose() } }]), u }(); exports.About = h;
    }, { "pure-parallaxify": "CgH9", "gsap": "TpQl", "./utils/utils": "HUaJ", "./navbar": "bAir", "./footer-waves": "j2Os", "./magnetic": "FcVb", "./constants/global": "Utju", "./Bubble": "t3hd", "./SmoothScroll": "dsjG" }], "Qw94": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.Draggable = void 0; var t = require("./utils/matrix.js"); function e(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function n(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } var o, r, i, l, a, s, c, u, d, p, f, h, g, x, m, v, y, w, b, T, M, E = function () { return "undefined" != typeof window }, D = function () { return o || E() && (o = window.gsap) && o.registerPlugin && o }, X = function (t) { return "function" == typeof t }, Y = function (t) { return "object" == typeof t }, S = function (t) { return void 0 === t }, k = function () { return !1 }, L = "transform", P = "transformOrigin", N = function (t) { return Math.round(1e4 * t) / 1e4 }, C = Array.isArray, _ = function (t, e) { var n = i.createElementNS ? i.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : i.createElement(t); return n.style ? n : i.createElement(t) }, O = 180 / Math.PI, R = 1e20, A = new t.Matrix2D, B = Date.now || function () { return (new Date).getTime() }, I = [], H = {}, W = 0, F = /^(?:a|input|textarea|button|select)$/i, z = 0, G = {}, K = {}, V = function (t, e) { var n, o = {}; for (n in t) o[n] = e ? t[n] * e : t[n]; return o }, j = function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }, U = function () { return I.forEach(function (t) { return t() }) }, q = function (t) { I.push(t), 1 === I.length && o.ticker.add(U) }, $ = function () { return !I.length && o.ticker.remove(U) }, Z = function (t) { for (var e = I.length; e--;)I[e] === t && I.splice(e, 1); o.to($, { overwrite: !0, delay: 15, duration: 0, onComplete: $, data: "_draggable" }) }, J = function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }, Q = function (t, e, n, o) { if (t.addEventListener) { var r = g[e]; o = o || (f ? { passive: !1 } : null), t.addEventListener(r || e, n, o), r && e !== r && t.addEventListener(e, n, o) } }, tt = function (t, e, n) { if (t.removeEventListener) { var o = g[e]; t.removeEventListener(o || e, n), o && e !== o && t.removeEventListener(e, n) } }, et = function (t) { t.preventDefault && t.preventDefault(), t.preventManipulation && t.preventManipulation() }, nt = function (t, e) { for (var n = t.length; n--;)if (t[n].identifier === e) return !0 }, ot = function t(e) { m = e.touches && x < e.touches.length, tt(e.target, "touchend", t) }, rt = function (t) { m = t.touches && x < t.touches.length, Q(t.target, "touchend", ot) }, it = function (t) { return r.pageYOffset || t.scrollTop || t.documentElement.scrollTop || t.body.scrollTop || 0 }, lt = function (t) { return r.pageXOffset || t.scrollLeft || t.documentElement.scrollLeft || t.body.scrollLeft || 0 }, at = function t(e, n) { Q(e, "scroll", n), ct(e.parentNode) || t(e.parentNode, n) }, st = function t(e, n) { tt(e, "scroll", n), ct(e.parentNode) || t(e.parentNode, n) }, ct = function (t) { return !(t && t !== l && 9 !== t.nodeType && t !== i.body && t !== r && t.nodeType && t.parentNode) }, ut = function (t, e) { var n = "x" === e ? "Width" : "Height", o = "scroll" + n, i = "client" + n; return Math.max(0, ct(t) ? Math.max(l[o], a[o]) - (r["inner" + n] || l[i] || a[i]) : t[o] - t[i]) }, dt = function t(e, n) { var o = ut(e, "x"), r = ut(e, "y"); ct(e) ? e = K : t(e.parentNode, n), e._gsMaxScrollX = o, e._gsMaxScrollY = r, n || (e._gsScrollX = e.scrollLeft || 0, e._gsScrollY = e.scrollTop || 0) }, pt = function (t, e, n) { var o = t.style; o && (S(o[e]) && (e = d(e, t) || e), null == n ? o.removeProperty && o.removeProperty(e.replace(/([A-Z])/g, "-$1").toLowerCase()) : o[e] = n) }, ft = function (t) { return r.getComputedStyle(t instanceof Element ? t : t.host || (t.parentNode || {}).host || t) }, ht = {}, gt = function (t) { if (t === r) return ht.left = ht.top = 0, ht.width = ht.right = l.clientWidth || t.innerWidth || a.clientWidth || 0, ht.height = ht.bottom = (t.innerHeight || 0) - 20 < l.clientHeight ? l.clientHeight : t.innerHeight || a.clientHeight || 0, ht; var e = t.ownerDocument || i, n = S(t.pageX) ? t.nodeType || S(t.left) || S(t.top) ? p(t)[0].getBoundingClientRect() : t : { left: t.pageX - lt(e), top: t.pageY - it(e), right: t.pageX - lt(e) + 1, bottom: t.pageY - it(e) + 1 }; return S(n.right) && !S(n.width) ? (n.right = n.left + n.width, n.bottom = n.top + n.height) : S(n.width) && (n = { width: n.right - n.left, height: n.bottom - n.top, right: n.right, left: n.left, bottom: n.bottom, top: n.top }), n }, xt = function (t, e, n) { var o, r = t.vars, i = r[n], l = t._listeners[e]; return X(i) && (o = i.apply(r.callbackScope || t, r[n + "Params"] || [t.pointerEvent])), l && !1 === t.dispatchEvent(e) && (o = !1), o }, mt = function (t, e) { var n, o, i, l = p(t)[0]; return l.nodeType || l === r ? yt(l, e) : S(t.left) ? { left: o = t.min || t.minX || t.minRotation || 0, top: n = t.min || t.minY || 0, width: (t.max || t.maxX || t.maxRotation || 0) - o, height: (t.max || t.maxY || 0) - n } : (i = { x: 0, y: 0 }, { left: t.left - i.x, top: t.top - i.y, width: t.width, height: t.height }) }, vt = {}, yt = function (e, n) { n = p(n)[0]; var o, l, a, s, c, u, d, f, h, g, x, m, v, y, w = e.getBBox && e.ownerSVGElement, b = e.ownerDocument || i; if (e === r) a = it(b), l = (o = lt(b)) + (b.documentElement.clientWidth || e.innerWidth || b.body.clientWidth || 0), s = a + ((e.innerHeight || 0) - 20 < b.documentElement.clientHeight ? b.documentElement.clientHeight : e.innerHeight || b.body.clientHeight || 0); else { if (n === r || S(n)) return e.getBoundingClientRect(); o = a = 0, w ? (x = (g = e.getBBox()).width, m = g.height) : (e.viewBox && (g = e.viewBox.baseVal) && (o = g.x || 0, a = g.y || 0, x = g.width, m = g.height), x || (g = "border-box" === (v = ft(e)).boxSizing, x = (parseFloat(v.width) || e.clientWidth || 0) + (g ? 0 : parseFloat(v.borderLeftWidth) + parseFloat(v.borderRightWidth)), m = (parseFloat(v.height) || e.clientHeight || 0) + (g ? 0 : parseFloat(v.borderTopWidth) + parseFloat(v.borderBottomWidth)))), l = x, s = m } return e === n ? { left: o, top: a, width: l - o, height: s - a } : (u = (c = (0, t.getGlobalMatrix)(n, !0).multiply((0, t.getGlobalMatrix)(e))).apply({ x: o, y: a }), d = c.apply({ x: l, y: a }), f = c.apply({ x: l, y: s }), h = c.apply({ x: o, y: s }), o = Math.min(u.x, d.x, f.x, h.x), a = Math.min(u.y, d.y, f.y, h.y), { left: o + ((y = n.parentNode || {}).scrollLeft || 0), top: a + (y.scrollTop || 0), width: Math.max(u.x, d.x, f.x, h.x) - o, height: Math.max(u.y, d.y, f.y, h.y) - a }) }, wt = function (t, e, n, o, r, i) { var l, a, s, c = {}; if (e) if (1 !== r && e instanceof Array) { if (c.end = l = [], s = e.length, Y(e[0])) for (a = 0; a < s; a++)l[a] = V(e[a], r); else for (a = 0; a < s; a++)l[a] = e[a] * r; n += 1.1, o -= 1.1 } else X(e) ? c.end = function (n) { var o, i, l = e.call(t, n); if (1 !== r) if (Y(l)) { for (i in o = {}, l) o[i] = l[i] * r; l = o } else l *= r; return l } : c.end = e; return (n || 0 === n) && (c.max = n), (o || 0 === o) && (c.min = o), i && (c.velocity = 0), c }, bt = function t(e) { var n; return !(!e || !e.getAttribute || e === a) && (!("true" !== (n = e.getAttribute("data-clickable")) && ("false" === n || !e.onclick && !F.test(e.nodeName + "") && "true" !== e.getAttribute("contentEditable"))) || t(e.parentNode)) }, Tt = function (t, e) { for (var n, r = t.length; r--;)(n = t[r]).ondragstart = n.onselectstart = e ? null : k, o.set(n, { lazy: !0, userSelect: e ? "text" : "none" }) }, Mt = function t(e) { return "fixed" === ft(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0) }, Et = function (t, e) { t = o.utils.toArray(t)[0], e = e || {}; var n, r, i, l, a, s, c = document.createElement("div"), u = c.style, d = t.firstChild, p = 0, f = 0, h = t.scrollTop, g = t.scrollLeft, x = t.scrollWidth, m = t.scrollHeight, v = 0, y = 0, w = 0; T && !1 !== e.force3D ? (a = "translate3d(", s = "px,0px)") : L && (a = "translate(", s = "px)"), this.scrollTop = function (t, e) { if (!arguments.length) return -this.top(); this.top(-t, e) }, this.scrollLeft = function (t, e) { if (!arguments.length) return -this.left(); this.left(-t, e) }, this.left = function (n, r) { if (!arguments.length) return -(t.scrollLeft + f); var i = t.scrollLeft - g, l = f; if ((i > 2 || i < -2) && !r) return g = t.scrollLeft, o.killTweensOf(this, { left: 1, scrollLeft: 1 }), this.left(-g), void (e.onKill && e.onKill()); (n = -n) < 0 ? (f = n - .5 | 0, n = 0) : n > y ? (f = n - y | 0, n = y) : f = 0, (f || l) && (this._skip || (u[L] = a + -f + "px," + -p + s), f + v >= 0 && (u.paddingRight = f + v + "px")), t.scrollLeft = 0 | n, g = t.scrollLeft }, this.top = function (n, r) { if (!arguments.length) return -(t.scrollTop + p); var i = t.scrollTop - h, l = p; if ((i > 2 || i < -2) && !r) return h = t.scrollTop, o.killTweensOf(this, { top: 1, scrollTop: 1 }), this.top(-h), void (e.onKill && e.onKill()); (n = -n) < 0 ? (p = n - .5 | 0, n = 0) : n > w ? (p = n - w | 0, n = w) : p = 0, (p || l) && (this._skip || (u[L] = a + -f + "px," + -p + s)), t.scrollTop = 0 | n, h = t.scrollTop }, this.maxScrollTop = function () { return w }, this.maxScrollLeft = function () { return y }, this.disable = function () { for (d = c.firstChild; d;)l = d.nextSibling, t.appendChild(d), d = l; t === c.parentNode && t.removeChild(c) }, this.enable = function () { if ((d = t.firstChild) !== c) { for (; d;)l = d.nextSibling, c.appendChild(d), d = l; t.appendChild(c), this.calibrate() } }, this.calibrate = function (e) { var o, l, a, s = t.clientWidth === n; h = t.scrollTop, g = t.scrollLeft, s && t.clientHeight === r && c.offsetHeight === i && x === t.scrollWidth && m === t.scrollHeight && !e || ((p || f) && (l = this.left(), a = this.top(), this.left(-t.scrollLeft), this.top(-t.scrollTop)), o = ft(t), s && !e || (u.display = "block", u.width = "auto", u.paddingRight = "0px", (v = Math.max(0, t.scrollWidth - t.clientWidth)) && (v += parseFloat(o.paddingLeft) + (M ? parseFloat(o.paddingRight) : 0))), u.display = "inline-block", u.position = "relative", u.overflow = "visible", u.verticalAlign = "top", u.boxSizing = "content-box", u.width = "100%", u.paddingRight = v + "px", M && (u.paddingBottom = o.paddingBottom), n = t.clientWidth, r = t.clientHeight, x = t.scrollWidth, m = t.scrollHeight, y = t.scrollWidth - n, w = t.scrollHeight - r, i = c.offsetHeight, u.display = "block", (l || a) && (this.left(l), this.top(a))) }, this.content = c, this.element = t, this._skip = !1, this.enable() }, Dt = function (t) { if (E() && document.body) { var e = window && window.navigator; r = window, i = document, l = i.documentElement, a = i.body, s = _("div"), b = !!window.PointerEvent, (c = _("div")).style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab", w = "grab" === c.style.cursor ? "grab" : "move", v = e && -1 !== e.userAgent.toLowerCase().indexOf("android"), h = "ontouchstart" in l && "orientation" in r || e && (e.MaxTouchPoints > 0 || e.msMaxTouchPoints > 0), x = _("div"), m = _("div"), X = m.style, Y = a, X.display = "inline-block", X.position = "relative", x.style.cssText = m.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden", x.appendChild(m), Y.appendChild(x), n = m.offsetHeight + 18 > x.scrollHeight, Y.removeChild(x), M = n, g = function (t) { for (var e = t.split(","), n = (("onpointerdown" in s ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in s ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : t).split(",")), o = {}, r = 4; --r > -1;)o[e[r]] = n[r], o[n[r]] = e[r]; try { l.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function () { f = 1 } })) } catch (i) { } return o }("touchstart,touchmove,touchend,touchcancel"), Q(i, "touchcancel", k), Q(r, "touchmove", k), a && a.addEventListener("touchstart", k), Q(i, "contextmenu", function () { for (var t in H) H[t].isPressed && H[t].endDrag() }), o = u = D() } var n, x, m, X, Y; o ? (y = o.plugins.inertia, d = o.utils.checkPrefix, L = d(L), P = d(P), p = o.utils.toArray, T = !!d("perspective")) : t && console.warn("Please gsap.registerPlugin(Draggable)") }, Xt = function () { function t(t) { this._listeners = {}, this.target = t || this } var e = t.prototype; return e.addEventListener = function (t, e) { var n = this._listeners[t] || (this._listeners[t] = []); ~n.indexOf(e) || n.push(e) }, e.removeEventListener = function (t, e) { var n = this._listeners[t], o = n && n.indexOf(e) || -1; o > -1 && n.splice(o, 1) }, e.dispatchEvent = function (t) { var e, n = this; return (this._listeners[t] || []).forEach(function (o) { return !1 === o.call(n, { type: t, target: n.target }) && (e = !1) }), e }, t }(), Yt = function (a) { function s(n, u) { var d; d = a.call(this) || this, o || Dt(1), n = p(n)[0], y || (y = o.plugins.inertia), d.vars = u = V(u || {}), d.target = n, d.x = d.y = d.rotation = 0, d.dragResistance = parseFloat(u.dragResistance) || 0, d.edgeResistance = isNaN(u.edgeResistance) ? 1 : parseFloat(u.edgeResistance) || 0, d.lockAxis = u.lockAxis, d.autoScroll = u.autoScroll || 0, d.lockedAxis = null, d.allowEventDefault = !!u.allowEventDefault, o.getProperty(n, "x"); var f, T, M, E, D, k, L, _, I, F, U, $, J, ot, ut, ht, yt, Xt, Yt, St, kt, Lt, Pt, Nt, Ct, _t, Ot, Rt, At, Bt, It, Ht = (u.type || "x,y").toLowerCase(), Wt = ~Ht.indexOf("x") || ~Ht.indexOf("y"), Ft = -1 !== Ht.indexOf("rotation"), zt = Ft ? "rotation" : Wt ? "x" : "left", Gt = Wt ? "y" : "top", Kt = !(!~Ht.indexOf("x") && !~Ht.indexOf("left") && "scroll" !== Ht), Vt = !(!~Ht.indexOf("y") && !~Ht.indexOf("top") && "scroll" !== Ht), jt = u.minimumMovement || 2, Ut = e(d), qt = p(u.trigger || u.handle || n), $t = {}, Zt = 0, Jt = !1, Qt = u.autoScrollMarginTop || 40, te = u.autoScrollMarginRight || 40, ee = u.autoScrollMarginBottom || 40, ne = u.autoScrollMarginLeft || 40, oe = u.clickableTest || bt, re = 0, ie = n._gsap || o.core.getCache(n), le = Mt(n), ae = function (t, e) { return parseFloat(ie.get(n, t, e)) }, se = n.ownerDocument || i, ce = function (t) { return et(t), t.stopImmediatePropagation && t.stopImmediatePropagation(), !1 }, ue = function t(e) { if (Ut.autoScroll && Ut.isDragging && (Jt || yt)) { var o, i, a, s, c, u, d, p, f = n, h = 15 * Ut.autoScroll; for (Jt = !1, K.scrollTop = null != r.pageYOffset ? r.pageYOffset : null != se.documentElement.scrollTop ? se.documentElement.scrollTop : se.body.scrollTop, K.scrollLeft = null != r.pageXOffset ? r.pageXOffset : null != se.documentElement.scrollLeft ? se.documentElement.scrollLeft : se.body.scrollLeft, s = Ut.pointerX - K.scrollLeft, c = Ut.pointerY - K.scrollTop; f && !i;)o = (i = ct(f.parentNode)) ? K : f.parentNode, a = i ? { bottom: Math.max(l.clientHeight, r.innerHeight || 0), right: Math.max(l.clientWidth, r.innerWidth || 0), left: 0, top: 0 } : o.getBoundingClientRect(), u = d = 0, Vt && ((p = o._gsMaxScrollY - o.scrollTop) < 0 ? d = p : c > a.bottom - ee && p ? (Jt = !0, d = Math.min(p, h * (1 - Math.max(0, a.bottom - c) / ee) | 0)) : c < a.top + Qt && o.scrollTop && (Jt = !0, d = -Math.min(o.scrollTop, h * (1 - Math.max(0, c - a.top) / Qt) | 0)), d && (o.scrollTop += d)), Kt && ((p = o._gsMaxScrollX - o.scrollLeft) < 0 ? u = p : s > a.right - te && p ? (Jt = !0, u = Math.min(p, h * (1 - Math.max(0, a.right - s) / te) | 0)) : s < a.left + ne && o.scrollLeft && (Jt = !0, u = -Math.min(o.scrollLeft, h * (1 - Math.max(0, s - a.left) / ne) | 0)), u && (o.scrollLeft += u)), i && (u || d) && (r.scrollTo(o.scrollLeft, o.scrollTop), Me(Ut.pointerX + u, Ut.pointerY + d)), f = o } if (yt) { var g = Ut.x, x = Ut.y; Ft ? (Ut.deltaX = g - parseFloat(ie.rotation), Ut.rotation = g, ie.rotation = g + "deg", ie.renderTransform(1, ie)) : T ? (Vt && (Ut.deltaY = x - T.top(), T.top(x)), Kt && (Ut.deltaX = g - T.left(), T.left(g))) : Wt ? (Vt && (Ut.deltaY = x - parseFloat(ie.y), ie.y = x + "px"), Kt && (Ut.deltaX = g - parseFloat(ie.x), ie.x = g + "px"), ie.renderTransform(1, ie)) : (Vt && (Ut.deltaY = x - parseFloat(n.style.top || 0), n.style.top = x + "px"), Kt && (Ut.deltaY = g - parseFloat(n.style.left || 0), n.style.left = g + "px")), !_ || e || Rt || (Rt = !0, !1 === xt(Ut, "drag", "onDrag") && (Kt && (Ut.x -= Ut.deltaX), Vt && (Ut.y -= Ut.deltaY), t(!0)), Rt = !1) } yt = !1 }, de = function (t, e) { var r, i, l = Ut.x, a = Ut.y; n._gsap || (ie = o.core.getCache(n)), Wt ? (Ut.x = parseFloat(ie.x), Ut.y = parseFloat(ie.y)) : Ft ? Ut.x = Ut.rotation = parseFloat(ie.rotation) : T ? (Ut.y = T.top(), Ut.x = T.left()) : (Ut.y = parseInt(n.style.top || (i = ft(n)) && i.top, 10) || 0, Ut.x = parseInt(n.style.left || (i || {}).left, 10) || 0), (Yt || St || kt) && !e && (Ut.isDragging || Ut.isThrowing) && (kt && (G.x = Ut.x, G.y = Ut.y, (r = kt(G)).x !== Ut.x && (Ut.x = r.x, yt = !0), r.y !== Ut.y && (Ut.y = r.y, yt = !0)), Yt && (r = Yt(Ut.x)) !== Ut.x && (Ut.x = r, Ft && (Ut.rotation = r), yt = !0), St && ((r = St(Ut.y)) !== Ut.y && (Ut.y = r), yt = !0)), yt && ue(!0), t || (Ut.deltaX = Ut.x - l, Ut.deltaY = Ut.y - a, xt(Ut, "throwupdate", "onThrowUpdate")) }, pe = function (t, e, n, o) { return null == e && (e = -R), null == n && (n = R), X(t) ? function (r) { var i = Ut.isPressed ? 1 - Ut.edgeResistance : 1; return t.call(Ut, r > n ? n + (r - n) * i : r < e ? e + (r - e) * i : r) * o } : C(t) ? function (o) { for (var r, i, l = t.length, a = 0, s = R; --l > -1;)(i = (r = t[l]) - o) < 0 && (i = -i), i < s && r >= e && r <= n && (a = l, s = i); return t[a] } : isNaN(t) ? function (t) { return t } : function () { return t * o } }, fe = function () { var t, e, o, r; L = !1, T ? (T.calibrate(), Ut.minX = U = -T.maxScrollLeft(), Ut.minY = J = -T.maxScrollTop(), Ut.maxX = F = Ut.maxY = $ = 0, L = !0) : u.bounds && (t = mt(u.bounds, n.parentNode), Ft ? (Ut.minX = U = t.left, Ut.maxX = F = t.left + t.width, Ut.minY = J = Ut.maxY = $ = 0) : S(u.bounds.maxX) && S(u.bounds.maxY) ? (e = mt(n, n.parentNode), Ut.minX = U = Math.round(ae(zt, "px") + t.left - e.left - .5), Ut.minY = J = Math.round(ae(Gt, "px") + t.top - e.top - .5), Ut.maxX = F = Math.round(U + (t.width - e.width)), Ut.maxY = $ = Math.round(J + (t.height - e.height))) : (t = u.bounds, Ut.minX = U = t.minX, Ut.minY = J = t.minY, Ut.maxX = F = t.maxX, Ut.maxY = $ = t.maxY), U > F && (Ut.minX = F, Ut.maxX = F = U, U = Ut.minX), J > $ && (Ut.minY = $, Ut.maxY = $ = J, J = Ut.minY), Ft && (Ut.minRotation = U, Ut.maxRotation = F), L = !0), u.liveSnap && (o = !0 === u.liveSnap ? u.snap || {} : u.liveSnap, r = C(o) || X(o), Ft ? (Yt = pe(r ? o : o.rotation, U, F, 1), St = null) : o.points ? kt = function (t, e, n, o, r, i, l) { return i = i && i < R ? i * i : R, X(t) ? function (a) { var s, c, u, d = Ut.isPressed ? 1 - Ut.edgeResistance : 1, p = a.x, f = a.y; return a.x = p = p > n ? n + (p - n) * d : p < e ? e + (p - e) * d : p, a.y = f = f > r ? r + (f - r) * d : f < o ? o + (f - o) * d : f, (s = t.call(Ut, a)) !== a && (a.x = s.x, a.y = s.y), 1 !== l && (a.x *= l, a.y *= l), i < R && (c = a.x - p) * c + (u = a.y - f) * u > i && (a.x = p, a.y = f), a } : C(t) ? function (e) { for (var n, o, r, l, a = t.length, s = 0, c = R; --a > -1;)(l = (n = (r = t[a]).x - e.x) * n + (o = r.y - e.y) * o) < c && (s = a, c = l); return c <= i ? t[s] : e } : function (t) { return t } }(r ? o : o.points, U, F, J, $, o.radius, T ? -1 : 1) : (Kt && (Yt = pe(r ? o : o.x || o.left || o.scrollLeft, U, F, T ? -1 : 1)), Vt && (St = pe(r ? o : o.y || o.top || o.scrollTop, J, $, T ? -1 : 1)))) }, he = function () { Ut.isThrowing = !1, xt(Ut, "throwcomplete", "onThrowComplete") }, ge = function () { Ut.isThrowing = !1 }, xe = function (t, e) { var r, i, l, a; t && y ? (!0 === t && (r = u.snap || u.liveSnap || {}, i = C(r) || X(r), t = { resistance: (u.throwResistance || u.resistance || 1e3) / (Ft ? 10 : 1) }, Ft ? t.rotation = wt(Ut, i ? r : r.rotation, F, U, 1, e) : (Kt && (t[zt] = wt(Ut, i ? r : r.points || r.x || r.left, F, U, T ? -1 : 1, e || "x" === Ut.lockedAxis)), Vt && (t[Gt] = wt(Ut, i ? r : r.points || r.y || r.top, $, J, T ? -1 : 1, e || "y" === Ut.lockedAxis)), (r.points || C(r) && Y(r[0])) && (t.linkedProps = zt + "," + Gt, t.radius = r.radius))), Ut.isThrowing = !0, a = isNaN(u.overshootTolerance) ? 1 === u.edgeResistance ? 0 : 1 - Ut.edgeResistance + .2 : u.overshootTolerance, t.duration || (t.duration = { max: Math.max(u.minDuration || 0, "maxDuration" in u ? u.maxDuration : 2), min: isNaN(u.minDuration) ? 0 === a || Y(t) && t.resistance > 1e3 ? 0 : .5 : u.minDuration, overshoot: a }), Ut.tween = l = o.to(T || n, { inertia: t, data: "_draggable", onComplete: he, onInterrupt: ge, onUpdate: u.fastMode ? xt : de, onUpdateParams: u.fastMode ? [Ut, "onthrowupdate", "onThrowUpdate"] : r && r.radius ? [!1, !0] : [] }), u.fastMode || (T && (T._skip = !0), l.render(1e9, !0, !0), de(!0, !0), Ut.endX = Ut.x, Ut.endY = Ut.y, Ft && (Ut.endRotation = Ut.x), l.play(0), de(!0, !0), T && (T._skip = !1))) : L && Ut.applyBounds() }, me = function (e) { var o, r = Nt; Nt = (0, t.getGlobalMatrix)(n.parentNode, !0), e && Ut.isPressed && !Nt.equals(r || new t.Matrix2D) && (o = r.inverse().apply({ x: M, y: E }), Nt.apply(o, o), M = o.x, E = o.y), Nt.equals(A) && (Nt = null) }, ve = function () { var e, o, r, i = 1 - Ut.edgeResistance, l = le ? lt(se) : 0, a = le ? it(se) : 0; me(!1), Nt && (vt.x = Ut.pointerX - l, vt.y = Ut.pointerY - a, Nt.apply(vt, vt), M = vt.x, E = vt.y), yt && (Me(Ut.pointerX, Ut.pointerY), ue(!0)), T ? (fe(), k = T.top(), D = T.left()) : (ye() ? (de(!0, !0), fe()) : Ut.applyBounds(), Ft ? (e = n.ownerSVGElement ? [ie.xOrigin - n.getBBox().x, ie.yOrigin - n.getBBox().y] : (ft(n)[P] || "0 0").split(" "), ht = Ut.rotationOrigin = (0, t.getGlobalMatrix)(n).apply({ x: parseFloat(e[0]) || 0, y: parseFloat(e[1]) || 0 }), de(!0, !0), o = Ut.pointerX - ht.x - l, r = ht.y - Ut.pointerY + a, D = Ut.x, k = Ut.y = Math.atan2(r, o) * O) : (k = ae(Gt, "px"), D = ae(zt, "px"))), L && i && (D > F ? D = F + (D - F) / i : D < U && (D = U - (U - D) / i), Ft || (k > $ ? k = $ + (k - $) / i : k < J && (k = J - (J - k) / i))), Ut.startX = D, Ut.startY = k }, ye = function () { return Ut.tween && Ut.tween.isActive() }, we = function () { !c.parentNode || ye() || Ut.isDragging || c.parentNode.removeChild(c) }, be = function (t, e) { var i; if (!f || Ut.isPressed || !t || !("mousedown" !== t.type && "pointerdown" !== t.type || e) && B() - re < 30 && g[Ut.pointerEvent.type]) It && t && f && et(t); else { if (Ct = ye(), Ut.pointerEvent = t, g[t.type] ? (Pt = ~t.type.indexOf("touch") ? t.currentTarget || t.target : se, Q(Pt, "touchend", Ee), Q(Pt, "touchmove", Te), Q(Pt, "touchcancel", Ee), Q(se, "touchstart", rt)) : (Pt = null, Q(se, "mousemove", Te)), Ot = null, b && Pt || (Q(se, "mouseup", Ee), t && t.target && Q(t.target, "mouseup", Ee)), Lt = oe.call(Ut, t.target) && !1 === u.dragClickables && !e) return Q(t.target, "change", Ee), xt(Ut, "pressInit", "onPressInit"), xt(Ut, "press", "onPress"), void Tt(qt, !0); if (_t = !(!Pt || Kt === Vt || !1 === Ut.vars.allowNativeTouchScrolling || Ut.vars.allowContextMenu && t && (t.ctrlKey || t.which > 2)) && (Kt ? "y" : "x"), (It = !_t && !Ut.allowEventDefault) && (et(t), Q(r, "touchforcechange", et)), t.changedTouches ? (t = ot = t.changedTouches[0], ut = t.identifier) : t.pointerId ? ut = t.pointerId : ot = ut = null, x++, q(ue), E = Ut.pointerY = t.pageY, M = Ut.pointerX = t.pageX, xt(Ut, "pressInit", "onPressInit"), (_t || Ut.autoScroll) && dt(n.parentNode), !n.parentNode || !Ut.autoScroll || T || Ft || !n.parentNode._gsMaxScrollX || c.parentNode || n.getBBox || (c.style.width = n.parentNode.scrollWidth + "px", n.parentNode.appendChild(c)), ve(), Ut.tween && Ut.tween.kill(), Ut.isThrowing = !1, o.killTweensOf(T || n, $t, !0), T && o.killTweensOf(n, { scrollTo: 1 }, !0), Ut.tween = Ut.lockedAxis = null, (u.zIndexBoost || !Ft && !T && !1 !== u.zIndexBoost) && (n.style.zIndex = s.zIndex++), Ut.isPressed = !0, _ = !(!u.onDrag && !Ut._listeners.drag), I = !(!u.onMove && !Ut._listeners.move), !Ft && (!1 !== u.cursor || u.activeCursor)) for (i = qt.length; --i > -1;)o.set(qt[i], { cursor: u.activeCursor || u.cursor || ("grab" === w ? "grabbing" : w) }); xt(Ut, "press", "onPress") } }, Te = function (t) { var e, n, o, i, l, a, s = t; if (f && !m && Ut.isPressed && t) { if (Ut.pointerEvent = t, e = t.changedTouches) { if ((t = e[0]) !== ot && t.identifier !== ut) { for (i = e.length; --i > -1 && (t = e[i]).identifier !== ut;); if (i < 0) return } } else if (t.pointerId && ut && t.pointerId !== ut) return; Pt && _t && !Ot && (vt.x = t.pageX, vt.y = t.pageY, Nt && Nt.apply(vt, vt), n = vt.x, o = vt.y, ((l = Math.abs(n - M)) !== (a = Math.abs(o - E)) && (l > jt || a > jt) || v && _t === Ot) && (Ot = l > a && Kt ? "x" : "y", _t && Ot !== _t && Q(r, "touchforcechange", et), !1 !== Ut.vars.lockAxisOnTouchScroll && Kt && Vt && (Ut.lockedAxis = "x" === Ot ? "y" : "x", X(Ut.vars.onLockAxis) && Ut.vars.onLockAxis.call(Ut, s)), v && _t === Ot)) ? Ee(s) : (Ut.allowEventDefault || _t && (!Ot || _t === Ot) || !1 === s.cancelable ? It && (It = !1) : (et(s), It = !0), Ut.autoScroll && (Jt = !0), Me(t.pageX, t.pageY, I)) } else It && t && f && et(t) }, Me = function (t, e, n) { var o, r, i, l, a, s, c = 1 - Ut.dragResistance, u = 1 - Ut.edgeResistance, d = Ut.pointerX, p = Ut.pointerY, f = k, h = Ut.x, g = Ut.y, x = Ut.endX, m = Ut.endY, v = Ut.endRotation, y = yt; Ut.pointerX = t, Ut.pointerY = e, le && (t -= lt(se), e -= it(se)), Ft ? (l = Math.atan2(ht.y - e, t - ht.x) * O, (a = Ut.y - l) > 180 ? (k -= 360, Ut.y = l) : a < -180 && (k += 360, Ut.y = l), Ut.x !== D || Math.abs(k - l) > jt ? (Ut.y = l, i = D + (k - l) * c) : i = D) : (Nt && (s = t * Nt.a + e * Nt.c + Nt.e, e = t * Nt.b + e * Nt.d + Nt.f, t = s), (r = e - E) < jt && r > -jt && (r = 0), (o = t - M) < jt && o > -jt && (o = 0), (Ut.lockAxis || Ut.lockedAxis) && (o || r) && ((s = Ut.lockedAxis) || (Ut.lockedAxis = s = Kt && Math.abs(o) > Math.abs(r) ? "y" : Vt ? "x" : null, s && X(Ut.vars.onLockAxis) && Ut.vars.onLockAxis.call(Ut, Ut.pointerEvent)), "y" === s ? r = 0 : "x" === s && (o = 0)), i = N(D + o * c), l = N(k + r * c)), (Yt || St || kt) && (Ut.x !== i || Ut.y !== l && !Ft) ? (kt && (G.x = i, G.y = l, s = kt(G), i = N(s.x), l = N(s.y)), Yt && (i = N(Yt(i))), St && (l = N(St(l)))) : L && (i > F ? i = F + Math.round((i - F) * u) : i < U && (i = U + Math.round((i - U) * u)), Ft || (l > $ ? l = Math.round($ + (l - $) * u) : l < J && (l = Math.round(J + (l - J) * u)))), (Ut.x !== i || Ut.y !== l && !Ft) && (Ft ? (Ut.endRotation = Ut.x = Ut.endX = i, yt = !0) : (Vt && (Ut.y = Ut.endY = l, yt = !0), Kt && (Ut.x = Ut.endX = i, yt = !0)), n && !1 === xt(Ut, "move", "onMove") ? (Ut.pointerX = d, Ut.pointerY = p, k = f, Ut.x = h, Ut.y = g, Ut.endX = x, Ut.endY = m, Ut.endRotation = v, yt = y) : !Ut.isDragging && Ut.isPressed && (Ut.isDragging = !0, xt(Ut, "dragstart", "onDragStart"))) }, Ee = function t(e, i) { if (f && Ut.isPressed && (!e || null == ut || i || !(e.pointerId && e.pointerId !== ut || e.changedTouches && !nt(e.changedTouches, ut)))) { Ut.isPressed = !1; var l, a, s, c, d, p = e, h = Ut.isDragging, g = Ut.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2), m = o.delayedCall(.001, we); if (Pt ? (tt(Pt, "touchend", t), tt(Pt, "touchmove", Te), tt(Pt, "touchcancel", t), tt(se, "touchstart", rt)) : tt(se, "mousemove", Te), tt(r, "touchforcechange", et), b && Pt || (tt(se, "mouseup", t), e && e.target && tt(e.target, "mouseup", t)), yt = !1, Lt && !g) return e && (tt(e.target, "change", t), Ut.pointerEvent = p), Tt(qt, !1), xt(Ut, "release", "onRelease"), xt(Ut, "click", "onClick"), void (Lt = !1); if (Z(ue), !Ft) for (a = qt.length; --a > -1;)pt(qt[a], "cursor", u.cursor || (!1 !== u.cursor ? w : null)); if (h && (Zt = z = B(), Ut.isDragging = !1), x--, e) { if ((l = e.changedTouches) && (e = l[0]) !== ot && e.identifier !== ut) { for (a = l.length; --a > -1 && (e = l[a]).identifier !== ut;); if (a < 0) return } Ut.pointerEvent = p, Ut.pointerX = e.pageX, Ut.pointerY = e.pageY } return g && p ? (et(p), It = !0, xt(Ut, "release", "onRelease")) : p && !h ? (It = !1, Ct && (u.snap || u.bounds) && xe(u.inertia || u.throwProps), xt(Ut, "release", "onRelease"), v && "touchmove" === p.type || -1 !== p.type.indexOf("cancel") || (xt(Ut, "click", "onClick"), B() - re < 300 && xt(Ut, "doubleclick", "onDoubleClick"), c = p.target || n, re = B(), d = function () { re === At || !Ut.enabled() || Ut.isPressed || p.defaultPrevented || (c.click ? c.click() : se.createEvent && ((s = se.createEvent("MouseEvents")).initMouseEvent("click", !0, !0, r, 1, Ut.pointerEvent.screenX, Ut.pointerEvent.screenY, Ut.pointerX, Ut.pointerY, !1, !1, !1, !1, 0, null), c.dispatchEvent(s))) }, v || p.defaultPrevented || o.delayedCall(.05, d))) : (xe(u.inertia || u.throwProps), Ut.allowEventDefault || !p || !1 === u.dragClickables && oe.call(Ut, p.target) || !h || _t && (!Ot || _t !== Ot) || !1 === p.cancelable ? It = !1 : (It = !0, et(p)), xt(Ut, "release", "onRelease")), ye() && m.duration(Ut.tween.duration()), h && xt(Ut, "dragend", "onDragEnd"), !0 } It && e && f && et(e) }, De = function (t) { if (t && Ut.isDragging && !T) { var e = t.target || n.parentNode, o = e.scrollLeft - e._gsScrollX, r = e.scrollTop - e._gsScrollY; (o || r) && (Nt ? (M -= o * Nt.a + r * Nt.c, E -= r * Nt.d + o * Nt.b) : (M -= o, E -= r), e._gsScrollX += o, e._gsScrollY += r, Me(Ut.pointerX, Ut.pointerY)) } }, Xe = function (t) { var e = B(), n = e - re < 40, o = e - Zt < 40, r = n && At === re, i = Ut.pointerEvent && Ut.pointerEvent.defaultPrevented, l = n && Bt === re, a = t.isTrusted || null == t.isTrusted && n && r; if ((r || o && !1 !== Ut.vars.suppressClickOnDrag) && t.stopImmediatePropagation && t.stopImmediatePropagation(), n && (!Ut.pointerEvent || !Ut.pointerEvent.defaultPrevented) && (!r || a && !l)) return a && r && (Bt = re), void (At = re); (Ut.isPressed || o || n) && (a && t.detail && n && !i || et(t)) }, Ye = function (t) { return Nt ? { x: t.x * Nt.a + t.y * Nt.c + Nt.e, y: t.x * Nt.b + t.y * Nt.d + Nt.f } : { x: t.x, y: t.y } }; return (Xt = s.get(n)) && Xt.kill(), d.startDrag = function (t, e) { var o, r, i, l; be(t || Ut.pointerEvent, !0), e && !Ut.hitTest(t || Ut.pointerEvent) && (o = gt(t || Ut.pointerEvent), r = gt(n), i = Ye({ x: o.left + o.width / 2, y: o.top + o.height / 2 }), l = Ye({ x: r.left + r.width / 2, y: r.top + r.height / 2 }), M -= i.x - l.x, E -= i.y - l.y), Ut.isDragging || (Ut.isDragging = !0, xt(Ut, "dragstart", "onDragStart")) }, d.drag = Te, d.endDrag = function (t) { return Ee(t || Ut.pointerEvent, !0) }, d.timeSinceDrag = function () { return Ut.isDragging ? 0 : (B() - Zt) / 1e3 }, d.timeSinceClick = function () { return (B() - re) / 1e3 }, d.hitTest = function (t, e) { return s.hitTest(Ut.target, t, e) }, d.getDirection = function (t, e) { var o, r, i, l, a, s, c = "velocity" === t && y ? t : Y(t) && !Ft ? "element" : "start"; return "element" === c && (a = gt(Ut.target), s = gt(t)), o = "start" === c ? Ut.x - D : "velocity" === c ? y.getVelocity(n, zt) : a.left + a.width / 2 - (s.left + s.width / 2), Ft ? o < 0 ? "counter-clockwise" : "clockwise" : (e = e || 2, r = "start" === c ? Ut.y - k : "velocity" === c ? y.getVelocity(n, Gt) : a.top + a.height / 2 - (s.top + s.height / 2), l = (i = Math.abs(o / r)) < 1 / e ? "" : o < 0 ? "left" : "right", i < e && ("" !== l && (l += "-"), l += r < 0 ? "up" : "down"), l) }, d.applyBounds = function (t, e) { var o, i, l, a, s, c; if (t && u.bounds !== t) return u.bounds = t, Ut.update(!0, e); if (de(!0), fe(), L && !ye()) { if (o = Ut.x, i = Ut.y, o > F ? o = F : o < U && (o = U), i > $ ? i = $ : i < J && (i = J), (Ut.x !== o || Ut.y !== i) && (l = !0, Ut.x = Ut.endX = o, Ft ? Ut.endRotation = o : Ut.y = Ut.endY = i, yt = !0, ue(!0), Ut.autoScroll && !Ut.isDragging)) for (dt(n.parentNode), a = n, K.scrollTop = null != r.pageYOffset ? r.pageYOffset : null != se.documentElement.scrollTop ? se.documentElement.scrollTop : se.body.scrollTop, K.scrollLeft = null != r.pageXOffset ? r.pageXOffset : null != se.documentElement.scrollLeft ? se.documentElement.scrollLeft : se.body.scrollLeft; a && !c;)s = (c = ct(a.parentNode)) ? K : a.parentNode, Vt && s.scrollTop > s._gsMaxScrollY && (s.scrollTop = s._gsMaxScrollY), Kt && s.scrollLeft > s._gsMaxScrollX && (s.scrollLeft = s._gsMaxScrollX), a = s; Ut.isThrowing && (l || Ut.endX > F || Ut.endX < U || Ut.endY > $ || Ut.endY < J) && xe(u.inertia || u.throwProps, l) } return Ut }, d.update = function (t, e, o) { var r = Ut.x, i = Ut.y; return me(!e), t ? Ut.applyBounds() : (yt && o && ue(!0), de(!0)), e && (Me(Ut.pointerX, Ut.pointerY), yt && ue(!0)), Ut.isPressed && !e && (Kt && Math.abs(r - Ut.x) > .01 || Vt && Math.abs(i - Ut.y) > .01 && !Ft) && ve(), Ut.autoScroll && (dt(n.parentNode, Ut.isDragging), Jt = Ut.isDragging, ue(!0), st(n, De), at(n, De)), Ut }, d.enable = function (t) { var e, r, i, l = { lazy: !0 }; if (Ft || !1 === u.cursor || (l.cursor = u.cursor || w), o.utils.checkPrefix("touchCallout") && (l.touchCallout = "none"), l.touchAction = Kt === Vt ? "none" : u.allowNativeTouchScrolling || u.allowEventDefault ? "manipulation" : Kt ? "pan-y" : "pan-x", "soft" !== t) { for (r = qt.length; --r > -1;)i = qt[r], b || Q(i, "mousedown", be), Q(i, "touchstart", be), Q(i, "click", Xe, !0), o.set(i, l), i.getBBox && i.ownerSVGElement && o.set(i.ownerSVGElement, { touchAction: Kt === Vt ? "none" : u.allowNativeTouchScrolling || u.allowEventDefault ? "manipulation" : Kt ? "pan-y" : "pan-x" }), u.allowContextMenu || Q(i, "contextmenu", ce); Tt(qt, !1) } return at(n, De), f = !0, y && "soft" !== t && y.track(T || n, Wt ? "x,y" : Ft ? "rotation" : "top,left"), n._gsDragID = e = "d" + W++, H[e] = Ut, T && (T.enable(), T.element._gsDragID = e), (u.bounds || Ft) && ve(), u.bounds && Ut.applyBounds(), Ut }, d.disable = function (t) { var e, o, r = Ut.isDragging; if (!Ft) for (e = qt.length; --e > -1;)pt(qt[e], "cursor", null); if ("soft" !== t) { for (e = qt.length; --e > -1;)o = qt[e], pt(o, "touchCallout", null), pt(o, "touchAction", null), tt(o, "mousedown", be), tt(o, "touchstart", be), tt(o, "click", Xe), tt(o, "contextmenu", ce); Tt(qt, !0), Pt && (tt(Pt, "touchcancel", Ee), tt(Pt, "touchend", Ee), tt(Pt, "touchmove", Te)), tt(se, "mouseup", Ee), tt(se, "mousemove", Te) } return st(n, De), f = !1, y && "soft" !== t && y.untrack(T || n, Wt ? "x,y" : Ft ? "rotation" : "top,left"), T && T.disable(), Z(ue), Ut.isDragging = Ut.isPressed = Lt = !1, r && xt(Ut, "dragend", "onDragEnd"), Ut }, d.enabled = function (t, e) { return arguments.length ? t ? Ut.enable(e) : Ut.disable(e) : f }, d.kill = function () { return Ut.isThrowing = !1, Ut.tween && Ut.tween.kill(), Ut.disable(), o.set(qt, { clearProps: "userSelect" }), delete H[n._gsDragID], Ut }, ~Ht.indexOf("scroll") && (T = d.scrollProxy = new Et(n, j({ onKill: function () { Ut.isPressed && Ee(null) } }, u)), n.style.overflowY = Vt && !h ? "auto" : "hidden", n.style.overflowX = Kt && !h ? "auto" : "hidden", n = T.content), Ft ? $t.rotation = 1 : (Kt && ($t[zt] = 1), Vt && ($t[Gt] = 1)), ie.force3D = !("force3D" in u) || u.force3D, d.enable(), d } return n(s, a), s.register = function (t) { o = t, Dt() }, s.create = function (t, e) { return u || Dt(!0), p(t).map(function (t) { return new s(t, e) }) }, s.get = function (t) { return H[(p(t)[0] || {})._gsDragID] }, s.timeSinceDrag = function () { return (B() - z) / 1e3 }, s.hitTest = function (t, e, n) { if (t === e) return !1; var o, r, i, l = gt(t), a = gt(e), s = l.top, c = l.left, u = l.right, d = l.bottom, p = l.width, f = l.height, h = a.left > u || a.right < c || a.top > d || a.bottom < s; return h || !n ? !h : (i = -1 !== (n + "").indexOf("%"), n = parseFloat(n) || 0, (o = { left: Math.max(c, a.left), top: Math.max(s, a.top) }).width = Math.min(u, a.right) - o.left, o.height = Math.min(d, a.bottom) - o.top, !(o.width < 0 || o.height < 0) && (i ? (n *= .01, (r = o.width * o.height) >= p * f * n || r >= a.width * a.height * n) : o.width > n && o.height > n)) }, s }(Xt); exports.default = exports.Draggable = Yt, J(Yt.prototype, { pointerX: 0, pointerY: 0, startX: 0, startY: 0, deltaX: 0, deltaY: 0, isDragging: !1, isPressed: !1 }), Yt.zIndex = 1e3, Yt.version = "3.5.1", D() && o.registerPlugin(Yt);
    }, { "./utils/matrix.js": "ZBXp" }], "ZcgQ": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.CSSRulePlugin = void 0; var e, t, s, n, r, i = function () { return "undefined" != typeof window }, o = function () { return e || i() && (e = window.gsap) && e.registerPlugin && e }, l = function () { return t || (u(), r || console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)")), t }, u = function (l) { e = l || o(), i() && (s = window, n = document), e && (r = e.plugins.css) && (t = 1) }, c = { version: "3.5.1", name: "cssRule", init: function (e, t, s, i, o) { if (!l() || void 0 === e.cssText) return !1; var u = e._gsProxy = e._gsProxy || n.createElement("div"); this.ss = e, this.style = u.style, u.style.cssText = e.cssText, r.prototype.init.call(this, u, t, s, i, o) }, render: function (e, t) { for (var s, n = t._pt, r = t.style, i = t.ss; n;)n.r(e, n.d), n = n._next; for (s = r.length; --s > -1;)i[r[s]] = r[r[s]] }, getRule: function (e) { l(); var t, s, r, i, o = n.all ? "rules" : "cssRules", u = n.styleSheets, c = u.length, f = ":" === e.charAt(0); for (e = (f ? "" : ",") + e.split("::").join(":").toLowerCase() + ",", f && (i = []); c--;) { try { if (!(s = u[c][o])) continue; t = s.length } catch (a) { console.warn(a); continue } for (; --t > -1;)if ((r = s[t]).selectorText && -1 !== ("," + r.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(e)) { if (!f) return r.style; i.push(r.style) } } return i }, register: u }; exports.default = exports.CSSRulePlugin = c, o() && e.registerPlugin(c);
    }, {}], "LHlC": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.EaselPlugin = void 0; var e, t, r, i, l, n, o = "redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset".split(","), s = function () { return "undefined" != typeof window }, u = function () { return e || s() && (e = window.gsap) && e.registerPlugin && e }, a = function () { return i || r && r.createjs || r || {} }, f = function (e) { return console.warn(e) }, c = function (e) { var t = e.getBounds && e.getBounds(); t || (t = e.nominalBounds || { x: 0, y: 0, width: 100, height: 100 }, e.setBounds && e.setBounds(t.x, t.y, t.width, t.height)), e.cache && e.cache(t.x, t.y, t.width, t.height), f("EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. " + e) }, h = function (t, r, i) { l || (l = a().ColorFilter) || f("EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded."); for (var n, s, u, h, p, d, g = t.filters || [], b = g.length; b--;)if (g[b] instanceof l) { s = g[b]; break } if (s || (s = new l, g.push(s), t.filters = g), u = s.clone(), null != r.tint) n = e.utils.splitColor(r.tint), h = null != r.tintAmount ? +r.tintAmount : 1, u.redOffset = +n[0] * h, u.greenOffset = +n[1] * h, u.blueOffset = +n[2] * h, u.redMultiplier = u.greenMultiplier = u.blueMultiplier = 1 - h; else for (p in r) "exposure" !== p && "brightness" !== p && (u[p] = +r[p]); for (null != r.exposure ? (u.redOffset = u.greenOffset = u.blueOffset = 255 * (+r.exposure - 1), u.redMultiplier = u.greenMultiplier = u.blueMultiplier = 1) : null != r.brightness && (h = +r.brightness - 1, u.redOffset = u.greenOffset = u.blueOffset = h > 0 ? 255 * h : 0, u.redMultiplier = u.greenMultiplier = u.blueMultiplier = 1 - Math.abs(h)), b = 8; b--;)s[p = o[b]] !== u[p] && (d = i.add(s, p, s[p], u[p])) && (d.op = "easel_colorFilter"); i._props.push("easel_colorFilter"), t.cacheID || c(t) }, p = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], d = .212671, g = .71516, b = .072169, M = function (e, t) { if (!(e instanceof Array && t instanceof Array)) return t; var r, i, l = [], n = 0, o = 0; for (r = 0; r < 4; r++) { for (i = 0; i < 5; i++)o = 4 === i ? e[n + 4] : 0, l[n + i] = e[n] * t[i] + e[n + 1] * t[i + 5] + e[n + 2] * t[i + 10] + e[n + 3] * t[i + 15] + o; n += 5 } return l }, m = function (e, t) { if (isNaN(t)) return e; var r = 1 - t, i = r * d, l = r * g, n = r * b; return M([i + t, l, n, 0, 0, i, l + t, n, 0, 0, i, l, n + t, 0, 0, 0, 0, 0, 1, 0], e) }, x = function (t, r, i) { isNaN(i) && (i = 1); var l = e.utils.splitColor(r), n = l[0] / 255, o = l[1] / 255, s = l[2] / 255, u = 1 - i; return M([u + i * n * d, i * n * g, i * n * b, 0, 0, i * o * d, u + i * o * g, i * o * b, 0, 0, i * s * d, i * s * g, u + i * s * b, 0, 0, 0, 0, 0, 1, 0], t) }, v = function (e, t) { if (isNaN(t)) return e; t *= Math.PI / 180; var r = Math.cos(t), i = Math.sin(t); return M([d + r * (1 - d) + i * -d, g + r * -g + i * -g, b + r * -b + i * (1 - b), 0, 0, d + r * -d + .143 * i, g + r * (1 - g) + .14 * i, b + r * -b + -.283 * i, 0, 0, d + r * -d + i * -(1 - d), g + r * -g + i * g, b + r * (1 - b) + i * b, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], e) }, w = function (e, t) { return isNaN(t) ? e : M([t += .01, 0, 0, 0, 128 * (1 - t), 0, t, 0, 0, 128 * (1 - t), 0, 0, t, 0, 128 * (1 - t), 0, 0, 0, 1, 0], e) }, O = function (e, t, r) { n || (n = a().ColorMatrixFilter) || f("EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded."); for (var i, l, o, s, u = e.filters || [], h = u.length; --h > -1;)if (u[h] instanceof n) { o = u[h]; break } for (o || (o = new n(p.slice()), u.push(o), e.filters = u), l = o.matrix, i = p.slice(), null != t.colorize && (i = x(i, t.colorize, Number(t.colorizeAmount))), null != t.contrast && (i = w(i, Number(t.contrast))), null != t.hue && (i = v(i, Number(t.hue))), null != t.saturation && (i = m(i, Number(t.saturation))), h = i.length; --h > -1;)i[h] !== l[h] && (s = r.add(l, h, l[h], i[h])) && (s.op = "easel_colorMatrixFilter"); r._props.push("easel_colorMatrixFilter"), e.cacheID || c(), r._matrix = l }, P = function (i) { e = i || u(), s() && (r = window), e && (t = 1) }, y = { version: "3.5.1", name: "easel", init: function (r, i, l, n, o) { var s, u, a, c, p, d, g; for (s in t || (P(), e || f("Please gsap.registerPlugin(EaselPlugin)")), this.target = r, i) if (p = i[s], "colorFilter" === s || "tint" === s || "tintAmount" === s || "exposure" === s || "brightness" === s) a || (h(r, i.colorFilter || i, this), a = !0); else if ("saturation" === s || "contrast" === s || "hue" === s || "colorize" === s || "colorizeAmount" === s) c || (O(r, i.colorMatrixFilter || i, this), c = !0); else if ("frame" === s) { if ("string" == typeof p && "=" !== p.charAt(1) && (d = r.labels)) for (g = 0; g < d.length; g++)d[g].label === p && (p = d[g].position); (u = this.add(r, "gotoAndStop", r.currentFrame, p, n, o, Math.round)) && (u.op = s) } else null != r[s] && this.add(r, s, "get", p) }, render: function (e, t) { for (var r = t._pt; r;)r.r(e, r.d), r = r._next; t.target.cacheID && t.target.updateCache() }, register: P }; exports.default = exports.EaselPlugin = y, y.registerCreateJS = function (e) { i = e }, u() && e.registerPlugin(y);
    }, {}], "Y7PD": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.PixiPlugin = void 0; var t, r, i, o, e, n, s, l, a, u = function () { return "undefined" != typeof window }, c = function () { return t || u() && (t = window.gsap) && t.registerPlugin && t }, h = function (t) { return "function" == typeof t }, f = function (t) { return console.warn(t) }, p = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], g = .212671, d = .71516, x = .072169, b = function (t, r) { var i, o, e = [], n = 0, s = 0; for (i = 0; i < 4; i++) { for (o = 0; o < 5; o++)s = 4 === o ? t[n + 4] : 0, e[n + o] = t[n] * r[o] + t[n + 1] * r[o + 5] + t[n + 2] * r[o + 10] + t[n + 3] * r[o + 15] + s; n += 5 } return e }, m = function (t, r) { var i = 1 - r, o = i * g, e = i * d, n = i * x; return b([o + r, e, n, 0, 0, o, e + r, n, 0, 0, o, e, n + r, 0, 0, 0, 0, 0, 1, 0], t) }, v = function (t, r, o) { var e = i(r), n = e[0] / 255, s = e[1] / 255, l = e[2] / 255, a = 1 - o; return b([a + o * n * g, o * n * d, o * n * x, 0, 0, o * s * g, a + o * s * d, o * s * x, 0, 0, o * l * g, o * l * d, a + o * l * x, 0, 0, 0, 0, 0, 1, 0], t) }, P = function (t, r) { r *= Math.PI / 180; var i = Math.cos(r), o = Math.sin(r); return b([g + i * (1 - g) + o * -g, d + i * -d + o * -d, x + i * -x + o * (1 - x), 0, 0, g + i * -g + .143 * o, d + i * (1 - d) + .14 * o, x + i * -x + -.283 * o, 0, 0, g + i * -g + o * -(1 - g), d + i * -d + o * d, x + i * (1 - x) + o * x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], t) }, z = function (t, r) { return b([r, 0, 0, 0, .5 * (1 - r), 0, r, 0, 0, .5 * (1 - r), 0, 0, r, 0, .5 * (1 - r), 0, 0, 0, 1, 0], t) }, M = function (t, r) { var i, o = e.filters[r], n = t.filters || [], s = n.length; for (o || f(r + " not found. PixiPlugin.registerPIXI(PIXI)"); --s > -1;)if (n[s] instanceof o) return n[s]; return i = new o, "BlurFilter" === r && (i.blur = 0), n.push(i), t.filters = n, i }, w = function (t, r, i, o) { r.add(i, t, i[t], o[t]), r._props.push(t) }, A = function (t, r) { var i = new e.filters.ColorMatrixFilter; return i.matrix = r, i.brightness(t, !0), i.matrix }, _ = function (t) { var r, i = {}; for (r in t) i[r] = t[r]; return i }, F = { contrast: 1, saturation: 1, colorizeAmount: 0, colorize: "rgb(255,255,255)", hue: 0, brightness: 1 }, y = function (t, r, i) { var o, e, n, s = M(t, "ColorMatrixFilter"), l = t._gsColorMatrixFilter = t._gsColorMatrixFilter || _(F), a = r.combineCMF && !("colorMatrixFilter" in r && !r.colorMatrixFilter); n = s.matrix, r.resolution && (s.resolution = r.resolution), r.matrix && r.matrix.length === n.length ? (e = r.matrix, 1 !== l.contrast && w("contrast", i, l, F), l.hue && w("hue", i, l, F), 1 !== l.brightness && w("brightness", i, l, F), l.colorizeAmount && (w("colorize", i, l, F), w("colorizeAmount", i, l, F)), 1 !== l.saturation && w("saturation", i, l, F)) : (e = p.slice(), null != r.contrast ? (e = z(e, +r.contrast), w("contrast", i, l, r)) : 1 !== l.contrast && (a ? e = z(e, l.contrast) : w("contrast", i, l, F)), null != r.hue ? (e = P(e, +r.hue), w("hue", i, l, r)) : l.hue && (a ? e = P(e, l.hue) : w("hue", i, l, F)), null != r.brightness ? (e = A(+r.brightness, e), w("brightness", i, l, r)) : 1 !== l.brightness && (a ? e = A(l.brightness, e) : w("brightness", i, l, F)), null != r.colorize ? (r.colorizeAmount = "colorizeAmount" in r ? +r.colorizeAmount : 1, e = v(e, r.colorize, r.colorizeAmount), w("colorize", i, l, r), w("colorizeAmount", i, l, r)) : l.colorizeAmount && (a ? e = v(e, l.colorize, l.colorizeAmount) : (w("colorize", i, l, F), w("colorizeAmount", i, l, F))), null != r.saturation ? (e = m(e, +r.saturation), w("saturation", i, l, r)) : 1 !== l.saturation && (a ? e = m(e, l.saturation) : w("saturation", i, l, F))), o = e.length; for (; --o > -1;)e[o] !== n[o] && i.add(n, o, n[o], e[o], "colorMatrixFilter"); i._props.push("colorMatrixFilter") }, C = function (t, r) { var i = r.t, o = r.p, e = r.color; (0, r.set)(i, o, e[0] << 16 | e[1] << 8 | e[2]) }, I = function (t, r) { var i = r.g; i && (i.dirty++, i.clearDirty++) }, X = function (t, r) { r.t.visible = !!r.t.alpha }, O = function (t, r, o, e) { var l = t[r], a = i(h(l) ? t[r.indexOf("set") || !h(t["get" + r.substr(3)]) ? r : "get" + r.substr(3)]() : l), u = i(o); e._pt = new n(e._pt, t, r, 0, 0, C, { t: t, p: r, color: a, set: s(t, r) }), e.add(a, 0, a[0], u[0]), e.add(a, 1, a[1], u[1]), e.add(a, 2, a[2], u[2]) }, S = { tint: 1, lineColor: 1, fillColor: 1 }, D = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","), Y = { x: "position", y: "position", tileX: "tilePosition", tileY: "tilePosition" }, j = { colorMatrixFilter: 1, saturation: 1, contrast: 1, hue: 1, colorize: 1, colorizeAmount: 1, brightness: 1, combineCMF: 1 }, k = Math.PI / 180, B = function (t) { return "string" == typeof t }, E = function (t) { return B(t) && "=" === t.charAt(1) ? t.substr(0, 2) + parseFloat(t.substr(2)) * k : t * k }, G = function (t, r) { return r.set(r.t, r.p, 1 === t ? r.e : Math.round(1e5 * (r.s + r.c * t)) / 1e5, r) }, L = function (t, r, i, o, e, s) { var l, a, u = 360 * (s ? k : 1), c = B(e), h = c && "=" === e.charAt(1) ? +(e.charAt(0) + "1") : 0, f = parseFloat(h ? e.substr(2) : e) * (s ? k : 1), p = h ? f * h : f - o, g = o + p; return c && ("short" === (l = e.split("_")[1]) && (p %= u) !== p % (u / 2) && (p += p < 0 ? u : -u), "cw" === l && p < 0 ? p = (p + 1e10 * u) % u - ~~(p / u) * u : "ccw" === l && p > 0 && (p = (p - 1e10 * u) % u - ~~(p / u) * u)), t._pt = a = new n(t._pt, r, i, o, p, G), a.e = g, a }, N = function () { u() && (r = window, t = o = c(), e = e || r.PIXI, i = function (r) { return t.utils.splitColor("0x" === (r + "").substr(0, 2) ? "#" + r.substr(2) : r) }) }; for (l = 0; l < D.length; l++)a = D[l], Y[a + "X"] = a, Y[a + "Y"] = a; var R = { version: "3.5.1", name: "pixi", register: function (r, i, o) { t = r, n = o, s = i.getSetter, N() }, registerPIXI: function (t) { e = t }, init: function (t, r, i, o, s) { if (e || N(), !t instanceof e.DisplayObject) return !1; var l, a, u, c, h, f, p, g, d, x = "4" === e.VERSION.charAt(0); for (f in r) { if (l = Y[f], u = r[f], l) a = ~f.charAt(f.length - 1).toLowerCase().indexOf("x") ? "x" : "y", this.add(t[l], a, t[l][a], "skew" === l ? E(u) : u); else if ("scale" === f || "anchor" === f || "pivot" === f || "tileScale" === f) this.add(t[f], "x", t[f].x, u), this.add(t[f], "y", t[f].y, u); else if ("rotation" === f || "angle" === f) L(this, t, f, t[f], u, "rotation" === f); else if (j[f]) c || (y(t, r.colorMatrixFilter || r, this), c = !0); else if ("blur" === f || "blurX" === f || "blurY" === f || "blurPadding" === f) { if (h = M(t, "BlurFilter"), this.add(h, f, h[f], u), 0 !== r.blurPadding) for (p = r.blurPadding || 2 * Math.max(h[f], u), g = t.filters.length; --g > -1;)t.filters[g].padding = Math.max(t.filters[g].padding, p) } else if (S[f]) if (("lineColor" === f || "fillColor" === f) && t instanceof e.Graphics) for (d = (t.geometry || t).graphicsData, this._pt = new n(this._pt, t, f, 0, 0, I, { g: t.geometry || t }), g = d.length; --g > -1;)O(x ? d[g] : d[g][f.substr(0, 4) + "Style"], x ? f : "color", u, this); else O(t, f, u, this); else "autoAlpha" === f ? (this._pt = new n(this._pt, t, "visible", 0, 0, X), this.add(t, "alpha", t.alpha, u), this._props.push("alpha", "visible")) : "resolution" !== f && this.add(t, f, "get", u); this._props.push(f) } } }; exports.default = exports.PixiPlugin = R, c() && t.registerPlugin(R);
    }, {}], "aDqt": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getText = F, exports.splitInnerHTML = C, exports.emojiSafeSplit = E, exports.emojiExp = void 0; var D = /(^\s+|\s+$)/g, u = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/; function F(D) { var u = D.nodeType, C = ""; if (1 === u || 9 === u || 11 === u) { if ("string" == typeof D.textContent) return D.textContent; for (D = D.firstChild; D; D = D.nextSibling)C += F(D) } else if (3 === u || 4 === u) return D.nodeValue; return C } function C(D, u, F) { for (var C = D.firstChild, B = []; C;)3 === C.nodeType ? B.push.apply(B, E((C.nodeValue + "").replace(/^\n+/g, "").replace(/\s+/g, " "), u, F)) : "br" === (C.nodeName + "").toLowerCase() ? B[B.length - 1] += "<br>" : B.push(C.outerHTML), C = C.nextSibling; return B } function E(F, C, E) { if (F += "", E && (F = F.replace(D, "")), C && "" !== C) return F.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(C); for (var B, A, e = [], t = F.length, r = 0; r < t; r++)((A = F.charAt(r)).charCodeAt(0) >= 55296 && A.charCodeAt(0) <= 56319 || F.charCodeAt(r + 1) >= 65024 && F.charCodeAt(r + 1) <= 65039) && (B = ((F.substr(r, 12).split(u) || [])[1] || "").length || 2, A = F.substr(r, B), e.emoji = 1, r += B - 1), e.push(">" === A ? "&gt;" : "<" === A ? "&lt;" : A); return e } exports.emojiExp = u;
    }, {}], "SvsE": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = exports.TextPlugin = void 0; var e, t, i = require("./utils/strings.js"), s = function () { return e || "undefined" != typeof window && (e = window.gsap) && e.registerPlugin && e }, n = { version: "3.5.1", name: "text", init: function (e, s, n) { var l, r, a, o, p, h, d, f, u = e.nodeName.toUpperCase(); if (this.svg = e.getBBox && ("TEXT" === u || "TSPAN" === u), !("innerHTML" in e || this.svg)) return !1; if (this.target = e, "object" != typeof s && (s = { value: s }), "value" in s) { for (this.delimiter = s.delimiter || "", a = (0, i.splitInnerHTML)(e, this.delimiter), t || (t = document.createElement("div")), t.innerHTML = s.value, r = (0, i.splitInnerHTML)(t, this.delimiter), this.from = n._from, this.from && (u = a, a = r, r = u), this.hasClass = !(!s.newClass && !s.oldClass), this.newClass = s.newClass, this.oldClass = s.oldClass, l = (u = a.length - r.length) < 0 ? a : r, this.fillChar = s.fillChar || (s.padSpace ? "&nbsp;" : ""), u < 0 && (u = -u); --u > -1;)l.push(this.fillChar); if ("diff" === s.type) { for (o = 0, p = [], h = [], d = "", u = 0; u < r.length; u++)(f = r[u]) === a[u] ? d += f : (p[o] = d + f, h[o++] = d + a[u], d = ""); r = p, a = h, d && (r.push(d), a.push(d)) } s.speed && n.duration(Math.min(.05 / s.speed * l.length, s.maxDuration || 9999)), this.original = a, this.text = r, this._props.push("text") } else this.text = this.original = [""] }, render: function (e, t) { e > 1 ? e = 1 : e < 0 && (e = 0), t.from && (e = 1 - e); var i, s, n, l = t.text, r = t.hasClass, a = t.newClass, o = t.oldClass, p = t.delimiter, h = t.target, d = t.fillChar, f = t.original, u = l.length, g = e * u + .5 | 0; r ? (s = o && g !== u, n = ((i = a && g) ? "<span class='" + a + "'>" : "") + l.slice(0, g).join(p) + (i ? "</span>" : "") + (s ? "<span class='" + o + "'>" : "") + p + f.slice(g).join(p) + (s ? "</span>" : "")) : n = l.slice(0, g).join(p) + p + f.slice(g).join(p), t.svg ? h.textContent = n : h.innerHTML = "&nbsp;" === d && ~n.indexOf("  ") ? n.split("  ").join("&nbsp;&nbsp;") : n } }; exports.default = exports.TextPlugin = n, n.splitInnerHTML = i.splitInnerHTML, n.emojiSafeSplit = i.emojiSafeSplit, n.getText = i.getText, s() && e.registerPlugin(n);
    }, { "./utils/strings.js": "aDqt" }], "am8F": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var e = { gsap: !0, TweenMax: !0, TweenLite: !0, TimelineMax: !0, TimelineLite: !0, Power0: !0, Power1: !0, Power2: !0, Power3: !0, Power4: !0, Linear: !0, Quad: !0, Cubic: !0, Quart: !0, Quint: !0, Strong: !0, Elastic: !0, Back: !0, SteppedEase: !0, Bounce: !0, Sine: !0, Expo: !0, Circ: !0, wrap: !0, wrapYoyo: !0, distribute: !0, random: !0, snap: !0, normalize: !0, getUnit: !0, clamp: !0, splitColor: !0, toArray: !0, mapRange: !0, pipe: !0, unitize: !0, interpolate: !0, shuffle: !0, CSSPlugin: !0 }; Object.defineProperty(exports, "TweenLite", { enumerable: !0, get: function () { return r.TweenLite } }), Object.defineProperty(exports, "TimelineMax", { enumerable: !0, get: function () { return r.TimelineMax } }), Object.defineProperty(exports, "TimelineLite", { enumerable: !0, get: function () { return r.TimelineLite } }), Object.defineProperty(exports, "Power0", { enumerable: !0, get: function () { return r.Power0 } }), Object.defineProperty(exports, "Power1", { enumerable: !0, get: function () { return r.Power1 } }), Object.defineProperty(exports, "Power2", { enumerable: !0, get: function () { return r.Power2 } }), Object.defineProperty(exports, "Power3", { enumerable: !0, get: function () { return r.Power3 } }), Object.defineProperty(exports, "Power4", { enumerable: !0, get: function () { return r.Power4 } }), Object.defineProperty(exports, "Linear", { enumerable: !0, get: function () { return r.Linear } }), Object.defineProperty(exports, "Quad", { enumerable: !0, get: function () { return r.Quad } }), Object.defineProperty(exports, "Cubic", { enumerable: !0, get: function () { return r.Cubic } }), Object.defineProperty(exports, "Quart", { enumerable: !0, get: function () { return r.Quart } }), Object.defineProperty(exports, "Quint", { enumerable: !0, get: function () { return r.Quint } }), Object.defineProperty(exports, "Strong", { enumerable: !0, get: function () { return r.Strong } }), Object.defineProperty(exports, "Elastic", { enumerable: !0, get: function () { return r.Elastic } }), Object.defineProperty(exports, "Back", { enumerable: !0, get: function () { return r.Back } }), Object.defineProperty(exports, "SteppedEase", { enumerable: !0, get: function () { return r.SteppedEase } }), Object.defineProperty(exports, "Bounce", { enumerable: !0, get: function () { return r.Bounce } }), Object.defineProperty(exports, "Sine", { enumerable: !0, get: function () { return r.Sine } }), Object.defineProperty(exports, "Expo", { enumerable: !0, get: function () { return r.Expo } }), Object.defineProperty(exports, "Circ", { enumerable: !0, get: function () { return r.Circ } }), Object.defineProperty(exports, "wrap", { enumerable: !0, get: function () { return r.wrap } }), Object.defineProperty(exports, "wrapYoyo", { enumerable: !0, get: function () { return r.wrapYoyo } }), Object.defineProperty(exports, "distribute", { enumerable: !0, get: function () { return r.distribute } }), Object.defineProperty(exports, "random", { enumerable: !0, get: function () { return r.random } }), Object.defineProperty(exports, "snap", { enumerable: !0, get: function () { return r.snap } }), Object.defineProperty(exports, "normalize", { enumerable: !0, get: function () { return r.normalize } }), Object.defineProperty(exports, "getUnit", { enumerable: !0, get: function () { return r.getUnit } }), Object.defineProperty(exports, "clamp", { enumerable: !0, get: function () { return r.clamp } }), Object.defineProperty(exports, "splitColor", { enumerable: !0, get: function () { return r.splitColor } }), Object.defineProperty(exports, "toArray", { enumerable: !0, get: function () { return r.toArray } }), Object.defineProperty(exports, "mapRange", { enumerable: !0, get: function () { return r.mapRange } }), Object.defineProperty(exports, "pipe", { enumerable: !0, get: function () { return r.pipe } }), Object.defineProperty(exports, "unitize", { enumerable: !0, get: function () { return r.unitize } }), Object.defineProperty(exports, "interpolate", { enumerable: !0, get: function () { return r.interpolate } }), Object.defineProperty(exports, "shuffle", { enumerable: !0, get: function () { return r.shuffle } }), Object.defineProperty(exports, "CSSPlugin", { enumerable: !0, get: function () { return t.default } }), exports.TweenMax = exports.default = exports.gsap = void 0; var r = d(require("./gsap-core.js")), t = s(require("./CSSPlugin.js")), n = require("./Draggable.js"); Object.keys(n).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return n[r] } })) }); var o = require("./CSSRulePlugin.js"); Object.keys(o).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return o[r] } })) }); var u = require("./EaselPlugin.js"); Object.keys(u).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return u[r] } })) }); var i = require("./EasePack.js"); Object.keys(i).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return i[r] } })) }); var p = require("./MotionPathPlugin.js"); Object.keys(p).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return p[r] } })) }); var a = require("./PixiPlugin.js"); Object.keys(a).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return a[r] } })) }); var c = require("./ScrollToPlugin.js"); Object.keys(c).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return c[r] } })) }); var f = require("./ScrollTrigger.js"); Object.keys(f).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return f[r] } })) }); var l = require("./TextPlugin.js"); function s(e) { return e && e.__esModule ? e : { default: e } } function b() { if ("function" != typeof WeakMap) return null; var e = new WeakMap; return b = function () { return e }, e } function d(e) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var r = b(); if (r && r.has(e)) return r.get(e); var t = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o)) { var u = n ? Object.getOwnPropertyDescriptor(e, o) : null; u && (u.get || u.set) ? Object.defineProperty(t, o, u) : t[o] = e[o] } return t.default = e, r && r.set(e, t), t } Object.keys(l).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return l[r] } })) }); var y = r.default.registerPlugin(t.default) || r.default, P = y.core.Tween; exports.TweenMax = P, exports.default = exports.gsap = y;
    }, { "./gsap-core.js": "TNS6", "./CSSPlugin.js": "bp4Z", "./Draggable.js": "Qw94", "./CSSRulePlugin.js": "ZcgQ", "./EaselPlugin.js": "LHlC", "./EasePack.js": "bxmL", "./MotionPathPlugin.js": "DOrM", "./PixiPlugin.js": "Y7PD", "./ScrollToPlugin.js": "jhqH", "./ScrollTrigger.js": "TgBN", "./TextPlugin.js": "SvsE" }], "lyKV": [function (require, module, exports) {
        var define;
        var global = arguments[3];
        var e, t = arguments[3]; !function () { "use strict"; var n = function () { this.init() }; n.prototype = { init: function () { var e = this || o; return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e }, volume: function (e) { var t = this || o; if (e = parseFloat(e), t.ctx || l(), void 0 !== e && e >= 0 && e <= 1) { if (t._volume = e, t._muted) return t; t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, o.ctx.currentTime); for (var n = 0; n < t._howls.length; n++)if (!t._howls[n]._webAudio) for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) { var a = t._howls[n]._soundById(r[i]); a && a._node && (a._node.volume = a._volume * e) } return t } return t._volume }, mute: function (e) { var t = this || o; t.ctx || l(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, o.ctx.currentTime); for (var n = 0; n < t._howls.length; n++)if (!t._howls[n]._webAudio) for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) { var a = t._howls[n]._soundById(r[i]); a && a._node && (a._node.muted = !!e || a._muted) } return t }, stop: function () { for (var e = this || o, t = 0; t < e._howls.length; t++)e._howls[t].stop(); return e }, unload: function () { for (var e = this || o, t = e._howls.length - 1; t >= 0; t--)e._howls[t].unload(); return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, l()), e }, codecs: function (e) { return (this || o)._codecs[e.replace(/^x-/, "")] }, _setup: function () { var e = this || o; if (e.state = e.ctx && e.ctx.state || "suspended", e._autoSuspend(), !e.usingWebAudio) if ("undefined" != typeof Audio) try { void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay") } catch (t) { e.noAudio = !0 } else e.noAudio = !0; try { (new Audio).muted && (e.noAudio = !0) } catch (t) { } return e.noAudio || e._setupCodecs(), e }, _setupCodecs: function () { var e = this || o, t = null; try { t = "undefined" != typeof Audio ? new Audio : null } catch (_) { return e } if (!t || "function" != typeof t.canPlayType) return e; var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""), r = e._navigator ? e._navigator.userAgent : "", i = r.match(/OPR\/([0-6].)/g), a = i && parseInt(i[0].split("/")[1], 10) < 33, s = -1 !== r.indexOf("Safari") && -1 === r.indexOf("Chrome"), u = r.match(/Version\/(.*?) /), d = s && u && parseInt(u[1], 10) < 15; return e._codecs = { mp3: !(a || !n && !t.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!n, opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !(d || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !(d || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "") }, e }, _unlockAudio: function () { var e = this || o; if (!e._audioUnlocked && e.ctx) { e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050); var t = function (n) { for (; e._html5AudioPool.length < e.html5PoolSize;)try { var o = new Audio; o._unlocked = !0, e._releaseHtml5Audio(o) } catch (n) { e.noAudio = !0; break } for (var r = 0; r < e._howls.length; r++)if (!e._howls[r]._webAudio) for (var i = e._howls[r]._getSoundIds(), a = 0; a < i.length; a++) { var s = e._howls[r]._soundById(i[a]); s && s._node && !s._node._unlocked && (s._node._unlocked = !0, s._node.load()) } e._autoResume(); var u = e.ctx.createBufferSource(); u.buffer = e._scratchBuffer, u.connect(e.ctx.destination), void 0 === u.start ? u.noteOn(0) : u.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), u.onended = function () { u.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", t, !0), document.removeEventListener("touchend", t, !0), document.removeEventListener("click", t, !0), document.removeEventListener("keydown", t, !0); for (var n = 0; n < e._howls.length; n++)e._howls[n]._emit("unlock") } }; return document.addEventListener("touchstart", t, !0), document.addEventListener("touchend", t, !0), document.addEventListener("click", t, !0), document.addEventListener("keydown", t, !0), e } }, _obtainHtml5Audio: function () { var e = this || o; if (e._html5AudioPool.length) return e._html5AudioPool.pop(); var t = (new Audio).play(); return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch(function () { console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.") }), new Audio }, _releaseHtml5Audio: function (e) { var t = this || o; return e._unlocked && t._html5AudioPool.push(e), t }, _autoSuspend: function () { var e = this; if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && o.usingWebAudio) { for (var t = 0; t < e._howls.length; t++)if (e._howls[t]._webAudio) for (var n = 0; n < e._howls[t]._sounds.length; n++)if (!e._howls[t]._sounds[n]._paused) return e; return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function () { if (e.autoSuspend) { e._suspendTimer = null, e.state = "suspending"; var t = function () { e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume()) }; e.ctx.suspend().then(t, t) } }, 3e4), e } }, _autoResume: function () { var e = this; if (e.ctx && void 0 !== e.ctx.resume && o.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then(function () { e.state = "running"; for (var t = 0; t < e._howls.length; t++)e._howls[t]._emit("resume") }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e } }; var o = new n, r = function (e) { e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.") }; r.prototype = { init: function (e) { var t = this; return o.ctx || l(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhr = { method: e.xhr && e.xhr.method ? e.xhr.method : "GET", headers: e.xhr && e.xhr.headers ? e.xhr.headers : null, withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials }, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{ fn: e.onend }] : [], t._onfade = e.onfade ? [{ fn: e.onfade }] : [], t._onload = e.onload ? [{ fn: e.onload }] : [], t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : [], t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : [], t._onpause = e.onpause ? [{ fn: e.onpause }] : [], t._onplay = e.onplay ? [{ fn: e.onplay }] : [], t._onstop = e.onstop ? [{ fn: e.onstop }] : [], t._onmute = e.onmute ? [{ fn: e.onmute }] : [], t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : [], t._onrate = e.onrate ? [{ fn: e.onrate }] : [], t._onseek = e.onseek ? [{ fn: e.onseek }] : [], t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : [], t._onresume = [], t._webAudio = o.usingWebAudio && !t._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(t), t._autoplay && t._queue.push({ event: "play", action: function () { t.play() } }), t._preload && "none" !== t._preload && t.load(), t }, load: function () { var e = null; if (o.noAudio) this._emit("loaderror", null, "No audio support."); else { "string" == typeof this._src && (this._src = [this._src]); for (var t = 0; t < this._src.length; t++) { var n, r; if (this._format && this._format[t]) n = this._format[t]; else { if ("string" != typeof (r = this._src[t])) { this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue } (n = /^data:audio\/([^;,]+);/i.exec(r)) || (n = /\.([^.]+)$/.exec(r.split("?", 1)[0])), n && (n = n[1].toLowerCase()) } if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) { e = this._src[t]; break } } if (e) return this._src = e, this._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new i(this), this._webAudio && s(this), this; this._emit("loaderror", null, "No codec support for selected audio sources.") } }, play: function (e, t) { var n = this, r = null; if ("number" == typeof e) r = e, e = null; else { if ("string" == typeof e && "loaded" === n._state && !n._sprite[e]) return null; if (void 0 === e && (e = "__default", !n._playLock)) { for (var i = 0, a = 0; a < n._sounds.length; a++)n._sounds[a]._paused && !n._sounds[a]._ended && (i++, r = n._sounds[a]._id); 1 === i ? e = null : r = null } } var s = r ? n._soundById(r) : n._inactiveSound(); if (!s) return null; if (r && !e && (e = s._sprite || "__default"), "loaded" !== n._state) { s._sprite = e, s._ended = !1; var u = s._id; return n._queue.push({ event: "play", action: function () { n.play(u) } }), u } if (r && !s._paused) return t || n._loadQueue("play"), s._id; n._webAudio && o._autoResume(); var d = Math.max(0, s._seek > 0 ? s._seek : n._sprite[e][0] / 1e3), _ = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - d), l = 1e3 * _ / Math.abs(s._rate), c = n._sprite[e][0] / 1e3, p = (n._sprite[e][0] + n._sprite[e][1]) / 1e3; s._sprite = e, s._ended = !1; var f = function () { s._paused = !1, s._seek = d, s._start = c, s._stop = p, s._loop = !(!s._loop && !n._sprite[e][2]) }; if (!(d >= p)) { var h = s._node; if (n._webAudio) { var m = function () { n._playLock = !1, f(), n._refreshBuffer(s); var e = s._muted || n._muted ? 0 : s._volume; h.gain.setValueAtTime(e, o.ctx.currentTime), s._playStart = o.ctx.currentTime, void 0 === h.bufferSource.start ? s._loop ? h.bufferSource.noteGrainOn(0, d, 86400) : h.bufferSource.noteGrainOn(0, d, _) : s._loop ? h.bufferSource.start(0, d, 86400) : h.bufferSource.start(0, d, _), l !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), l)), t || setTimeout(function () { n._emit("play", s._id), n._loadQueue() }, 0) }; "running" === o.state && "interrupted" !== o.ctx.state ? m() : (n._playLock = !0, n.once("resume", m), n._clearTimer(s._id)) } else { var v = function () { h.currentTime = d, h.muted = s._muted || n._muted || o._muted || h.muted, h.volume = s._volume * o.volume(), h.playbackRate = s._rate; try { var r = h.play(); if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (n._playLock = !0, f(), r.then(function () { n._playLock = !1, h._unlocked = !0, t ? n._loadQueue() : n._emit("play", s._id) }).catch(function () { n._playLock = !1, n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), s._ended = !0, s._paused = !0 })) : t || (n._playLock = !1, f(), n._emit("play", s._id)), h.playbackRate = s._rate, h.paused) return void n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); "__default" !== e || s._loop ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), l) : (n._endTimers[s._id] = function () { n._ended(s), h.removeEventListener("ended", n._endTimers[s._id], !1) }, h.addEventListener("ended", n._endTimers[s._id], !1)) } catch (i) { n._emit("playerror", s._id, i) } }; "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === h.src && (h.src = n._src, h.load()); var A = window && window.ejecta || !h.readyState && o._navigator.isCocoonJS; if (h.readyState >= 3 || A) v(); else { n._playLock = !0, n._state = "loading"; var y = function () { n._state = "loaded", v(), h.removeEventListener(o._canPlayEvent, y, !1) }; h.addEventListener(o._canPlayEvent, y, !1), n._clearTimer(s._id) } } return s._id } n._ended(s) }, pause: function (e) { var t = this; if ("loaded" !== t._state || t._playLock) return t._queue.push({ event: "pause", action: function () { t.pause(e) } }), t; for (var n = t._getSoundIds(e), o = 0; o < n.length; o++) { t._clearTimer(n[o]); var r = t._soundById(n[o]); if (r && !r._paused && (r._seek = t.seek(n[o]), r._rateSeek = 0, r._paused = !0, t._stopFade(n[o]), r._node)) if (t._webAudio) { if (!r._node.bufferSource) continue; void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), t._cleanBuffer(r._node) } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause(); arguments[1] || t._emit("pause", r ? r._id : null) } return t }, stop: function (e, t) { var n = this; if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "stop", action: function () { n.stop(e) } }), n; for (var o = n._getSoundIds(e), r = 0; r < o.length; r++) { n._clearTimer(o[r]); var i = n._soundById(o[r]); i && (i._seek = i._start || 0, i._rateSeek = 0, i._paused = !0, i._ended = !0, n._stopFade(o[r]), i._node && (n._webAudio ? i._node.bufferSource && (void 0 === i._node.bufferSource.stop ? i._node.bufferSource.noteOff(0) : i._node.bufferSource.stop(0), n._cleanBuffer(i._node)) : isNaN(i._node.duration) && i._node.duration !== 1 / 0 || (i._node.currentTime = i._start || 0, i._node.pause(), i._node.duration === 1 / 0 && n._clearSound(i._node))), t || n._emit("stop", i._id)) } return n }, mute: function (e, t) { var n = this; if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "mute", action: function () { n.mute(e, t) } }), n; if (void 0 === t) { if ("boolean" != typeof e) return n._muted; n._muted = e } for (var r = n._getSoundIds(t), i = 0; i < r.length; i++) { var a = n._soundById(r[i]); a && (a._muted = e, a._interval && n._stopFade(a._id), n._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, o.ctx.currentTime) : a._node && (a._node.muted = !!o._muted || e), n._emit("mute", a._id)) } return n }, volume: function () { var e, t, n, r = this, i = arguments; if (0 === i.length) return r._volume; if (1 === i.length || 2 === i.length && void 0 === i[1] ? r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) : i.length >= 2 && (e = parseFloat(i[0]), t = parseInt(i[1], 10)), !(void 0 !== e && e >= 0 && e <= 1)) return (n = t ? r._soundById(t) : r._sounds[0]) ? n._volume : 0; if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "volume", action: function () { r.volume.apply(r, i) } }), r; void 0 === t && (r._volume = e), t = r._getSoundIds(t); for (var a = 0; a < t.length; a++)(n = r._soundById(t[a])) && (n._volume = e, i[2] || r._stopFade(t[a]), r._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, o.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * o.volume()), r._emit("volume", n._id)); return r }, fade: function (e, t, n, r) { var i = this; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "fade", action: function () { i.fade(e, t, n, r) } }), i; e = Math.min(Math.max(0, parseFloat(e)), 1), t = Math.min(Math.max(0, parseFloat(t)), 1), n = parseFloat(n), i.volume(e, r); for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) { var u = i._soundById(a[s]); if (u) { if (r || i._stopFade(a[s]), i._webAudio && !u._muted) { var d = o.ctx.currentTime, _ = d + n / 1e3; u._volume = e, u._node.gain.setValueAtTime(e, d), u._node.gain.linearRampToValueAtTime(t, _) } i._startFadeInterval(u, e, t, n, a[s], void 0 === r) } } return i }, _startFadeInterval: function (e, t, n, o, r, i) { var a = this, s = t, u = n - t, d = Math.abs(u / .01), _ = Math.max(4, d > 0 ? o / d : o), l = Date.now(); e._fadeTo = n, e._interval = setInterval(function () { var r = (Date.now() - l) / o; l = Date.now(), s += u * r, s = Math.round(100 * s) / 100, s = u < 0 ? Math.max(n, s) : Math.min(n, s), a._webAudio ? e._volume = s : a.volume(s, e._id, !0), i && (a._volume = s), (n < t && s <= n || n > t && s >= n) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, a.volume(n, e._id), a._emit("fade", e._id)) }, _) }, _stopFade: function (e) { var t = this._soundById(e); return t && t._interval && (this._webAudio && t._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(t._interval), t._interval = null, this.volume(t._fadeTo, e), t._fadeTo = null, this._emit("fade", e)), this }, loop: function () { var e, t, n, o = arguments; if (0 === o.length) return this._loop; if (1 === o.length) { if ("boolean" != typeof o[0]) return !!(n = this._soundById(parseInt(o[0], 10))) && n._loop; e = o[0], this._loop = e } else 2 === o.length && (e = o[0], t = parseInt(o[1], 10)); for (var r = this._getSoundIds(t), i = 0; i < r.length; i++)(n = this._soundById(r[i])) && (n._loop = e, this._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e, e && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop, this.playing(r[i]) && (this.pause(r[i], !0), this.play(r[i], !0))))); return this }, rate: function () { var e, t, n, r = this, i = arguments; if (0 === i.length) t = r._sounds[0]._id; else if (1 === i.length) { r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) } else 2 === i.length && (e = parseFloat(i[0]), t = parseInt(i[1], 10)); if ("number" != typeof e) return (n = r._soundById(t)) ? n._rate : r._rate; if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "rate", action: function () { r.rate.apply(r, i) } }), r; void 0 === t && (r._rate = e), t = r._getSoundIds(t); for (var a = 0; a < t.length; a++)if (n = r._soundById(t[a])) { r.playing(t[a]) && (n._rateSeek = r.seek(t[a]), n._playStart = r._webAudio ? o.ctx.currentTime : n._playStart), n._rate = e, r._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, o.ctx.currentTime) : n._node && (n._node.playbackRate = e); var s = r.seek(t[a]), u = 1e3 * ((r._sprite[n._sprite][0] + r._sprite[n._sprite][1]) / 1e3 - s) / Math.abs(n._rate); !r._endTimers[t[a]] && n._paused || (r._clearTimer(t[a]), r._endTimers[t[a]] = setTimeout(r._ended.bind(r, n), u)), r._emit("rate", n._id) } return r }, seek: function () { var e, t, n = this, r = arguments; if (0 === r.length) n._sounds.length && (t = n._sounds[0]._id); else if (1 === r.length) { n._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : n._sounds.length && (t = n._sounds[0]._id, e = parseFloat(r[0])) } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10)); if (void 0 === t) return 0; if ("number" == typeof e && ("loaded" !== n._state || n._playLock)) return n._queue.push({ event: "seek", action: function () { n.seek.apply(n, r) } }), n; var i = n._soundById(t); if (i) { if (!("number" == typeof e && e >= 0)) { if (n._webAudio) { var a = n.playing(t) ? o.ctx.currentTime - i._playStart : 0, s = i._rateSeek ? i._rateSeek - i._seek : 0; return i._seek + (s + a * Math.abs(i._rate)) } return i._node.currentTime } var u = n.playing(t); u && n.pause(t, !0), i._seek = e, i._ended = !1, n._clearTimer(t), n._webAudio || !i._node || isNaN(i._node.duration) || (i._node.currentTime = e); var d = function () { u && n.play(t, !0), n._emit("seek", t) }; if (u && !n._webAudio) { var _ = function () { n._playLock ? setTimeout(_, 0) : d() }; setTimeout(_, 0) } else d() } return n }, playing: function (e) { if ("number" == typeof e) { var t = this._soundById(e); return !!t && !t._paused } for (var n = 0; n < this._sounds.length; n++)if (!this._sounds[n]._paused) return !0; return !1 }, duration: function (e) { var t = this._duration, n = this._soundById(e); return n && (t = this._sprite[n._sprite][1] / 1e3), t }, state: function () { return this._state }, unload: function () { for (var e = this, t = e._sounds, n = 0; n < t.length; n++)t[n]._paused || e.stop(t[n]._id), e._webAudio || (e._clearSound(t[n]._node), t[n]._node.removeEventListener("error", t[n]._errorFn, !1), t[n]._node.removeEventListener(o._canPlayEvent, t[n]._loadFn, !1), t[n]._node.removeEventListener("ended", t[n]._endFn, !1), o._releaseHtml5Audio(t[n]._node)), delete t[n]._node, e._clearTimer(t[n]._id); var r = o._howls.indexOf(e); r >= 0 && o._howls.splice(r, 1); var i = !0; for (n = 0; n < o._howls.length; n++)if (o._howls[n]._src === e._src || e._src.indexOf(o._howls[n]._src) >= 0) { i = !1; break } return a && i && delete a[e._src], o.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null }, on: function (e, t, n, o) { var r = this["_on" + e]; return "function" == typeof t && r.push(o ? { id: n, fn: t, once: o } : { id: n, fn: t }), this }, off: function (e, t, n) { var o = this["_on" + e], r = 0; if ("number" == typeof t && (n = t, t = null), t || n) for (r = 0; r < o.length; r++) { var i = n === o[r].id; if (t === o[r].fn && i || !t && i) { o.splice(r, 1); break } } else if (e) this["_on" + e] = []; else { var a = Object.keys(this); for (r = 0; r < a.length; r++)0 === a[r].indexOf("_on") && Array.isArray(this[a[r]]) && (this[a[r]] = []) } return this }, once: function (e, t, n) { return this.on(e, t, n, 1), this }, _emit: function (e, t, n) { for (var o = this["_on" + e], r = o.length - 1; r >= 0; r--)o[r].id && o[r].id !== t && "load" !== e || (setTimeout(function (e) { e.call(this, t, n) }.bind(this, o[r].fn), 0), o[r].once && this.off(e, o[r].fn, o[r].id)); return this._loadQueue(e), this }, _loadQueue: function (e) { if (this._queue.length > 0) { var t = this._queue[0]; t.event === e && (this._queue.shift(), this._loadQueue()), e || t.action() } return this }, _ended: function (e) { var t = e._sprite; if (!this._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(this._ended.bind(this, e), 100), this; var n = !(!e._loop && !this._sprite[t][2]); if (this._emit("end", e._id), !this._webAudio && n && this.stop(e._id, !0).play(e._id), this._webAudio && n) { this._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = o.ctx.currentTime; var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate); this._endTimers[e._id] = setTimeout(this._ended.bind(this, e), r) } return this._webAudio && !n && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, this._clearTimer(e._id), this._cleanBuffer(e._node), o._autoSuspend()), this._webAudio || n || this.stop(e._id, !0), this }, _clearTimer: function (e) { if (this._endTimers[e]) { if ("function" != typeof this._endTimers[e]) clearTimeout(this._endTimers[e]); else { var t = this._soundById(e); t && t._node && t._node.removeEventListener("ended", this._endTimers[e], !1) } delete this._endTimers[e] } return this }, _soundById: function (e) { for (var t = 0; t < this._sounds.length; t++)if (e === this._sounds[t]._id) return this._sounds[t]; return null }, _inactiveSound: function () { this._drain(); for (var e = 0; e < this._sounds.length; e++)if (this._sounds[e]._ended) return this._sounds[e].reset(); return new i(this) }, _drain: function () { var e = this._pool, t = 0, n = 0; if (!(this._sounds.length < e)) { for (n = 0; n < this._sounds.length; n++)this._sounds[n]._ended && t++; for (n = this._sounds.length - 1; n >= 0; n--) { if (t <= e) return; this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), t--) } } }, _getSoundIds: function (e) { if (void 0 === e) { for (var t = [], n = 0; n < this._sounds.length; n++)t.push(this._sounds[n]._id); return t } return [e] }, _refreshBuffer: function (e) { return e._node.bufferSource = o.ctx.createBufferSource(), e._node.bufferSource.buffer = a[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, o.ctx.currentTime), this }, _cleanBuffer: function (e) { var t = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0; if (o._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try { e.bufferSource.buffer = o._scratchBuffer } catch (n) { } return e.bufferSource = null, this }, _clearSound: function (e) { /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") } }; var i = function (e) { this._parent = e, this.init() }; i.prototype = { init: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, e._sounds.push(this), this.create(), this }, create: function () { var e = this._parent, t = o._muted || this._muted || this._parent._muted ? 0 : this._volume; return e._webAudio ? (this._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(t, o.ctx.currentTime), this._node.paused = !0, this._node.connect(o.masterGain)) : o.noAudio || (this._node = o._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, !1), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, !1), this._node.src = e._src, this._node.preload = !0 === e._preload ? "auto" : e._preload, this._node.volume = t * o.volume(), this._node.load()), this }, reset: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, this }, _errorListener: function () { this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1) }, _loadListener: function () { var e = this._parent; e._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, !1) }, _endListener: function () { var e = this._parent; e._duration === 1 / 0 && (e._duration = Math.ceil(10 * this._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(this)), this._node.removeEventListener("ended", this._endFn, !1) } }; var a = {}, s = function (e) { var t = e._src; if (a[t]) return e._duration = a[t].duration, void _(e); if (/^data:[^;]+;base64,/.test(t)) { for (var n = atob(t.split(",")[1]), o = new Uint8Array(n.length), r = 0; r < n.length; ++r)o[r] = n.charCodeAt(r); d(o.buffer, e) } else { var i = new XMLHttpRequest; i.open(e._xhr.method, t, !0), i.withCredentials = e._xhr.withCredentials, i.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach(function (t) { i.setRequestHeader(t, e._xhr.headers[t]) }), i.onload = function () { var t = (i.status + "")[0]; "0" === t || "2" === t || "3" === t ? d(i.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + i.status + ".") }, i.onerror = function () { e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete a[t], e.load()) }, u(i) } }, u = function (e) { try { e.send() } catch (t) { e.onerror() } }, d = function (e, t) { var n = function () { t._emit("loaderror", null, "Decoding audio data failed.") }, r = function (e) { e && t._sounds.length > 0 ? (a[t._src] = e, _(t, e)) : n() }; "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(e).then(r).catch(n) : o.ctx.decodeAudioData(e, r, n) }, _ = function (e, t) { t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()) }, l = function () { if (o.usingWebAudio) { try { "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1 } catch (i) { o.usingWebAudio = !1 } o.ctx || (o.usingWebAudio = !1); var e = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform), t = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), n = t ? parseInt(t[1], 10) : null; if (e && n && n < 9) { var r = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase()); o._navigator && !r && (o.usingWebAudio = !1) } o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup() } }; "function" == typeof e && e.amd && e([], function () { return { Howler: o, Howl: r } }), "undefined" != typeof exports && (exports.Howler = o, exports.Howl = r), void 0 !== t ? (t.HowlerGlobal = n, t.Howler = o, t.Howl = r, t.Sound = i) : "undefined" != typeof window && (window.HowlerGlobal = n, window.Howler = o, window.Howl = r, window.Sound = i) }(), function () { "use strict"; var e; HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) { if (!this.ctx || !this.ctx.listener) return this; for (var t = this._howls.length - 1; t >= 0; t--)this._howls[t].stereo(e); return this }, HowlerGlobal.prototype.pos = function (e, t, n) { return this.ctx && this.ctx.listener ? (t = "number" != typeof t ? this._pos[1] : t, n = "number" != typeof n ? this._pos[2] : n, "number" != typeof e ? this._pos : (this._pos = [e, t, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this }, HowlerGlobal.prototype.orientation = function (e, t, n, o, r, i) { if (!this.ctx || !this.ctx.listener) return this; var a = this._orientation; return t = "number" != typeof t ? a[1] : t, n = "number" != typeof n ? a[2] : n, o = "number" != typeof o ? a[3] : o, r = "number" != typeof r ? a[4] : r, i = "number" != typeof i ? a[5] : i, "number" != typeof e ? a : (this._orientation = [e, t, n, o, r, i], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(o, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(i, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(e, t, n, o, r, i), this) }, Howl.prototype.init = (e = Howl.prototype.init, function (t) { return this._orientation = t.orientation || [1, 0, 0], this._stereo = t.stereo || null, this._pos = t.pos || null, this._pannerAttr = { coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360, coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360, coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0, distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse", maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4, panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF", refDistance: void 0 !== t.refDistance ? t.refDistance : 1, rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1 }, this._onstereo = t.onstereo ? [{ fn: t.onstereo }] : [], this._onpos = t.onpos ? [{ fn: t.onpos }] : [], this._onorientation = t.onorientation ? [{ fn: t.onorientation }] : [], e.call(this, t) }), Howl.prototype.stereo = function (e, n) { var o = this; if (!o._webAudio) return o; if ("loaded" !== o._state) return o._queue.push({ event: "stereo", action: function () { o.stereo(e, n) } }), o; var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo"; if (void 0 === n) { if ("number" != typeof e) return o._stereo; o._stereo = e, o._pos = [e, 0, 0] } for (var i = o._getSoundIds(n), a = 0; a < i.length; a++) { var s = o._soundById(i[a]); if (s) { if ("number" != typeof e) return s._stereo; s._stereo = e, s._pos = [e, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || t(s, r), "spatial" === r ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(e, 0, 0) : s._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), o._emit("stereo", s._id) } } return o }, Howl.prototype.pos = function (e, n, o, r) { var i = this; if (!i._webAudio) return i; if ("loaded" !== i._state) return i._queue.push({ event: "pos", action: function () { i.pos(e, n, o, r) } }), i; if (n = "number" != typeof n ? 0 : n, o = "number" != typeof o ? -.5 : o, void 0 === r) { if ("number" != typeof e) return i._pos; i._pos = [e, n, o] } for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) { var u = i._soundById(a[s]); if (u) { if ("number" != typeof e) return u._pos; u._pos = [e, n, o], u._node && (u._panner && !u._panner.pan || t(u, "spatial"), void 0 !== u._panner.positionX ? (u._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.positionZ.setValueAtTime(o, Howler.ctx.currentTime)) : u._panner.setPosition(e, n, o)), i._emit("pos", u._id) } } return i }, Howl.prototype.orientation = function (e, n, o, r) { var i = this; if (!i._webAudio) return i; if ("loaded" !== i._state) return i._queue.push({ event: "orientation", action: function () { i.orientation(e, n, o, r) } }), i; if (n = "number" != typeof n ? i._orientation[1] : n, o = "number" != typeof o ? i._orientation[2] : o, void 0 === r) { if ("number" != typeof e) return i._orientation; i._orientation = [e, n, o] } for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) { var u = i._soundById(a[s]); if (u) { if ("number" != typeof e) return u._orientation; u._orientation = [e, n, o], u._node && (u._panner || (u._pos || (u._pos = i._pos || [0, 0, -.5]), t(u, "spatial")), void 0 !== u._panner.orientationX ? (u._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.orientationZ.setValueAtTime(o, Howler.ctx.currentTime)) : u._panner.setOrientation(e, n, o)), i._emit("orientation", u._id) } } return i }, Howl.prototype.pannerAttr = function () { var e, n, o, r = arguments; if (!this._webAudio) return this; if (0 === r.length) return this._pannerAttr; if (1 === r.length) { if ("object" != typeof r[0]) return (o = this._soundById(parseInt(r[0], 10))) ? o._pannerAttr : this._pannerAttr; e = r[0], void 0 === n && (e.pannerAttr || (e.pannerAttr = { coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor, panningModel: e.panningModel }), this._pannerAttr = { coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : this._coneInnerAngle, coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : this._coneOuterAngle, coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : this._coneOuterGain, distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : this._distanceModel, maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : this._maxDistance, refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : this._refDistance, rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : this._rolloffFactor, panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : this._panningModel }) } else 2 === r.length && (e = r[0], n = parseInt(r[1], 10)); for (var i = this._getSoundIds(n), a = 0; a < i.length; a++)if (o = this._soundById(i[a])) { var s = o._pannerAttr; s = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : s.coneInnerAngle, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : s.coneOuterAngle, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : s.coneOuterGain, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : s.distanceModel, maxDistance: void 0 !== e.maxDistance ? e.maxDistance : s.maxDistance, refDistance: void 0 !== e.refDistance ? e.refDistance : s.refDistance, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : s.rolloffFactor, panningModel: void 0 !== e.panningModel ? e.panningModel : s.panningModel }; var u = o._panner; u ? (u.coneInnerAngle = s.coneInnerAngle, u.coneOuterAngle = s.coneOuterAngle, u.coneOuterGain = s.coneOuterGain, u.distanceModel = s.distanceModel, u.maxDistance = s.maxDistance, u.refDistance = s.refDistance, u.rolloffFactor = s.rolloffFactor, u.panningModel = s.panningModel) : (o._pos || (o._pos = this._pos || [0, 0, -.5]), t(o, "spatial")) } return this }, Sound.prototype.init = function (e) { return function () { var t = this._parent; this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, e.call(this), this._stereo ? t.stereo(this._stereo) : this._pos && t.pos(this._pos[0], this._pos[1], this._pos[2], this._id) } }(Sound.prototype.init), Sound.prototype.reset = function (e) { return function () { var t = this._parent; return this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, this._stereo ? t.stereo(this._stereo) : this._pos ? t.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, t._refreshBuffer(this)), e.call(this) } }(Sound.prototype.reset); var t = function (e, t) { "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0) } }();
    }, {}], "lPjN": [function (require, module, exports) {
        module.exports = "/sounds/peaceful-mind-astron.8fa4dde5.mp3";
    }, {}], "ejki": [function (require, module, exports) {
        module.exports = "/sounds/hummingbird-buzzing-chirping.72f2e207.mp3";
    }, {}], "x8YA": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Sound = void 0; var o = e(require("@barba/core")), i = e(require("gsap/all")), n = require("howler"), s = require("./utils/utils"); function e(o) { return o && o.__esModule ? o : { default: o } } function d(o, i) { if (!(o instanceof i)) throw new TypeError("Cannot call a class as a function") } function t(o, i) { for (var n = 0; n < i.length; n++) { var s = i[n]; s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(o, s.key, s) } } function a(o, i, n) { return i && t(o.prototype, i), n && t(o, n), o } var u = "https://www.nikka.me/wp-content/themes/the-teal-bird", l = !0, c = (l ? u : "") + require("../sounds/peaceful-mind-astron.mp3"), r = (l ? u : "") + require("../sounds/hummingbird-buzzing-chirping.mp3"), g = function () { function o() { d(this, o), s.bindMethods.call(this), this.backgroundSound, this.birdSound, this.loadingAudioToggle = document.querySelector(".loading-wrapper .loading-sound"), this.audioToggle = document.querySelector(".audio-toggle"), this.audioText = this.audioToggle.querySelector("span"), this.modal = document.querySelector(".audio-modal"), this.modalAccept = this.modal.querySelector(".accept"), this.modalCencel = this.modal.querySelector(".cancel"), this.isBackgroundSoundPlaying = !1, this.isBirdSoundPlaying = !1, this.isBirdSoundsPlayedOnce = !1, this.bindEvents() } return a(o, [{ key: "loadSoungs", value: function () { this.backgroundSound || (this.backgroundSound = new n.Howl({ src: [c], loop: !0 }), this.backgroundSound.volume(0)), this.birdSound || (this.birdSound = new n.Howl({ src: [r], loop: !0 }), this.birdSound.volume(0)) } }, { key: "bindEvents", value: function () { this.loadingAudioToggle.addEventListener("click", this.backgroundSoundToggle), this.audioToggle.addEventListener("click", this.allSoundsToggle), this.modalAccept.addEventListener("click", this.onModalAccept), this.modalCencel.addEventListener("click", this.closeModal) } }, { key: "backgroundSoundToggle", value: function () { this.loadSoungs(), this.isBirdSoundsPlayedOnce ? this.allSoundsToggle() : (this.backgroundSound.playing() || this.backgroundSound.play(), this.loadingAudioToggle.classList.contains("sound--off") ? (this.backgroundSound.fade(0, .1, 1e3), this.loadingAudioToggle.classList.remove("sound--off"), this.loadingAudioToggle.classList.add("sound--on"), this.isBackgroundSoundPlaying = !0) : this.loadingAudioToggle.classList.contains("sound--on") && (this.backgroundSound.fade(.1, 0, 1e3), this.loadingAudioToggle.classList.remove("sound--on"), this.loadingAudioToggle.classList.add("sound--off"), this.isBackgroundSoundPlaying = !1)) } }, { key: "allSoundsToggle", value: function () { this.loadSoungs(), this.backgroundSound.playing() || this.backgroundSound.play(), this.birdSound.playing() || (this.birdSound.seek(4), this.birdSound.play()), this.audioToggle.classList.contains("off") ? (this.birdSound.fade(0, .1, 1e3), this.backgroundSound.fade(0, .1, 1e3), this.audioToggle.classList.remove("off"), this.audioToggle.classList.add("on"), this.loadingAudioToggle.classList.remove("sound--off"), this.loadingAudioToggle.classList.add("sound--on"), this.audioText.innerHTML = "Music On", this.isBackgroundSoundPlaying = !0, this.isBirdSoundPlaying = !0, this.isBirdSoundsPlayedOnce || (this.isBirdSoundsPlayedOnce = !0)) : this.audioToggle.classList.contains("on") && (this.birdSound.fade(.1, 0, 1e3), this.backgroundSound.fade(.1, 0, 1e3), this.audioToggle.classList.remove("on"), this.audioToggle.classList.add("off"), this.loadingAudioToggle.classList.remove("sound--on"), this.loadingAudioToggle.classList.add("sound--off"), this.audioText.innerHTML = "Music Off", this.isBackgroundSoundPlaying = !1, this.isBirdSoundPlaying = !1) } }, { key: "onModalAccept", value: function () { var o = this; this.loadSoungs(), this.modalAccept.classList.add("clicked"), this.backgroundSoundToggle(); var i = setTimeout(function () { o.closeModal(), clearTimeout(i) }, 500) } }, { key: "closeModal", value: function () { i.default.to(this.modal, { opacity: 0, pointerEvents: "none" }) } }]), o }(); exports.Sound = g;
    }, { "@barba/core": "nGBO", "gsap/all": "am8F", "howler": "lyKV", "./utils/utils": "HUaJ", "../sounds/peaceful-mind-astron.mp3": "lPjN", "../sounds/hummingbird-buzzing-chirping.mp3": "ejki" }], "JwJh": [function (require, module, exports) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var t, i, e, s, n, h = .1, r = .06, a = !0, o = "180,184,240", u = "226,225,142", d = "226,225,224", c = document.getElementById("universe"), f = []; function y() { universe = c.getContext("2d"); for (var t = 0; t < e; t++)f[t] = new l, f[t].reset(); m() } function m() { universe.clearRect(0, 0, t, i); for (var e = f.length, s = 0; s < e; s++) { var n = f[s]; n.move(), n.fadeIn(), n.fadeOut(), n.draw() } window.requestAnimationFrame(m) } function l() { this.reset = function () { this.giant = v(3), this.comet = !this.giant && !a && v(10), this.x = w(0, t - 10), this.y = w(0, i), this.r = w(1.1, 2.6), this.dx = w(r, 6 * r) + (this.comet + 1 - 1) * r * w(50, 120) + 2 * r, this.dy = -w(r, 6 * r) - (this.comet + 1 - 1) * r * w(50, 120), this.fadingOut = null, this.fadingIn = !0, this.opacity = 0, this.opacityTresh = w(.1, 1 - .4 * (this.comet + 1 - 1)), this.do = w(5e-4, .002) + .001 * (this.comet + 1 - 1) }, this.fadeIn = function () { this.fadingIn && (this.fadingIn = !(this.opacity > this.opacityTresh), this.opacity += this.do) }, this.fadeOut = function () { this.fadingOut && (this.fadingOut = !(this.opacity < 0), this.opacity -= this.do / 2, (this.x > t || this.y < 0) && (this.fadingOut = !1, this.reset())) }, this.draw = function () { if (universe.beginPath(), this.giant) universe.fillStyle = "rgba(" + o + "," + this.opacity + ")", universe.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1); else if (this.comet) { universe.fillStyle = "rgba(" + d + "," + this.opacity + ")", universe.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1); for (var t = 0; t < 30; t++)universe.fillStyle = "rgba(" + d + "," + (this.opacity - this.opacity / 20 * t) + ")", universe.rect(this.x - this.dx / 4 * t, this.y - this.dy / 4 * t - 2, 2, 2), universe.fill() } else universe.fillStyle = "rgba(" + u + "," + this.opacity + ")", universe.rect(this.x, this.y, this.r, this.r); universe.closePath(), universe.fill() }, this.move = function () { this.x += this.dx, this.y += this.dy, !1 === this.fadingOut && this.reset(), (this.x > t - t / 4 || this.y < 0) && (this.fadingOut = !0) }, setTimeout(function () { a = !1 }, 50) } function v(t) { return Math.floor(1e3 * Math.random()) + 1 < 10 * t } function w(t, i) { return Math.random() * (i - t) + t } function g() { t = window.innerWidth, i = window.innerHeight, e = t * h, s = t > i ? i / 2 : t / 2, n = { x: t / 2, y: i / 2 }, c.setAttribute("width", t), c.setAttribute("height", i) } g(), window.addEventListener("resize", g, !1), y();
    }, {}], "QvaY": [function (require, module, exports) {

        "use strict"; var e = d(require("@barba/core")), t = d(require("@barba/router")), o = d(require("gsap")), r = d(require("./Stage")), a = d(require("./Bird")), n = d(require("./Preload")), c = require("./Welcome"), u = require("./Home"), s = require("./Project"), i = require("./About"), l = require("./Sound"), m = d(require("./constants/global")); function d(e) { return e && e.__esModule ? e : { default: e } } require("./comet"); var p = [{ path: "/", name: "home" }, { path: "project/:id", name: "project" }, { path: "/about", name: "about" }]; e.default.use(t.default, { routes: p }); var v = document.querySelector("#main_canvas"), f = new r.default(v), y = new l.Sound, q = new a.default, S = new u.Home(f, q), w = new s.SingleProject(f, q), b = new i.About(f, q); window.addEventListener("resize", function () { document.querySelector(":root").style.setProperty("--vw", window.innerWidth / 100 + "px"), document.querySelector(":root").style.setProperty("--vh", window.innerHeight / 100 + "px") }), e.default.init({ transitions: [{ name: "homepage-once", sync: !0, to: { namespace: ["home"] }, once: function () { return new Promise(function (e) { var t = new c.Welcome(f, y, e); new n.default(t.init) }) } }, { name: "other-pages-once", to: { namespace: ["project", "about"] }, once: function (e) { var t = e.next; document.querySelector(".loading-wrapper").setAttribute("style", "display: none;"); var o = document.querySelector(".header .navbar .secondary-menu .about"); "about" === t.namespace ? o.classList.add("active") : o.classList.remove("active") } }, { name: "cover", sync: !1, to: { namespace: ["home", "project", "about"] }, leave: function (e) { var t = e.current, r = e.next; return new Promise(function (e) { document.querySelector("html").classList.add("stop-scroll"); var a = document.querySelector(".page-cover").querySelectorAll(".circle"), n = document.querySelector(".header .hamburger-trigger"), c = document.querySelector(".header .navbar"); "home" === t.namespace && S.dispose(), o.default.to(a, { scale: 1, stagger: .06, ease: "elastic.out(1.2, 0.75)", onComplete: e }); var u = document.querySelector(".header .navbar .secondary-menu .about"); if ("home" !== r.namespace) { var s = document.querySelector(".header .navbar .active"); s && s.classList.remove("active") } "project" === r.namespace && o.default.to("#awwwards", { opacity: 0, pointerEvents: "none" }), "about" === r.namespace ? u.classList.add("active") : u.classList.remove("active"), m.default.isMobile && c.classList.contains("is-open") && (n.classList.remove("is-open"), c.classList.remove("is-open")); var i = document.querySelector(".flying-bird"); "home" !== r.namespace ? o.default.to(i, { opacity: 0 }) : o.default.to(i, { opacity: 1 }) }) } }], views: [{ namespace: "home", afterEnter: function () { var e = document.querySelector(".page-cover").querySelectorAll(".circle"); o.default.to(e, { scale: 0, stagger: { from: "end", amount: .8 }, ease: "expo.in", onStart: function () { window.scrollTo(0, 0) }, onComplete: function () { document.querySelector("html").classList.remove("stop-scroll"), S.init() } }) } }, { namespace: "project", afterEnter: function () { var e = document.querySelector(".page-cover").querySelectorAll(".circle"); o.default.to(e, { scale: 0, stagger: { from: "end", amount: .8 }, ease: "expo.in", onStart: function () { window.scrollTo(0, 0) }, onComplete: function () { document.querySelector("html").classList.remove("stop-scroll"), w.init() } }) }, beforeLeave: function () { w.dispose() } }, { namespace: "about", beforeLeave: function () { b.dispose() }, afterEnter: function () { var e = document.querySelector(".page-cover").querySelectorAll(".circle"); o.default.to(e, { scale: 0, stagger: { from: "end", amount: .8 }, ease: "expo.in", onStart: function () { window.scrollTo(0, 0) }, onComplete: function () { document.querySelector("html").classList.remove("stop-scroll"), b.init() } }) } }] });
    }, { "@barba/core": "nGBO", "@barba/router": "w1pc", "gsap": "TpQl", "./Stage": "CK79", "./Bird": "ygg0", "./Preload": "mDEI", "./Welcome": "XlP0", "./Home": "qPEW", "./Project": "sCyn", "./About": "XovL", "./Sound": "x8YA", "./constants/global": "Utju", "./comet": "JwJh" }]
}, {}, ["QvaY"], null)
//# sourceMappingURL=/js/js.effc8ee9.js.map